{"remainingRequest":"/Users/jonny/Desktop/myProjects/Kalaam-BE/FE/node_modules/babel-loader/lib/index.js!/Users/jonny/Desktop/myProjects/Kalaam-BE/Compiler/main.js","dependencies":[{"path":"/Users/jonny/Desktop/myProjects/Kalaam-BE/Compiler/main.js","mtime":1652678601442},{"path":"/Users/jonny/Desktop/myProjects/Kalaam-BE/FE/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/jonny/Desktop/myProjects/Kalaam-BE/FE/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0IjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmlsdGVyIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmluZCI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZvci1lYWNoIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaW5jbHVkZXMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pbmRleC1vZiI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmpvaW4iOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zcGxpY2UiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5kYXRlLnRvLXN0cmluZyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmZ1bmN0aW9uLm5hbWUiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5udW1iZXIudG8tcHJlY2lzaW9uIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnRvLXN0cmluZyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pbmNsdWRlcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5yZXBsYWNlIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnNwbGl0IjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5mb3ItZWFjaCI7CmltcG9ydCBfdG9Db25zdW1hYmxlQXJyYXkgZnJvbSAiL1VzZXJzL2pvbm55L0Rlc2t0b3AvbXlQcm9qZWN0cy9LYWxhYW0tQkUvRkUvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3RvQ29uc3VtYWJsZUFycmF5IjsKCi8qIQogKiBLYWxhYW0gdjEuMC4wCiAqIChDKSAyMDIwLTIxIFN3YW5hbmQgS2FkYW0KICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLgogKi8KLy9TRUNUSU9OIC0gSW1wb3J0aW5nIGZ1bmN0aW9uIG1vZHVsZXMKLy9UbyBjaGVjayB2YXJpYWJsZSB0eXBlczogTnVtYmVyLCBTdHJpbmcsIEFycmF5IGV0Yy4KaW1wb3J0ICogYXMgVHlwZUNoZWNrIGZyb20gJy4uL1R5cGVDaGVjay9UeXBlQ2hlY2tpbmcnOwppbXBvcnQgeyBBY3RpdmVMYW5ndWdhZUtleXdvcmRzLCBLYWxhYW1LZXl3b3JkcyB9IGZyb20gJy4uL0NvbXBpbGVyL2NvbnN0YW50cyc7CmNvbnNvbGUubG9nKCdBY3RpdmVMYW5ndWdhZUtleXdvcmRzOicsIEFjdGl2ZUxhbmd1Z2FlS2V5d29yZHMpOyAvL1RvIGNoZWNrIG90aGVyIG9wZXJhdGlvbnMgbGlrZSBNdWx0aVN0cmluZywgQXJpdGhtZXRpYyBPcGVyYXRpb24gZXRjLgoKaW1wb3J0ICogYXMgQWR2YW5jZWRUeXBlQ2hlY2sgZnJvbSAnLi4vVHlwZUNoZWNrL0FkdmFuY2VkVHlwZUNoZWNraW5nJzsgLy9UbyBmb3JtYXQgdXNlciBpbnB1dCBpbnRvIGEgcHJvcGVyIFN0cmluZywgQXJyYXkgb3IgQ29uZGl0aW9uLgoKaW1wb3J0ICogYXMgQnVpbGRPcGVyYXRpb24gZnJvbSAnLi4vU2NyaXB0cy9CdWlsZE9wZXJhdGlvbnMnOwppbXBvcnQgeyBSZW1vdmVRdW90ZXMsIFJlbW92ZUJyYWNrZXRzLCBlYXJseUNsZWFuaW5nIH0gZnJvbSAnLi4vU2NyaXB0cy9IZWxwZXJzJzsgLy9GdW5jdGlvbnMgaW1wb3J0ZWQgdG8gcHVzaCBhIHBhcnRpY3VsYXIgZGF0YSB0byBvdXIgVG9rZW5zIGFycmF5LgovL1Rva2VucyBhcnJheSBpcyBiYXNpY2FsbHkgYSBjbGVhbiwgZm9ybWF0dGVkIGFuZCBhIHdvcmQgYnkgd29yZCB2ZXJzaW9uIG9mIHJhdyBjb2RlIHByb3ZpZGVkIGJ5IHVzZXIKCmltcG9ydCB7IFB1c2hBcnJheSwgUHVzaENhbGN1bGF0aW9uLCBQdXNoQ29uZGl0aW9uYWxLZXl3b3JkLCBQdXNoQ29uZGl0aW9uLCBQdXNoRm9yTG9vcCwgUHVzaFdoaWxlTG9vcCwgUHVzaEZvckxvb3BBcnVndW1lbnRzLCBQdXNoRXhwcmVzc2lvbiwgUHVzaE5hdGl2ZU9wZXJhdGlvbiwgUHVzaEtleXdvcmQsIFB1c2hOdW1iZXIsIFB1c2hPcGVyYXRvciwgUHVzaFJlYWxUaW1lUHJpbnRPcGVyYXRpb24sIFB1c2hTdHJpbmcsIFB1c2hWYXJpYWJsZSwgUHVzaFZhcmlhYmxlVmFsdWUsIFB1c2hGdW5jdGlvbkRhdGEsIFB1c2hGdW5jdGlvbkV4ZWN1dGlvbiwgUHVzaFRvQXJyYXksIFB1c2hJbnB1dCB9IGZyb20gJy4uL1B1c2hUb2tlbnMvbWFpbic7IC8vVGhpcyBhcmUgb3RoZXIgaGVscGVyIGZ1bmN0aW9ucyB0aGF0IHdlIG5lZWQgZm9yIGEgcGFydGljdWxhciB0YXNrLiBBbGwgb2YgdGhpcyBmdW5jdGlvbnMgd2lsbCBiZSBleHBsYWluZWQgaW5kZXB0aCBhcyB3ZSBzZWUgdGhlbSBpbiBjb2RlYmFzZS4KCmltcG9ydCB7IEdldENsZWFuU291cmNlZGF0YSwgR2V0Y2xlYW5lZEV4cHJlc3Npb24sIEFkZEVsZW1lbnRUb0FycmF5LCBSZXNldFZhbHVlLCBDcmVhdGVBcnJheUVsZW1lbnQsIENhbGN1bGF0ZVZhbHVlcywgR2V0QXJyYXlvclN0cmluZ0VsZW1lbnQsIEhhbmRsZUJsb2NrcywgU3BsaXRFbGVtZW50c0FycmF5LCBTZXRWYWx1ZXMsIFB1c2hTZXRBcnJheUluZGV4VmFsdWUsIFB1c2hHZXRBcnJheUluZGV4VmFsdWUsIEdldENvbmRpdGlvblZhbHVlLCBBY2NlcHRJbnB1dGFuZFNldFZhbHVlLCBBc3NpZ25vclVwZGF0ZVZhbHVlcywgSGFuZGxlQ29uZGl0aW9ucywgZ2V0TG9vcEluZGV4U3RhcnQsIEZvckxvb3BTZXRNZXRhZGF0YSwgU2V0QXJyYXlJbmRleFZhbHVlLCBBZGR0b0V4ZWN1dGlvblN0YWNrIH0gZnJvbSAnLi4vU2NyaXB0cy9tYWluLmpzJzsKaW1wb3J0IHNjYW5uZXIgZnJvbSAnLi4vc2Nhbm5lci9tYWluJzsKaW1wb3J0ICcuLi9IZWxwZXJMaWJyYXJ5L21haW4nOwppbXBvcnQgeyBoYW5kbGVSZWFsdGltZVByaW50LCBoYW5kbGVWYXJpYWJsZSwgaGFuZGxlT3V0cHV0LCBwcmVwYXJlRnVuY3Rpb24gfSBmcm9tICcuLi9TY3JpcHRzL0hhbmRsZXJzJzsKaW1wb3J0IHsgZmluZHRva2VuUG9zaXRpb25pbkNvZGUgfSBmcm9tICcuLi9TY3JpcHRzL2ZpbmRlcnMnOwppbXBvcnQgeyBpc0ludGVycHJldGFibGVUeXBlIH0gZnJvbSAnLi4vU2NyaXB0cy90ZXN0ZXJzJzsgLy9XZSB3aWxsIGJlIGltcG9ydGluZyB0aGlzIHdob2xlIGZ1bmN0aW9uIHRvIHByYWN0aXNlLnZ1ZSBhbmQgaXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIHVzZXIgY2xpY2tzIG9uICdSVU4nCgpmdW5jdGlvbiBDb21waWxlKHNvdXJjZWNvZGUpIHsKICB0cnkgewogICAgLy9UaGlzIHdpbGwgcnVuIGZvciBldmVyeSDgpKbgpL/gpJbgpL7gpI8oKSBzdGF0ZW1lbnQgZW5jb3VudGVyZWQgaW4gdGhlIHByb2dyYW0sIG5vdCBqdXN0IGZvciBsb29wcwogICAgLy9BUkdVTUVOVFMgVE8gUHJpbnRFbmdpbmUgYXJlOgogICAgLy9Ub2tlbnMtIFRva2VucyBhcnJheQogICAgLy9tZW1vcnktIFZhcmlhYmxlLXZhbHVlIHBhaXJzIG9mIHZhcmlhYmxlcwogICAgLy9qLSBJbmRleCBvZiBhIHRva2VuIGluIFRva2VucyBhcnJheQogICAgLy9nbG9iYWwtIHNlbGYgb3Igc2VsZgogICAgLy9pdGVyYXRvciBhbmQgT3JpZ2luYWxJdGVyYXRvciBhcmUgdXNlZCB0byBwcmludCB2YWx1ZXMgaW4gZm9yIGFuZCB3aGlsZSBsb29wcy4KICAgIHZhciBQcmludEVuZ2luZSA9IGZ1bmN0aW9uIFByaW50RW5naW5lKFRva2VucywgbWVtb3J5LCBqLCBpdGVyYXRvciwgT3JpZ2luYWxJdGVyYXRvcikgewogICAgICAvL1RvIHVuZGVyc3RhbmQgd2hhdCBraW5kIG9mIGRhdGEgaXMgbmVjZXNzYXJ5IHRvIHByaW50IGEgdmFsdWUKICAgICAgLy9HZXR0aW5nIHRoZSBjdXJyZW50IHRva2VuIGFzIHRva2VuIGFuZCB2YWx1ZSB0byBiZSBwcmludGVkIGFzIE5leHRUb2tlblZhbHVlCiAgICAgIC8vZS5nLiBGb3Ig4KSm4KS/4KSW4KS+4KSPKE5hbWUpLCBOYW1lIGlzIHRoZSBOZXh0VG9rZW5WYWx1ZSBhbmQgaXQgaXMgdGhlIG9uZSB3aGljaCB3ZSB3aWxsIGhhdmUgdG8gcHJpbnQKICAgICAgdmFyIFN0cmluZ1ZhciA9IFtdOwogICAgICB2YXIgdG9rZW4gPSBUb2tlbnNbal0udmFsdWU7CiAgICAgIHZhciBOZXh0VG9rZW5WYWx1ZSA9IFRva2Vucy5uZXh0RWxlbWVudChqKS52YWx1ZTsgLy9SZW1vdmluZyB0aGUgYnJhY2tldHMsIGlmIGFueS4KCiAgICAgIHZhciBWYXJpYWJsZVRvUHJpbnQgPSBSZW1vdmVCcmFja2V0cyhOZXh0VG9rZW5WYWx1ZSk7IC8vU0VDVElPTiAtIE91dHB1dHRpbmcgdGhlIGNvZGUKICAgICAgLy8gZmluZGluZyB0aGUgdmFyaWFibGUgdmFsdWUgaW4gbWVtb3J5LiBtZW1vcnkgaXMgd2hlcmUgb3VyIFZhcmlhYmxlLXZhbHVlIHBhaXJzIGV4aXN0cy4KICAgICAgLy9UaGlzIGxvb3AgaXMgb25seSBmb3IgcHJpbnRpbmcgZGlyZWN0IHZhbHVlcyBsaWtlIHByaW50KG5hbWUpLCBwcmludChhcnJheSkKCiAgICAgIG1lbW9yeS5mb3JFYWNoKGZ1bmN0aW9uIChlbCkgewogICAgICAgIC8vSWYgd2UgaGF2ZSBhIHZhcmlhYmxlLXZhbHVlIHBhaXIgc2l0dGluZyBpbiBtZW1vcnkKICAgICAgICBpZiAoZWwubmFtZSA9PT0gVmFyaWFibGVUb1ByaW50KSB7CiAgICAgICAgICAvL2ZvciBjYWxjdWxhdGlvbnMgbGlrZSB4PWFnZW9uZSthZ2V0d28KICAgICAgICAgIC8vSWYgd2UgaGF2ZSBhbHJlYWR5IGNhbGN1bGF0ZWQgdmFsdWUgaW4gYXNzaWduZWRfdmFyaWFibGVzLCB1c2UgdGhhdCBvciBlbHNlIG1vdmUgZm9yd2FyZAogICAgICAgICAgaWYgKGFzc2lnbmVkX3ZhcmlhYmxlcy5pbmNsdWRlcyhlbCkgfHwgYXNzaWduZWRfdmFyaWFibGVzLmluY2x1ZGVzKGVsLm5hbWUpKSB7CiAgICAgICAgICAgIGhhbmRsZU91dHB1dChlbC52YWx1ZSwga2FsYWFtKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIC8vaWYgdGhlIHZhbHVlIGZvdW5kIGlzIGEgTnVtYmVyCiAgICAgICAgICAgIGlmIChpc051bWJlcihlbC52YWx1ZSkpIHsKICAgICAgICAgICAgICBoYW5kbGVPdXRwdXQoZWwudmFsdWUsIGthbGFhbSk7CiAgICAgICAgICAgICAgYXNzaWduZWRfdmFyaWFibGVzLnB1c2goZWwubmFtZSk7CiAgICAgICAgICAgIH0gLy9pZiB0aGUgdmFsdWUgZm91bmQgaXMgb3BlcmF0aW9ucyBsaWtlIGFnZT0yMDIwLTE5OTYKICAgICAgICAgICAgZWxzZSBpZiAoaXNQdXJlRXZhbChlbC52YWx1ZSkpIHsKICAgICAgICAgICAgICAgIC8vd2UgYXJlIHVzaW5nIEphdmFzY3JpcHQncyBldmFsIGZ1bmN0aW9uIHRvIGNhbGN1bGF0ZSBkaXJlY3QgYXJpdGhtZXRpYyBvcGVyYXRpb25zCiAgICAgICAgICAgICAgICB2YXIgb3V0cHV0cHVyZSA9IGV2YWwoZWwudmFsdWUpOwogICAgICAgICAgICAgICAgZWwudmFsdWUgPSBvdXRwdXRwdXJlOwogICAgICAgICAgICAgICAgaGFuZGxlT3V0cHV0KGVsLnZhbHVlLCBrYWxhYW0pOwogICAgICAgICAgICAgICAgYXNzaWduZWRfdmFyaWFibGVzLnB1c2goZWwubmFtZSk7CiAgICAgICAgICAgICAgfSAvL1dlIHdpbGwgc2ltcGxpZnkgdGhpcyBjb25kaXRpb25zIGFzIHdlIG1vdmUgZm9yd2FyZAogICAgICAgICAgICAgIGVsc2UgaWYgKCFpc1B1cmVFdmFsKGVsLnZhbHVlKSAmJiAhaXNOdW1iZXIoZWwudmFsdWUpKSB7CiAgICAgICAgICAgICAgICAgIGlmICghKGVsLm5hbWUuaW5jbHVkZXMoJ10nKSAmJiBlbC5uYW1lLmluY2x1ZGVzKCdbJykpKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKGVsLnR5cGUgPT09ICdBcnJheScpIHsKICAgICAgICAgICAgICAgICAgICAgIGlmICghZWwudmFsdWUuaW5jbHVkZXMoJ1snKSkgewogICAgICAgICAgICAgICAgICAgICAgICBlbC52YWx1ZSA9ICdbJyArIGVsLnZhbHVlLnRvU3RyaW5nKCkgKyAnXSc7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICBoYW5kbGVPdXRwdXQoZWwudmFsdWUsIGthbGFhbSk7CiAgICAgICAgICAgICAgICAgICAgYXNzaWduZWRfdmFyaWFibGVzLnB1c2goZWwubmFtZSk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0pOyAvL1RoaXMgaXMgaG93IHdlIHByaW50IEFycmF5IGluIEthbGFhbQoKICAgICAgaWYgKFRva2Vuc1tqICsgMV0udHlwZSA9PT0gJ0FycmF5JykgewogICAgICAgIC8vVG8gcnVuIG9ubHkgaWYgaXRlcmF0b3IgaXMgcHJlc2VudAogICAgICAgIC8vVGhpcyBydW5zIG9uIGZvciBsb29wIC0g4KSm4KS/4KSW4KS+4KSPKEFycmF5W2FdKSBldGMKICAgICAgICAvL3NlbGYgcnVucyBvbmx5IGlmIGZvcihpKSBhbmQgaW4gdGhlIGxvb3AsIGFycmF5W2ldLCBub3Qgb24gYXJyYXlbeF0uIEZvciBsb29wIEl0ZXJhdG9yIGFuZCBpbmRleCBzaG91bGQgYmUgc2FtZSwgaW4gc2VsZiBjYXNlICdpJwogICAgICAgIGlmIChpdGVyYXRvciAhPSB1bmRlZmluZWQgJiYgVG9rZW5zW2ogKyAxXS5JbmRleElucHV0ID09PSBPcmlnaW5hbEl0ZXJhdG9yKSB7CiAgICAgICAgICB2YXIgVmFsdWUgPSBOZXh0VG9rZW5WYWx1ZTsKICAgICAgICAgIHZhciBBcnJheUVsZW1lbnQgPSBDcmVhdGVBcnJheUVsZW1lbnQoVmFsdWUsIGl0ZXJhdG9yKTsKICAgICAgICAgIHZhciBvdXRwdXQgPSBHZXRBcnJheW9yU3RyaW5nRWxlbWVudChBcnJheUVsZW1lbnQsIG1lbW9yeSk7CiAgICAgICAgICBvdXRwdXQgPSBSZW1vdmVRdW90ZXMob3V0cHV0KTsKICAgICAgICAgIGhhbmRsZU91dHB1dChvdXRwdXQsIGthbGFhbSk7CiAgICAgICAgICBhc3NpZ25lZF92YXJpYWJsZXMucHVzaChUb2tlbnNbaiArIDFdKTsKICAgICAgICB9IC8vVGhpcyBydW5zIHRvIFByaW50KEFycmF5WzJdKSBsaWtlIHNwZWNpZmljIGFycmF5IHZhbHVlcwogICAgICAgIGVsc2UgaWYgKFRva2Vuc1tqICsgMV0uSW5kZXhJbnB1dCAhPSBPcmlnaW5hbEl0ZXJhdG9yKSB7CiAgICAgICAgICAgIHZhciBfVmFsdWUgPSBOZXh0VG9rZW5WYWx1ZTsKICAgICAgICAgICAgdmFyIEluZGV4VG9DaGFuZ2UgPSBUb2tlbnNbaiArIDFdLkluZGV4SW5wdXQ7CgogICAgICAgICAgICB2YXIgX0FycmF5RWxlbWVudCA9IENyZWF0ZUFycmF5RWxlbWVudChfVmFsdWUsIEluZGV4VG9DaGFuZ2UpOwoKICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBfQXJyYXlFbGVtZW50LnJlcGxhY2UoJ10nLCAnJyk7CgogICAgICAgICAgICB2YXIgU3BsaXQgPSBlbGVtZW50LnNwbGl0KCdbJyk7CgogICAgICAgICAgICBpZiAoU3BsaXRbMV0uaW5jbHVkZXMoJy0nKSB8fCBTcGxpdFsxXS5pbmNsdWRlcygnKycpKSB7CiAgICAgICAgICAgICAgdmFyIF9vdXRwdXQyID0gQ2FsY3VsYXRlVmFsdWVzKFNwbGl0WzFdLCBqLCBtZW1vcnkpOwoKICAgICAgICAgICAgICBTcGxpdFsxXSA9IF9vdXRwdXQyOwogICAgICAgICAgICAgIFNwbGl0ID0gU3BsaXQuam9pbignWycpICsgJ10nOwogICAgICAgICAgICAgIF9BcnJheUVsZW1lbnQgPSBTcGxpdDsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgdmFyIF90b2tlbiA9IG1lbW9yeS5maW5kKGZ1bmN0aW9uIChlbCkgewogICAgICAgICAgICAgIHJldHVybiBlbC5uYW1lID09PSBTcGxpdFsxXTsKICAgICAgICAgICAgfSk7CgogICAgICAgICAgICBpZiAoX3Rva2VuICE9IHVuZGVmaW5lZCAmJiBPcmlnaW5hbEl0ZXJhdG9yICE9IFNwbGl0WzFdKSB7CiAgICAgICAgICAgICAgU3BsaXRbMV0gPSBfdG9rZW4udmFsdWU7CiAgICAgICAgICAgICAgU3BsaXQgPSBTcGxpdC5qb2luKCdbJykgKyAnXSc7CiAgICAgICAgICAgICAgX0FycmF5RWxlbWVudCA9IFNwbGl0OwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIF9BcnJheUVsZW1lbnQgPSBfQXJyYXlFbGVtZW50OyAvLy8vCiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIHZhciBfb3V0cHV0ID0gR2V0QXJyYXlvclN0cmluZ0VsZW1lbnQoX0FycmF5RWxlbWVudCwgbWVtb3J5KTsKCiAgICAgICAgICAgIGhhbmRsZU91dHB1dChfb3V0cHV0LCBrYWxhYW0pOwogICAgICAgICAgfQogICAgICB9IC8vcHJpbnRpbmcgZGlyZWN0IG51bWJlcnMgYW5kIGRpcmVjdCBjYWxjdWx0aW9ucyBsaWtlIHByaW50KDEwKSwgcHJpbnQoMTAqMTApCiAgICAgIGVsc2UgaWYgKHRva2VuID09PSBBY3RpdmVMYW5ndWdhZUtleXdvcmRzLlByaW50ICYmIChpc1B1cmVFdmFsKFJlbW92ZUJyYWNrZXRzKE5leHRUb2tlblZhbHVlKSkgfHwgaXNOdW1iZXIoUmVtb3ZlQnJhY2tldHMoTmV4dFRva2VuVmFsdWUpKSkpIHsKICAgICAgICAgIE5leHRUb2tlblZhbHVlID0gUmVtb3ZlQnJhY2tldHMoTmV4dFRva2VuVmFsdWUpOwoKICAgICAgICAgIGlmIChpc051bWJlcihOZXh0VG9rZW5WYWx1ZSkgJiYgVG9rZW5zW2ogKyAxXS50eXBlICE9ICdDYWxjdWxhdGlvbicpIHsKICAgICAgICAgICAgaGFuZGxlT3V0cHV0KE5leHRUb2tlblZhbHVlLCBrYWxhYW0pOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdmFyIGEgPSBldmFsKE5leHRUb2tlblZhbHVlKTsKICAgICAgICAgICAgaGFuZGxlT3V0cHV0KGEsIGthbGFhbSk7CiAgICAgICAgICB9CiAgICAgICAgfSAvL2Zvcm9wZXJhdGlvbnMgbGlrZSBwcmludCgneW91IGxpdmUsIHlvdSBsZWFybicpCiAgICAgICAgZWxzZSBpZiAoVG9rZW5zW2ogKyAxXS5tb2RlID09PSAnUmVhbFRpbWVQcmludCcgJiYgIU5leHRUb2tlblZhbHVlLmluY2x1ZGVzKCcrJykKICAgICAgICAgIC8qJiYgIU5leHRUb2tlblZhbHVlLmluY2x1ZGVzKCc9JykqLwogICAgICAgICAgKSB7CiAgICAgICAgICAgICAgdmFyIF9vdXRwdXQzID0gUmVtb3ZlQnJhY2tldHMoTmV4dFRva2VuVmFsdWUpOwoKICAgICAgICAgICAgICBfb3V0cHV0MyA9IFJlbW92ZVF1b3Rlcyhfb3V0cHV0Myk7CiAgICAgICAgICAgICAgaGFuZGxlT3V0cHV0KF9vdXRwdXQzICsgJ1xuJywga2FsYWFtKTsKICAgICAgICAgICAgfSAvL29wZXJhdGlvbnMgbGlrZSBwcmludChBZ2UgKyAnaXMgeW91bmcgYWdlJykgaS5lIHN0cmluZyBjb25jYXRlbmF0aW9ucwogICAgICAgICAgZWxzZSBpZiAoVG9rZW5zW2ogKyAxXS5tb2RlID09PSAnUmVhbFRpbWVQcmludCcgJiYgTmV4dFRva2VuVmFsdWUuaW5jbHVkZXMoJysnKSkgewogICAgICAgICAgICAgIHZhciB4ID0gU3BsaXRFbGVtZW50c0FycmF5KE5leHRUb2tlblZhbHVlKTsKICAgICAgICAgICAgICB4ID0geC5qb2luKCcnKS5zcGxpdCgnKycpOwogICAgICAgICAgICAgIFN0cmluZ1ZhciA9IFNldFZhbHVlcyh4LCBtZW1vcnkpOwoKICAgICAgICAgICAgICB2YXIgX291dHB1dDQgPSBTdHJpbmdWYXIuam9pbignICcpOwoKICAgICAgICAgICAgICBfb3V0cHV0NCA9IFJlbW92ZUJyYWNrZXRzKF9vdXRwdXQ0KTsKICAgICAgICAgICAgICBfb3V0cHV0NCA9IFJlbW92ZVF1b3Rlcyhfb3V0cHV0NCk7CiAgICAgICAgICAgICAgaGFuZGxlT3V0cHV0KF9vdXRwdXQ0ICsgJ1xuJywga2FsYWFtKTsKICAgICAgICAgICAgfSBlbHNlIGlmIChpc0NhbGN1bGF0aW9uKFJlbW92ZUJyYWNrZXRzKE5leHRUb2tlblZhbHVlKSkgJiYgVG9rZW5zW2ogKyAxXS5tb2RlICE9ICdSZWFsVGltZVByaW50JykgewogICAgICAgICAgICAgIE5leHRUb2tlblZhbHVlID0gUmVtb3ZlQnJhY2tldHMoTmV4dFRva2VuVmFsdWUpOwoKICAgICAgICAgICAgICB2YXIgX291dHB1dDUgPSBDYWxjdWxhdGVWYWx1ZXMoTmV4dFRva2VuVmFsdWUsIGosIG1lbW9yeSk7CgogICAgICAgICAgICAgIGhhbmRsZU91dHB1dChfb3V0cHV0NSArICdcbicsIGthbGFhbSk7CiAgICAgICAgICAgIH0KCiAgICAgIHZhciBtZXNzYWdlID0gJyBDb21wdXRlciDgpKjgpYcg4KSG4KSq4KSV4KWAIOCkpuClgCDgpJfgpK/gpYAg4KS14KWI4KSy4KWN4KSv4KWCLCAnICsgJyInICsgUmVtb3ZlQnJhY2tldHMoTmV4dFRva2VuVmFsdWUpICsgJyInICsgJyDgpJXgpYsg4KSm4KS/4KSW4KS+4KSv4KS+IOCkueCliCB8JzsgLy9UaGlzIGlzIHRoZSBleHBlcmVzc2lvbiB3aGNpaCBpcyBnZXR0aW5nIGV2YWx1YXRlZC4KCiAgICAgIHZhciBleHByZXNzaW9uID0gdG9rZW4gKyBOZXh0VG9rZW5WYWx1ZTsKICAgICAgdmFyIGRlc2NyaXB0aW9uID0gJ+CkleCkv+CkuOClgCBWQUxVRSDgpJXgpYsgT1VUUFVUIFNDUkVFTiDgpKrgpYcg4KSm4KS/4KSW4KS+4KSo4KWHIOCkleClhyDgpLLgpL/gpI8g4KSm4KS/4KSW4KS+4KSPKCkg4KSV4KS+IOCkieCkquCkr+Cli+CklyDgpLngpYvgpKTgpL4g4KS54KWI4KWkJzsKICAgICAgZXhwcmVzc2lvbiA9IEdldGNsZWFuZWRFeHByZXNzaW9uKGV4cHJlc3Npb24pOwogICAgICB2YXIgcG9zaXRpb24gPSBmaW5kdG9rZW5Qb3NpdGlvbmluQ29kZShMaW5lYnlsaW5lU291cmNlZGF0YSwgZXhwcmVzc2lvbiwgdHJ1ZSk7CgogICAgICBpZiAocG9zaXRpb24gIT0gdW5kZWZpbmVkKSB7CiAgICAgICAgQWRkdG9FeGVjdXRpb25TdGFjayhFeGVjdXRpb25TdGFjaywgQWN0aXZlTGFuZ3VnYWVLZXl3b3Jkcy5QcmludCwgZGVzY3JpcHRpb24sIFZhcmlhYmxlVG9QcmludCwgbnVsbCwgbWVzc2FnZSwgcG9zaXRpb24pOwogICAgICB9CiAgICB9OyAvL0VORCBPRiBGdW5jdGlvbnMgYW5kIEltcG9ydGVkIEZ1bmN0aW9ucwogICAgLy9PdXQgb2YgYWxsIHNlbGYgZnVuY3Rpb24sIFByaW50RW5naW5lIGlzIHZlcnkgaW1wb3J0YW50IGZ1bmN0aW9uLiBJdCBwcmludHMgdmFyaWFibGUgdmFsdWVzIGJ5IHNlYXJjaGluZyB0aGVpciB2YWx1ZSBpbiBtZW1vcnkuCiAgICAvL1NFQ1RJT04gLSBDaGVja2luZyBlYWNoIHRva2VuIGFuZCBhZGRpbmcgdG8gdG9rZW5zIGFycmF5CiAgICAvL190b2tlbnMgdGFrZXMgdHdvIGFyZ3VtZW50cy4gVGhlIGNsZWFuZWRfc291cmNlZGF0YSBhcnJheSBhbmQgY3VycmVudCBpbmRleCBvZiBjbGVhbmVkX3NvdXJjZWRhdGEgYXJyYXkKICAgIC8vX3Rva2VucyBpcyB1c2VkIHRvIGNyZWF0ZSBhIHRva2VucyBhcnJheSB3aXRoIGVhY2ggdG9rZW4gaGF2aW5nIGl0J3MgbmFtZSwgdmFsdWUsIHR5cGUgYW5kIG90aGVyIG1ldGFkYXRhCiAgICAvL0l0IHBlcmZvcm1zIG9wZXJhdGlvbnMgZGVwZW5kaW5nIHVwb24gd2hldGhlciB0aGUgZWxlbWVudCBpcyB2YXJpYWJsZSwgYXJyYXksIGZ1bmN0aW9uLCBsb29wIGV0Yy4KICAgIC8vc2Nhbm5pbmcgZXZlcnkgc2luZ2xlIGVsZW1lbnQgZnJvbSBjbGVhbmVkX3NvdXJjZWRhdGEgYXJyYXkgYW5kIHB1c2hpbmcgaXQgdG8gVG9rZW5zIGRlcGVuZGluZyB1cG9uIHRoZSB0eXBlIHBmIGVsZW1lbnQKCgogICAgdmFyIF9hbmFseXplVG9rZW4gPSBmdW5jdGlvbiBfYW5hbHl6ZVRva2VuKGNsZWFuZWRfc291cmNlZGF0YSwgaSwgdG9rZW5zKSB7CiAgICAgIHZhciBlbGVtZW50ID0gY2xlYW5lZF9zb3VyY2VkYXRhW2ldOwogICAgICBza2lwUGFyc2luZyA9IDA7CiAgICAgIHZhciBuZXh0RWwgPSBjbGVhbmVkX3NvdXJjZWRhdGEubmV4dEVsZW1lbnQoaSk7CiAgICAgIHZhciBwcmV2RWwgPSBjbGVhbmVkX3NvdXJjZWRhdGEucHJldkVsZW1lbnQoaSk7CiAgICAgIHZhciB0b2tlbl90eXBlID0gc2Nhbm5lcihjbGVhbmVkX3NvdXJjZWRhdGEsIGksIHRva2Vucyk7CiAgICAgIGNvbnNvbGUubG9nKCd0b2tlbl90eXBlOicsIHRva2VuX3R5cGUpOyAvL1B1c2ggdmFyaWFibGVzIHRvIHRva2VucwogICAgICAvL0Zvcm1hdDoge3R5cGU6ICJ2YXJpYWJsZSIsIHZhbHVlOiAiUmV2ZXJzZVN0cmluZyJ9CiAgICAgIC8vd2hlbmV2ZXIgd2UgbmVlZCBhIGNlcnRhaW4gaGFuZGxpbmcsIGhhbmRsZXJzLmpzIGlzIHVzZWQKCiAgICAgIHN3aXRjaCAodG9rZW5fdHlwZSkgewogICAgICAgIGNhc2UgJ1ZBUklBQkxFJzoKICAgICAgICAgIC8vSGVyZSB3ZSBzZXBlcmF0ZSBNZXNzYWdlID0gJ0hlbGxvJyBpbnRvIGZvbGxvd2luZyB0aHJlZSB0b2tlbnMgOgogICAgICAgICAgLy8xOsKge3R5cGU6wqAidmFyaWFibGUiLMKgdmFsdWU6wqAiTWVzc2FnZSJ9CiAgICAgICAgICAvLzI6wqB7dHlwZTrCoCJvcGVyYXRvciIswqB2YWx1ZTrCoCI9In0KICAgICAgICAgIC8vMzrCoHt0eXBlOsKgInZhbHVlIizCoHZhbHVlOsKgIkhlbGxvIn0KICAgICAgICAgIHZhciBoYW5kbGVkX3ZhcmlhYmxlID0gaGFuZGxlVmFyaWFibGUoZWxlbWVudCwgdG9rZW5zLCBjbGVhbmVkX3NvdXJjZWRhdGEsIGksIG5leHRFbCwgcHJldkVsKTsKICAgICAgICAgIHZhciBoID0gaGFuZGxlZF92YXJpYWJsZTsKCiAgICAgICAgICBpZiAoaCAhPSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICBoLnR5cGUgPT09ICd2YXJpYWJsZScgPyBQdXNoVmFyaWFibGUoaCwgdG9rZW5zKSA6IGNvbnNvbGUubG9nKCJlcnJvciBpbiBzZXR0aW5nICIuY29uY2F0KGVsZW1lbnQpKTsKICAgICAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUsICJlcnJvciBpbiBzZXR0aW5nICIuY29uY2F0KGVsZW1lbnQpKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQoKICAgICAgICAgIGJyZWFrOwogICAgICAgIC8vUHVzaCB2YXJpYWJsZXMgdG8gdG9rZW5zCgogICAgICAgIGNhc2UgJ05VTUJFUic6CiAgICAgICAgICBQdXNoTnVtYmVyKGVsZW1lbnQsIHRva2Vucyk7CiAgICAgICAgICBicmVhazsKICAgICAgICAvL1B1c2ggRW1wdHlTdHJpbmdzIHRvIHRva2VucwoKICAgICAgICBjYXNlICdFTVBUWV9TVFJJTkcnOgogICAgICAgICAgLy9JbiBzb21lIGNhc2VzIGVtcHR5IHN0cmluZ3Mgd2lsbCBiZSBtb2RpZmllZCBpbnRvIHNvbWV0aGluZyBsaWtlICInIiBvciAnIicKICAgICAgICAgIC8vV2UgY29udmVydCBpdCBiYWNrIHRvICIgIgogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgdmFyIGUgPSBlbGVtZW50OwogICAgICAgICAgICBlID0gZS5sZW5ndGggPiAxICYmIChlLmNoYXJBdCgwKSA9PT0gIiciIHx8IGUuY2hhckF0KDApID09PSAnIicpID8gZSA9IGUucmVwbGFjZSgvWyciXSsvZywgJycpIDogZSA9ICcgJzsKICAgICAgICAgICAgUHVzaFZhcmlhYmxlVmFsdWUoZSwgdG9rZW5zKTsKICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgY29uc29sZS5sb2coZSwgIkVycm9yIGluIHNldHRpbmcgRW1wdHkgc3RyaW5nICIuY29uY2F0KGVsZW1lbnQpKTsKICAgICAgICAgIH0KCiAgICAgICAgICBicmVhazsKICAgICAgICAvL1B1c2ggSW5wdXQgdG8gdG9rZW5zCiAgICAgICAgLy9Gb3JtYXQ6IHt0eXBlOsKgIkFjY2VwdElucHV0IizCoHZhbHVlOsKgIiAiLMKgQWNjZXB0QXM6wqAiTWVzc2FnZSJ9CgogICAgICAgIGNhc2UgJ0lOUFVUJzoKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIFB1c2hJbnB1dChlbGVtZW50LCB0b2tlbnMsIGNsZWFuZWRfc291cmNlZGF0YSwgaSk7CiAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUsICJFcnJvciBpbiBzZXR0aW5nIElucHV0ICIuY29uY2F0KGVsZW1lbnQpKTsKICAgICAgICAgIH0KCiAgICAgICAgICBicmVhazsKICAgICAgICAvL1B1c2ggb3BlcmF0b3JzIHRvIHRva2Vucy4gVGhlIGFjY2VwdGVkIG9wZXJhdG9ycyBhcmUgPSx9LHsKICAgICAgICAvL0Zvcm1hdDrCoHt0eXBlOsKgIm9wZXJhdG9yIizCoHZhbHVlOsKgIj0ifQoKICAgICAgICBjYXNlICdPUEVSQVRPUic6CiAgICAgICAgICB0cnkgewogICAgICAgICAgICBQdXNoT3BlcmF0b3IoZWxlbWVudCwgdG9rZW5zKTsKICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgY29uc29sZS5sb2coZSwgIkVycm9yIGluIHNldHRpbmcgb3BlcmF0b3IgIi5jb25jYXQoZWxlbWVudCkpOwogICAgICAgICAgfQoKICAgICAgICAgIGJyZWFrOwogICAgICAgIC8vUHVzaCBrZXlvd3JkcyB0byB0b2tlbnMuIFRoZSBhY2NlcHRlZCBrZXl3b3JkcyBpcyDgpKbgpL/gpJbgpL7gpI8KICAgICAgICAvL0Zvcm1hdDoge3R5cGU6wqAia2V5d29yZCIswqB2YWx1ZTrCoEFjdGl2ZUxhbmd1Z2FlS2V5d29yZHMuUHJpbnR9CgogICAgICAgIGNhc2UgJ1BSSU5UJzoKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIFB1c2hLZXl3b3JkKGVsZW1lbnQsIHRva2Vucyk7CiAgICAgICAgICAgIHZhciBFeHByZXNzaW9udG9QcmludCA9IG5leHRFbDsKICAgICAgICAgICAgY29uc29sZS5sb2coJ0V4cHJlc3Npb250b1ByaW50OicsIEV4cHJlc3Npb250b1ByaW50KTsKCiAgICAgICAgICAgIGlmICghaXNSZWFsVGltZVByaW50TXVsdGlwbGVTdHJpbmcoRXhwcmVzc2lvbnRvUHJpbnQpKSB7CiAgICAgICAgICAgICAgUHVzaEV4cHJlc3Npb24oRXhwcmVzc2lvbnRvUHJpbnQsIHRva2Vucyk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgY29uc29sZS5sb2coZSwgIkVycm9yIGluIHByaW50aW5nICIuY29uY2F0KGVsZW1lbnQpKTsKICAgICAgICAgIH0KCiAgICAgICAgICBicmVhazsKICAgICAgICAvL1B1c2ggZnVuY3Rpb25zIHRvIHRva2VucwogICAgICAgIC8vRm9ybWF0OiB7dHlwZTogImZ1bmN0aW9uIiwgdmFsdWU6ICJGaXJzdCIsIGFyZ3VtZW50czogQXJyYXkoMiksIEZ1bmN0aW9uSW52b2NhdGlvbkV4aXN0czogZmFsc2UsIEZ1bmN0aW9uU3RhY2s6IEFycmF5KDApLCDigKZ9CgogICAgICAgIGNhc2UgJ0ZVTkNUSU9OJzoKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIFB1c2hGdW5jdGlvbkRhdGEoZWxlbWVudCwgdG9rZW5zLCBjbGVhbmVkX3NvdXJjZWRhdGEsIGkpOwogICAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICBjb25zb2xlLmxvZyhlLCAiRXJyb3IgaW4gaGFuZGxpbmcgZnVuY3Rpb24gIi5jb25jYXQoZWxlbWVudCkpOwogICAgICAgICAgfQoKICAgICAgICAgIGJyZWFrOwogICAgICAgIC8vIFB1c2ggYXJyYXkgdG8gdG9rZW5zCgogICAgICAgIGNhc2UgJ0FSUkFZJzoKICAgICAgICAgIC8vRm9ybWF0OiB7dHlwZTogIkFycmF5IiwgdmFsdWU6ICJbXSJ9CiAgICAgICAgICAvL2lmIGVtcHR5IGFycmF5IGVsc2UgYnVpbGQgdGhlIGFycmF5IChUbyBjb252ZXJ0ICdbJywxLDIsMyw0LCddJyAgaW50byBbMSwyLDMsNF0KICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIHZhciBfZSA9IGVsZW1lbnQ7CiAgICAgICAgICAgIF9lLmNoYXJBdChfZS5sZW5ndGggLSAxKSA9PT0gJ10nID8gUHVzaEFycmF5KF9lLCB0b2tlbnMpIDogZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgIHZhciBCdWlsdEFycmF5ID0gQnVpbGRBcnJheShfZSwgaSwgY2xlYW5lZF9zb3VyY2VkYXRhKTsKICAgICAgICAgICAgICBQdXNoQXJyYXkoQnVpbHRBcnJheSwgdG9rZW5zKTsKICAgICAgICAgICAgfTsKICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgY29uc29sZS5sb2coZSwgIkVycm9yIGluIGhhbmRsaW5nIEFycmF5ICIuY29uY2F0KGVsZW1lbnQpKTsKICAgICAgICAgIH0KCiAgICAgICAgICBicmVhazsKICAgICAgICAvL0ZvciBvcGVyYXRpb25zIGxpa2UgTnVtYmVyc1thXT1hCiAgICAgICAgLy9Gb3JtYXQ6IHt0eXBlOsKgIlNldEFycmF5SW5kZXhWYWx1ZSIswqB2YWx1ZTrCoCJGaWJvbmFjY2lbYV0iLMKgVmFsdWVUb1NldDrCoCJhIn0KCiAgICAgICAgY2FzZSAnU0VUX0FSUkFZX0lOREVYJzoKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIFB1c2hTZXRBcnJheUluZGV4VmFsdWUoZWxlbWVudCwgdG9rZW5zLCBjbGVhbmVkX3NvdXJjZWRhdGEsIGkpOwogICAgICAgICAgICBjbGVhbmVkX3NvdXJjZWRhdGEuc3BsaWNlKGkgKyAxLCAxKTsKICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgY29uc29sZS5sb2coZSwgIkVycm9yIGluIHNldHRpbmcgYXJyYXkgaW5kZXggdmFsdWUgIi5jb25jYXQoZWxlbWVudCkpOwogICAgICAgICAgfQoKICAgICAgICAgIGJyZWFrOwogICAgICAgIC8vRm9yIG9wZXJhdGlvbnMgbGlrZSBhPU51bWJlcnNbYV0sIHJldmVyc2Ugb2YgYWJvdmUKICAgICAgICAvL0Zvcm1hdDoge3R5cGU6wqAiR2V0QXJyYXlJbmRleFZhbHVlIizCoHZhbHVlOsKgIkZpYm9uYWNjaVthLTJdIn0KCiAgICAgICAgY2FzZSAnR0VUX0FSUkFZX0lOREVYJzoKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIFB1c2hHZXRBcnJheUluZGV4VmFsdWUoZWxlbWVudCwgdG9rZW5zLCBjbGVhbmVkX3NvdXJjZWRhdGEsIGkpOwogICAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICBjb25zb2xlLmxvZyhlLCAiRXJyb3IgaW4gZ2V0dGluZyBhcnJheSBpbmRleCB2YWx1ZSAiLmNvbmNhdChlbGVtZW50KSk7CiAgICAgICAgICB9CgogICAgICAgICAgYnJlYWs7CiAgICAgICAgLy9QdXNoIGNvbmRpdGlvbnMgdG8gdG9rZW5zLiBUaGUgYWNjZXB0ZWQga2V5d29yZHMgYXJlIOCkheCkl+CksCwg4KSc4KSs4KSk4KSVLCDgpIXgpKjgpY3gpK/gpKXgpL4KICAgICAgICAvLyBGb3JtYXQ6IHt0eXBlOsKgImNvbmRpdGlvbmFsa2V5d29yZCIswqB2YWx1ZTrCoCLgpIXgpJfgpLAifQogICAgICAgIC8vUHVzaCB3aGlsZSBsb29wcyB0byB0b2tlbnMKICAgICAgICAvL0Zvcm1hdDoge3R5cGU6ICJXaGlsZUxvb3BTdGFydCIsIHZhbHVlOiAi4KSc4KSs4KSk4KSVIn0sIHt0eXBlOiAiY29uZGl0aW9uIiwgdmFsdWU6ICJjb3VudDwyNSJ9CgogICAgICAgIGNhc2UgJ0NPTkRJVElPTkFMX0tFWVdPUkQnOgogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgaXNXaGlsZUxvb3AoZWxlbWVudCkgPyBQdXNoV2hpbGVMb29wKGVsZW1lbnQsIHRva2VucykgOiBQdXNoQ29uZGl0aW9uYWxLZXl3b3JkKGVsZW1lbnQsIHRva2Vucyk7IC8vVGhpcyBpcyBob3cgd2UgcHVzaCBjb25kaXRpb25zIGVuY291bnRlcmVkIGluIHRoZSBzb3VyY2Vjb2RlCiAgICAgICAgICAgIC8vRm9ybWF0Ont0eXBlOsKgImNvbmRpdGlvbiIswqB2YWx1ZTrCoCJhPDMifQoKICAgICAgICAgICAgdmFyIGZvdW5kY29uZGl0aW9uID0gQnVpbGRDb25kaXRpb24oZWxlbWVudCwgaSwgY2xlYW5lZF9zb3VyY2VkYXRhKTsgLy9QdXNoIGNvbmRpdGlvbnMgdG8gdG9rZW5zIGFycmF5CgogICAgICAgICAgICBpZiAoZm91bmRjb25kaXRpb24gIT0gJycpIHsKICAgICAgICAgICAgICBQdXNoQ29uZGl0aW9uKGZvdW5kY29uZGl0aW9uLCB0b2tlbnMpOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUsICJFcnJvciBpbiBvcGVyYXRpbmcgb24gY29uZGl0aW9uYWxzICIuY29uY2F0KGVsZW1lbnQpKTsKICAgICAgICAgIH0KCiAgICAgICAgICBicmVhazsKICAgICAgICAvL0ZpbmRpbmcgb3BlcmF0aW9ucyBsaWtlIE51bWJlcnMu4KSq4KWB4KS2KHgpCiAgICAgICAgLy9Gb3JtYXQ6IHt0eXBlOiAiUHVzaFRvQXJyYXkiLCB2YWx1ZTogIk51bWJlcnMu4KSq4KWB4KS2KHgpIn0KCiAgICAgICAgY2FzZSAnUFVTSF9UT19BUlJBWSc6CiAgICAgICAgICB0cnkgewogICAgICAgICAgICBQdXNoVG9BcnJheShlbGVtZW50LCB0b2tlbnMpOwogICAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICBjb25zb2xlLmxvZyhlLCAiRXJyb3IgaW4gcHVzaGluZyB0aGUgdmFsdWVzIHRvIGFycmF5ICIuY29uY2F0KGVsZW1lbnQpKTsKICAgICAgICAgIH0KCiAgICAgICAgICBicmVhazsKICAgICAgICAvL1B1c2ggRm9yIGxvb3AgdG8gdG9rZW5zCiAgICAgICAgLy8gRm9ybWF0OgogICAgICAgIC8vIHt0eXBlOsKgIkZvckxvb3BTdGFydCIswqB2YWx1ZTrCoCLgpKbgpYHgpLngpLDgpL7gpJMifQogICAgICAgIC8vwqB7dHlwZTrCoCJGb3JMb29wQXJndW1lbnRzIizCoGl0ZXJhdG9yOsKgImEiLMKgdmFsdWU6wqAiKDAsMjUpIizCoGl0ZXJhdGlvblN0YXJ0OsKgIjAiLMKgaXRlcmF0aW9uRW5kOsKgIjI1In0KCiAgICAgICAgY2FzZSAnRk9SX0xPT1AnOgogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgUHVzaEZvckxvb3AoZWxlbWVudCwgdG9rZW5zKTsKICAgICAgICAgICAgUHVzaEZvckxvb3BBcnVndW1lbnRzKGVsZW1lbnQsIGNsZWFuZWRfc291cmNlZGF0YSwgaSwgdG9rZW5zKTsKICAgICAgICAgICAgbWVtb3J5LnB1c2goewogICAgICAgICAgICAgIG5hbWU6IG5leHRFbCwKICAgICAgICAgICAgICB2YWx1ZTogMCwKICAgICAgICAgICAgICB0eXBlOiAnRm9yTG9vcEl0ZXJhdG9yJwogICAgICAgICAgICB9KTsKICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgY29uc29sZS5sb2coZSwgIkVycm9yIGluIG9wZXJhdGluZyBvbiBmb3IgbG9vcCAiLmNvbmNhdChlbGVtZW50KSk7CiAgICAgICAgICB9CgogICAgICAgICAgYnJlYWs7CiAgICAgICAgLy9QdXNoaW5nIGJhc2ljIENhbGN1bGF0aW9ucyBsaWtlICdsZW5ndGgtMScgdG8gdG9rZW5zCiAgICAgICAgLy9Gb3JtYXQ6IHt0eXBlOsKgIkNhbGN1bGF0aW9uIizCoHZhbHVlOsKgImxlbmd0aC0xIn0KCiAgICAgICAgY2FzZSAnQ0FMQ1VMQVRJT04nOgogICAgICAgICAgLyogcmVkIHpvbmUKICAgICAgICAgICAgIGlmIChuZXh0RWwgIT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgIC8vIHRoaXMgaXMgdG8gcGVyZm9ybSBsb25nIGNhbGN1bGF0aW9ucyBsaWtlIEF2ZXJhZ2VBZ2U9KGFnZW9uZSthZ2V0d28pLzIgKyAoYWdlb25lK2FnZXR3bykqMgogICAgICAgICAgICAgICB3aGlsZSAoaXNDYWxjdWxhdGlvbihjbGVhbmVkX3NvdXJjZWRhdGFbaV0pKSB7CiAgICAgICAgICAgICAgZWwgPSBlbCArIGNsZWFuZWRfc291cmNlZGF0YVtpXTsKICAgICAgICAgICAgICAgICBpKys7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgICAgIGNvbnNvbGUubG9nKCJlbDoiLCBlbCk7CiAgICAgICAgICAqLwoKICAgICAgICAgIC8qZXJyb3IgcHJvbmUqLwogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgdmFyIGlzTXVsdGlDYWxjdWxhdGlvbiA9IGZ1bmN0aW9uIGlzTXVsdGlDYWxjdWxhdGlvbihjKSB7CiAgICAgICAgICAgICAgdmFyIG9wID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnKisvLSc7CgogICAgICAgICAgICAgIGlmIChjLmluY2x1ZGVzKCcoJykgJiYgYy5pbmNsdWRlcygnKScpKSB7CiAgICAgICAgICAgICAgICB2YXIgcyA9IGMuc3BsaXQoJycpOwogICAgICAgICAgICAgICAgcy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkgewogICAgICAgICAgICAgICAgICBpZiAob3AuaW5jbHVkZXMoZWwpKSB7CiAgICAgICAgICAgICAgICAgICAgZCA9IGQgKyAxOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9KTsKCiAgICAgICAgICAgICAgICBpZiAoZCA+IDEpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9OwoKICAgICAgICAgICAgdmFyIGVsID0gZWxlbWVudDsKICAgICAgICAgICAgdmFyIGNhbCA9ICcnOwogICAgICAgICAgICB2YXIgY291bnQgPSAwOyAvLyAgIGZ1bmN0aW9uIGZpbmRDYWxjdWxhdGlvbihjbGVhbmVkX3NvdXJjZWRhdGEsIGkpIHsKCiAgICAgICAgICAgIHZhciB4ID0gaTsKICAgICAgICAgICAgdmFyIGQgPSAwOwoKICAgICAgICAgICAgd2hpbGUgKGlzQ2FsY3VsYXRpb24oY2xlYW5lZF9zb3VyY2VkYXRhW3hdKSB8fCBjbGVhbmVkX3NvdXJjZWRhdGFbeF0gPT0gJysnKSB7CiAgICAgICAgICAgICAgY2FsID0gY2FsICsgY2xlYW5lZF9zb3VyY2VkYXRhW3hdOwogICAgICAgICAgICAgIGNvdW50ICs9IDE7CiAgICAgICAgICAgICAgeCsrOwogICAgICAgICAgICB9CgogICAgICAgICAgICB2YXIgbXVsdGlDYWwgPSBpc011bHRpQ2FsY3VsYXRpb24oY2FsKTsgLy8gIGNvbnNvbGUubG9nKCJ4IiwgeCwgaSk7CgogICAgICAgICAgICBza2lwUGFyc2luZyA9IGNvdW50IC0gMTsgLy8gY2FsID0gUmVtb3ZlQnJhY2tldHMoY2FsKTsKICAgICAgICAgICAgLy9sZXQgY19lbCA9IFJlbW92ZUJyYWNrZXRzKGNhbCk7CiAgICAgICAgICAgIC8vICBsZXQgY2FsID0gZmluZENhbGN1bGF0aW9uKCk7CiAgICAgICAgICAgIC8vIHRvIHN0b3AgcHJldmVudGlvbiBvZiBleHByZXNzaW9ucyBsaWtlIGlzIisgZ2V0dGluZyBhZGRlZCBhcyBhIGNhbGN1bGF0aW9uCgogICAgICAgICAgICAhY2FsLmluY2x1ZGVzKCciJykgJiYgIVsnLycsICcqJywgIiciLCAnIiddLmluY2x1ZGVzKGVsLmNoYXJBdCgwKSkgPyBQdXNoQ2FsY3VsYXRpb24oY2FsLCB0b2tlbnMsIGNsZWFuZWRfc291cmNlZGF0YSwgaSwgbXVsdGlDYWwpIDogY29uc29sZS5sb2coImltcHVyZSBjYWxjdWxhdGlvbiB0ZXJtcyAiLmNvbmNhdChlbCkpOwogICAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICBjb25zb2xlLmxvZyhlLCAiRXJyb3IgaW4gY29tcGxldGluZyBjYWxjdWxhdGlvbiAiLmNvbmNhdChlbGVtZW50KSk7CiAgICAgICAgICB9CgogICAgICAgICAgYnJlYWs7CgogICAgICAgIGNhc2UgJ1JFQUxUSU1FX1BSSU5UJzoKICAgICAgICAgIC8vZmluZGluZyBvcGVyYXRpb25zIGxpa2UgcHJpbnQoeCArICd5JykuIFRoZSBSZWFsVGltZVByaW50IG9wZXJhdGlvbnMKICAgICAgICAgIC8vRm9ybWF0OiB7dHlwZTrCoCJ2YWx1ZSIswqB2YWx1ZTrCoCIoJ1JldmVyc2VkIFN0cmluZy0nKyBSZXZlcnNlU3RyaW5nKSIswqBtb2RlOsKgIlJlYWxUaW1lUHJpbnQifQogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgdmFyIF9oYW5kbGVSZWFsdGltZVByaW50ID0gaGFuZGxlUmVhbHRpbWVQcmludChjbGVhbmVkX3NvdXJjZWRhdGEsIGkpLAogICAgICAgICAgICAgICAgZm91bmRTdHJpbmcgPSBfaGFuZGxlUmVhbHRpbWVQcmludC5mb3VuZFN0cmluZywKICAgICAgICAgICAgICAgIHNraXAgPSBfaGFuZGxlUmVhbHRpbWVQcmludC5za2lwOwoKICAgICAgICAgICAgUHVzaFJlYWxUaW1lUHJpbnRPcGVyYXRpb24oZm91bmRTdHJpbmcsIHRva2Vucyk7CiAgICAgICAgICAgIHNraXBQYXJzaW5nID0gc2tpcDsKICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgY29uc29sZS5sb2coZSwgIkVycm9yIGluIHJlYWwgdGltZSBwcmludCAiLmNvbmNhdChlbGVtZW50KSk7CiAgICAgICAgICB9CgogICAgICAgICAgYnJlYWs7CgogICAgICAgIGNhc2UgJ1NUUklORyc6CiAgICAgICAgICAvL3N0b3Jpbmcgb25seSB0aGUgc3RyaW5nIHZhbHVlcyB0byB0b2tlbnMgKCBub3QgdGhlIHN0cmluZ3MgaW4gcHJpbnQgc3RhdGVtZW50cykKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIHZhciBzID0gQnVpbGRTdHJpbmcoZWxlbWVudCwgaSwgY2xlYW5lZF9zb3VyY2VkYXRhKTsKICAgICAgICAgICAgcyA9IHMucmVwbGFjZSgvWyciXSsvZywgJycpOwogICAgICAgICAgICAhcy5pbmNsdWRlcyhBY3RpdmVMYW5ndWdhZUtleXdvcmRzLlByaW50KSA/IFB1c2hTdHJpbmcocywgdG9rZW5zKSA6IGNvbnNvbGUubG9nKCJlcnJvciBpbiBwdXNoaW5nIHN0cmluZyAiLmNvbmNhdCgocywgZWxlbWVudCkpKTsKICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgY29uc29sZS5sb2coZSwgImVycm9yIGluIG9wZXJhdGluZyBvbiBzdHJpbmcgIi5jb25jYXQoZWxlbWVudCkpOwogICAgICAgICAgfQoKICAgICAgICAgIGJyZWFrOwogICAgICAgIC8vQW4gZXh0ZW5zaW9uIG9mIGlzUHJpbnRPcGVyYXRpb24oKSBmdW5jdGlvbgogICAgICAgIC8vIE5lZWRzIGltcHJvdmVtZW50CgogICAgICAgIC8qICAgICBlbHNlIGlmICgvXig/PS4qP+CkpuCkv+CkluCkvuCkjykoPz0uKlthLXpdKS8udGVzdChlbGVtZW50KSkgewogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgIFB1c2hLZXl3b3JkKGVsZW1lbnQuc2xpY2UoMCwgNiksIHRva2Vucyk7IC8vUHVzaGluZyBwcmludCBrZXl3b3JkIG9ubHkKICAgICAgICAgICAgICAgICAgICAgUHVzaEV4cHJlc3Npb24oZWxlbWVudC5zbGljZSg2KSwgdG9rZW5zKTsgLy9QdXNoaW5nIHJlbWFpbmluZyBleHByZXNzaW9uIGxpa2UgKGEpLCAoTWVzc2FnZSkgZXRjCiAgICAgICAgICAgIH0KICAgICAgICAgICAgKi8KICAgICAgICAvL2Vycm9yIHByb25lIGNoYW5nZSBtYWRlIGhlcmUtIFB1c2hpbmcgZXhwcmVzc2lvbiBpbiBoZXJlCiAgICAgICAgLy9Vc2VkIHRvIHB1c2ggZnVuY3Rpb25zIGFuZCBleHByZXNzaW9ucwogICAgICAgIC8vVW5uZWNlc3NhcnkgZGF0YSBpcyBiZWluZyBwYXNzZWQgdGhyb3VnaCBrYWxhYW0uCiAgICAgICAgLy9UaGlzIHdhcyBjcmVhdGVkIGZvciBhIHRlbXBvcmFyeSBmaXgKCiAgICAgICAgY2FzZSAnRlVOQ1RJT05fQ0FMTCc6CiAgICAgICAgICB0cnkgewogICAgICAgICAgICB2YXIgQ2hlY2tGdW5jdGlvbkV4cHJlc3Npb24gPSBlbGVtZW50LnNwbGl0KCcoJyk7CiAgICAgICAgICAgIHZhciBwYXNzZWRWYWx1ZXMgPSBSZW1vdmVCcmFja2V0cyhDaGVja0Z1bmN0aW9uRXhwcmVzc2lvblsxXSk7CiAgICAgICAgICAgIHBhc3NlZFZhbHVlcyA9IHBhc3NlZFZhbHVlcy5zcGxpdCgnLCcpOwogICAgICAgICAgICBQdXNoRnVuY3Rpb25FeGVjdXRpb24oZWxlbWVudCwgdG9rZW5zLCBjbGVhbmVkX3NvdXJjZWRhdGEsIGksIHBhc3NlZFZhbHVlcyk7CiAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUsICJlcnJvciBpbiBwdXNoaW5nIGZ1bmN0aW9uIGV4ZWN1dGlvbiAiLmNvbmNhdChlbGVtZW50KSk7CiAgICAgICAgICB9CgogICAgICAgICAgYnJlYWs7CgogICAgICAgIGNhc2UgJ05BVElWRV9PUEVSQVRJT04nOgogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgUHVzaE5hdGl2ZU9wZXJhdGlvbihlbGVtZW50LCB0b2tlbnMpOwogICAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICBjb25zb2xlLmxvZyhlLCAiZXJyb3IgaW4gcHVzaGluZyBuYXRpdmUgb3BlcmFpb24gIi5jb25jYXQoZWxlbWVudCkpOwogICAgICAgICAgfQoKICAgICAgICAgIGJyZWFrOwoKICAgICAgICBjYXNlICdBUlJBWV9QVVNIJzoKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIFB1c2hBcnJheShlbGVtZW50LCB0b2tlbnMpOwogICAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICBjb25zb2xlLmxvZyhlLCAiZXJyb3IgaW4gYXJyYXkgcHVzaCAiLmNvbmNhdChlbGVtZW50KSk7CiAgICAgICAgICB9CgogICAgICAgICAgYnJlYWs7CiAgICAgIH0KICAgIH07IC8vbWFraW5nIHNlbnNlIG9mIHRva2VucyBhcnJheSBjb21pbmcgZnJvbSBfcGFyc2VyLgoKCiAgICB2YXIgaW50ZXJwcmV0VG9rZW4gPSBmdW5jdGlvbiBpbnRlcnByZXRUb2tlbih0LCBqLCBtZW1vcnkpIHsKICAgICAgc2tpcEludGVycHJldGF0aW9uID0gMDsKICAgICAgdmFyIG11dGFibGVfdG9rZW5zID0gdDsKICAgICAgdmFyIHRva2VuID0gbXV0YWJsZV90b2tlbnNbal0udmFsdWU7CiAgICAgIHZhciB0b2tlbl90eXBlID0gbXV0YWJsZV90b2tlbnNbal0udHlwZTsKICAgICAgdmFyIHRva2VuX3N1YnR5cGUgPSBtdXRhYmxlX3Rva2Vuc1tqXS5zdWJ0eXBlOwogICAgICB2YXIgdHlwZSA9IHRva2VuID09PSBBY3RpdmVMYW5ndWdhZUtleXdvcmRzLlByaW50IHx8IHRva2VuX3R5cGUgPT09ICdvcGVyYXRvcicgPyB0b2tlbl9zdWJ0eXBlIDogdG9rZW5fdHlwZTsgLy9uZWVkIHRvIHNraXAgb3ZlciBzb21lIHVubmNlc3NhcnkgdHlwZXMKICAgICAgLy9vcGVyYXRvcnMgYXJlIG5vdCB3b3JraW5nIGNvcnJlY3RseQogICAgICAvLyBubyBuZWVkIHRvIGludGVycHJldCBvdmVyIG5vbi10eXBlcwoKICAgICAgdHJ5IHsKICAgICAgICBpZiAoaXNJbnRlcnByZXRhYmxlVHlwZSh0eXBlKSkgewogICAgICAgICAgc3dpdGNoICh0eXBlKSB7CiAgICAgICAgICAgIGNhc2UgJ1NldEFycmF5SW5kZXhWYWx1ZSc6CiAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgU2V0QXJyYXlJbmRleFZhbHVlKG11dGFibGVfdG9rZW5zLCBqLCBqLCBtZW1vcnksIHRva2VucywgT3JpZ2luYWxJdGVyYXRvciwgaXRlcmF0b3IsIEV4ZWN1dGlvblN0YWNrLCBMaW5lYnlsaW5lU291cmNlZGF0YSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgY2FzZSAnYXNzaWdubWVudCc6CiAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgQXNzaWdub3JVcGRhdGVWYWx1ZXMobXV0YWJsZV90b2tlbnMsIGosIG1lbW9yeSwgaXRlcmF0b3IsIE9yaWdpbmFsSXRlcmF0b3IsIGthbGFhbSwgRXhlY3V0aW9uU3RhY2ssIExpbmVieWxpbmVTb3VyY2VkYXRhKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZQoKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgLy90eXBlPWFzc2lnbm1lbnQKCiAgICAgICAgICAgIGNhc2UgJ1B1c2hUb0FycmF5JzoKICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBBZGRFbGVtZW50VG9BcnJheShtdXRhYmxlX3Rva2VucywgaiwgbWVtb3J5LCBFeGVjdXRpb25TdGFjaywgTGluZWJ5bGluZVNvdXJjZWRhdGEpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgIGNhc2UgJ0FjY2VwdElucHV0JzoKICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBBY2NlcHRJbnB1dGFuZFNldFZhbHVlKG11dGFibGVfdG9rZW5zLCBqLCBtZW1vcnksIEV4ZWN1dGlvblN0YWNrLCBMaW5lYnlsaW5lU291cmNlZGF0YSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAvL1doZW5ldmVyIHdlIGVuY291bnRlciBhIGZ1bmN0aW9uLCB3ZSBjcmVhdGUgYSBzZXBlcmF0ZSBleGVjdXRpb24gY29udGV4dAoKICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOgogICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIC8vV2UgYXJlIHByZXBhcmluZyB0aGUgcmVxdWlyZWQgZGF0YSB0byBleGVjdXRlIGEgZnVuY3Rpb24gY2FsbCBsYXRlciBpbiB0aGUgcHJncm9hbQogICAgICAgICAgICAgICAgLy9mdW5jdGlvbnNvdXJjZWRhdGEgaW5jbHVkZXMgYWxsIHRoZSB0b2tlbnMgZnJvbSB0b2tlbnMgYXJyYXkgd2hpY2ggYmVsb25ncyB0byBhIHBhcnRpY3VsYXIgZnVuY3Rpb24KICAgICAgICAgICAgICAgIHNraXBJbnRlcnByZXRhdGlvbiA9IDA7IC8vV2UgZmluZCBzZWxmIHJhbmdlIG9yIGEgZnVuY3Rpb24gYmxvY2sgdGhyb3VnaCBIYW5kbGVCbG9ja3MgZnVuY3Rpb24KCiAgICAgICAgICAgICAgICB2YXIgX3ByZXBhcmVGdW5jdGlvbiA9IHByZXBhcmVGdW5jdGlvbihtdXRhYmxlX3Rva2VucywgaiksCiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25Tb3VyY2VEYXRhID0gX3ByZXBhcmVGdW5jdGlvbi5mdW5jdGlvblNvdXJjZURhdGE7CgogICAgICAgICAgICAgICAgbXV0YWJsZV90b2tlbnNbal0uU291cmNlRGF0YSA9IGZ1bmN0aW9uU291cmNlRGF0YTsKCiAgICAgICAgICAgICAgICB2YXIgX21lc3NhZ2UgPSAiXHUwOTA3XHUwOTM4ICIuY29uY2F0KEFjdGl2ZUxhbmd1Z2FlS2V5d29yZHMuRnVuY3Rpb24sICIgXHUwOTE1XHUwOTNFIFx1MDkyOFx1MDkzRVx1MDkyRSAiKS5jb25jYXQodG9rZW4sICIgXHUwOTM5XHUwOTQ4IFx1MDkxQ1x1MDkzRlx1MDkzOFx1MDk0NyBcdTA5MzlcdTA5MkUgXHUwOTE1XHUwOTRCXHUwOTIxIFx1MDkyRVx1MDk0N1x1MDkwMiBcdTA5MkNcdTA5M0VcdTA5MjYgXHUwOTJFXHUwOTQ3XHUwOTAyIE5FVyBWQUxVRVMgXHUwOTJBXHUwOTNFXHUwOTM4IFx1MDkxNVx1MDkzMFx1MDkxNVx1MDk0NyBcdTA5MDlcdTA5MkFcdTA5MkZcdTA5NEJcdTA5MTcgXHUwOTE1XHUwOTMwIFx1MDkzOFx1MDkxNVx1MDkyNFx1MDk0NyBcdTA5MzlcdTA5NDh8Iik7CgogICAgICAgICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSAiIi5jb25jYXQoQWN0aXZlTGFuZ3VnYWVLZXl3b3Jkcy5GdW5jdGlvbiwgIiAiKS5jb25jYXQodG9rZW4pOwogICAgICAgICAgICAgICAgdmFyIGRlc2NyaXB0aW9uID0gJyDgpI/gpJUg4KS14KS/4KS24KS/4KS34KWN4KSfIOCksOClguCkqiDgpLjgpYcg4KSy4KS/4KSW4KS+IOCkl+Ckr+CkviDgpJXgpYvgpKEg4KSc4KS/4KS44KSV4KS+IOCkueCkriDgpKzgpL7gpLAg4KSs4KS+4KSwIOCkieCkquCkr+Cli+CklyDgpJXgpLAg4KS44KSV4KSk4KWHIOCkueCliCB8ICc7CiAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBmaW5kdG9rZW5Qb3NpdGlvbmluQ29kZShMaW5lYnlsaW5lU291cmNlZGF0YSwgZXhwcmVzc2lvbiwgdHJ1ZSk7CgogICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uICE9IHVuZGVmaW5lZCkgewogICAgICAgICAgICAgICAgICBBZGR0b0V4ZWN1dGlvblN0YWNrKEV4ZWN1dGlvblN0YWNrLCBBY3RpdmVMYW5ndWdhZUtleXdvcmRzLkZ1bmN0aW9uLCBkZXNjcmlwdGlvbiwgbXV0YWJsZV90b2tlbnNbal0udmFsdWUsIGZ1bmN0aW9uU291cmNlRGF0YSwgX21lc3NhZ2UsIHBvc2l0aW9uKTsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICBza2lwSW50ZXJwcmV0YXRpb24gPSBmdW5jdGlvblNvdXJjZURhdGEubGVuZ3RoOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgLy9XZSBhcmUgb3V0IG9mIHRoZSBmdWNudGlvbiBleGVjdXRpb24gY29udGV4dCBhbmQgYmFjayB0byBnbG9iYWwgZXhlY3V0aW9uIGNvbnRleHQKCiAgICAgICAgICAgIGNhc2UgJ2NvbmRpdGlvbic6CiAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgdmFyIF9lbGVtZW50ID0gdG9rZW47CiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZTsgLy90aGlzIGZ1bmN0aW9uIGlzIHRoZSBmaXJzdCBzdGVwIHRvIGNhbGN1bGF0ZSB2YWx1ZSBvZiBvcGVyYXRpb25zIGxpa2Ug4KSF4KSX4KSwIChhZ2VvbmU9PT0xMCAmJiBBdmVyYWdlQWdlPDEwMDAgJiYgYWdldHdvPjEwMCB8fCBhZ2VvbmU9PT0xMCkgT1IgKGFnZW9uZT09PTEwICkKCiAgICAgICAgICAgICAgICB2YXIgQ29uZGl0aW9uVmFsdWUgPSBHZXRDb25kaXRpb25WYWx1ZShfZWxlbWVudCwgbWVtb3J5LCBqKTsKICAgICAgICAgICAgICAgIGthbGFhbS5MYXN0Q29uZGl0aW9uVmFsdWUucHVzaChDb25kaXRpb25WYWx1ZSk7IC8vaWYgdmFsdWUgaXMgZmFsc2UsIGp1c3Qgc2tpcCB0aGUgaWYgbG9vcCBjb250ZXh0LCBpZiBub3QgaXQgd2lsbCBiZSByYW4gaW4gZmluYWwgcHJpbnQgbW9kdWxlCgogICAgICAgICAgICAgICAgaWYgKCFDb25kaXRpb25WYWx1ZSkgewogICAgICAgICAgICAgICAgICAvLyAgbGV0IEluaXRpYWxpemVMb29wID0gdG9rZW5zLmluZGV4T2YobXV0YWJsZV90b2tlbnNbal0pOwogICAgICAgICAgICAgICAgICAvL0hhbmRsZSBCbG9ja3MgaXMgYSBmdW5jdGlvbiB3aGljaCB0YWtlcyBjYXJlIG9mIG5lc3RlZCBibG9jayBieSB0YWtpbmcgY2FyZSBvZiBuZXN0ZWQgeyBhbmQgfSBicmFja2V0cwogICAgICAgICAgICAgICAgICAvL2l0IHVzZXMgdGhlIHN0YWNrIHRvIHB1c2ggYW5kIHBvcCBicmFja2V0cyB0byBhY2N1cmF0ZWx5IGlkZW50aWZ5IHN0YXJ0IGFuZCB0aGUgZW5kIG9mIHRoZSBibG9jawogICAgICAgICAgICAgICAgICB2YXIgUmV0dXJudmFsdWUgPSBIYW5kbGVCbG9ja3MobXV0YWJsZV90b2tlbnMsIGopOyAvL2Ftb3VudCB0byBza2lwIGlmIGNvbmRpdGlvbiBpcyBmYWxzZQoKICAgICAgICAgICAgICAgICAgc2tpcEludGVycHJldGF0aW9uID0gUmV0dXJudmFsdWUuaiAtIGo7CiAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSAiXHUwOTE1XHUwOTAyXHUwOTIxXHUwOTQwXHUwOTM2XHUwOTI4ICAiLmNvbmNhdChfZWxlbWVudCwgIiAgLCBGQUxTRShcdTA5MTdcdTA5MzJcdTA5MjQpIFx1MDkzOVx1MDk0Qlx1MDkyOFx1MDk0NyBcdTA5MTVcdTA5NDcgXHUwOTE1XHUwOTNFXHUwOTMwXHUwOTI4IENPTVBVVEVSIFx1MDkwNlx1MDkxN1x1MDk0NyBcdTA5MTVcdTA5NDcgXHUwOTE1XHUwOTRCXHUwOTIxIFx1MDkxNVx1MDk0QiBcdTA5MzBcdTA5MjggXHUwOTI4XHUwOTM5XHUwOTQwXHUwOTAyIFx1MDkxNVx1MDkzMFx1MDk0N1x1MDkxN1x1MDkzRSAiKTsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSAiXHUwOTE1XHUwOTAyXHUwOTIxXHUwOTQwXHUwOTM2XHUwOTI4ICIuY29uY2F0KF9lbGVtZW50LCAiICAsIFRSVUUoXHUwOTM4XHUwOTI0XHUwOTREXHUwOTJGKSBcdTA5MzlcdTA5NEJcdTA5MjhcdTA5NDcgXHUwOTE1XHUwOTQ3IFx1MDkxNVx1MDkzRVx1MDkzMFx1MDkyOCBDT01QVVRFUiBcdTA5MDZcdTA5MTdcdTA5NDcgXHUwOTE1XHUwOTQ3IFx1MDkxNVx1MDk0Qlx1MDkyMSBcdTA5MTVcdTA5NEIgXHUwOTMwXHUwOTI4IFx1MDkxNVx1MDkzMFx1MDk0N1x1MDkxN1x1MDkzRSAiKTsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICB2YXIgX2V4cHJlc3Npb24gPSBfZWxlbWVudDsKICAgICAgICAgICAgICAgIHZhciBfZGVzY3JpcHRpb24gPSAn4KSP4KSVIENlcnRhaW4gQ29uZGl0aW9uIOCkleClhyDgpKTgpLngpKQg4KSV4KWL4KShIEV4ZWN1dGlvbiDgpJXgpYsgQWxsb3cg4KSV4KSw4KSk4KS+IOCkueCliOClpCAnOwogICAgICAgICAgICAgICAgX2V4cHJlc3Npb24gPSBHZXRjbGVhbmVkRXhwcmVzc2lvbihfZXhwcmVzc2lvbik7CgogICAgICAgICAgICAgICAgdmFyIF9wb3NpdGlvbiA9IGZpbmR0b2tlblBvc2l0aW9uaW5Db2RlKExpbmVieWxpbmVTb3VyY2VkYXRhLCBfZXhwcmVzc2lvbiwgdHJ1ZSk7CgogICAgICAgICAgICAgICAgaWYgKF9wb3NpdGlvbiAhPSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgICAgICAgQWRkdG9FeGVjdXRpb25TdGFjayhFeGVjdXRpb25TdGFjaywgQWN0aXZlTGFuZ3VnYWVLZXl3b3Jkcy5JZiwgX2Rlc2NyaXB0aW9uLCBfZWxlbWVudCwgQ29uZGl0aW9uVmFsdWUsIG1lc3NhZ2UsIF9wb3NpdGlvbik7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAvL1NvIHRoYXQgd2UgZG9uJ3QgcHJpbnQgYSBzYW1lIHZhbHVlIHR3aWNlLiBGaXJzdCBpbiBnbG9iYWwgZXhlY3V0aW9uIGNvbnRleHQgYW5kIHRoZSBpbiBmdW5jdGlvbiBjb250ZXh0CiAgICAgICAgICAgIC8vVGhpcyBvbmUgcHJpbnRzIHRoZSBnbG9iYWwgY29udGV4dCB2YWx1ZXMKCiAgICAgICAgICAgIGNhc2UgJ3ByaW50JzoKICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnaHJsb28nKTsKICAgICAgICAgICAgICAgIFByaW50RW5naW5lKG11dGFibGVfdG9rZW5zLCBtZW1vcnksIGopOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lCiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAvL1RoaXMgcnVucyBvdXIgd2hpbGUgbG9vcCAuaS5lIOCknOCkrOCkpOCklQoKICAgICAgICAgICAgY2FzZSAnV2hpbGVMb29wU3RhcnQnOgogICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIChmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgICAgIHZhciBnZXRXaGlsZUxvb3BTb3VyY2VkYXRhID0gZnVuY3Rpb24gZ2V0V2hpbGVMb29wU291cmNlZGF0YShzdGFydEluZGV4LCBtdXRhYmxlX3Rva2VucywgU3RvcmVSZXN1bHQpIHsKICAgICAgICAgICAgICAgICAgICBTdG9yZVJlc3VsdCA9IEhhbmRsZUJsb2NrcyhtdXRhYmxlX3Rva2Vucywgc3RhcnRJbmRleCwgU3RvcmVSZXN1bHQpOwogICAgICAgICAgICAgICAgICAgIHJldHVybiBTdG9yZVJlc3VsdDsKICAgICAgICAgICAgICAgICAgfTsKCiAgICAgICAgICAgICAgICAgIHNraXBJbnRlcnByZXRhdGlvbiA9IDA7CiAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gbXV0YWJsZV90b2tlbnNbaiArIDFdLnZhbHVlOwogICAgICAgICAgICAgICAgICB2YXIgRXh0cmF0Y2VkVmFyaWFibGUgPSBbXTsKICAgICAgICAgICAgICAgICAgdmFyIHZhcmlhYmxlID0gJyc7CiAgICAgICAgICAgICAgICAgIHZhciBXaGlsZUxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydCA9IDA7CiAgICAgICAgICAgICAgICAgIHZhciBXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zID0gW107CgogICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgZWxlbWVudC5sZW5ndGg7IF9pKyspIHsKICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IGVsZW1lbnQuY2hhckF0KF9pKTsKCiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFyaWFibGUoeCkpIHsKICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlID0gdmFyaWFibGUgKyB4OwogICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1ZhcmlhYmxlKGVsZW1lbnQuY2hhckF0KF9pICsgMSkpICYmIGlzVmFyaWFibGUoeCkpIHsKICAgICAgICAgICAgICAgICAgICAgIHZhciBfdG9rZW4yID0gbWVtb3J5LmZpbmQoZnVuY3Rpb24gKGVsKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbC5uYW1lID09PSB2YXJpYWJsZTsKICAgICAgICAgICAgICAgICAgICAgIH0pOwoKICAgICAgICAgICAgICAgICAgICAgIEV4dHJhdGNlZFZhcmlhYmxlLnB1c2goewogICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZTogdmFyaWFibGUsCiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBfdG9rZW4yLnZhbHVlCiAgICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlID0gJyc7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICBXaGlsZUxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydCA9IGdldExvb3BJbmRleFN0YXJ0KG11dGFibGVfdG9rZW5zLCBqLCAneycsIFdoaWxlTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0KTsKICAgICAgICAgICAgICAgICAgV2hpbGVMb29wU291cmNlZGF0YVRva2VucyA9IGdldFdoaWxlTG9vcFNvdXJjZWRhdGEoV2hpbGVMb29wU291cmNlZGF0YUluZGV4U3RhcnQsIG11dGFibGVfdG9rZW5zLCBXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zKS5TdG9yZVJlc3VsdDsKICAgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSAn4KSc4KSs4KSk4KSVICcgKyBlbGVtZW50ICsgJyDgpLjgpLngpYAg4KS54KWL4KSX4KS+IOCkpOCkrCDgpKTgpJUg4KSG4KSX4KWHIOCkleCkviDgpJXgpYvgpKEg4KSw4KSoIOCkleCkv+Ckr+CkviDgpJzgpL7gpK/gpYfgpJfgpL4gJzsKICAgICAgICAgICAgICAgICAgdmFyIGRlc2NyaXB0aW9uID0gJ+CknOCkrOCkpOCklSDgpK7gpYfgpIIg4KSm4KS/4KSPIOCkueClgeCkjyDgpLbgpLDgpY3gpKQoQ29uZGl0aW9uKSDgpJXgpYcg4KSq4KWC4KSw4KS+IOCkueCli+CkqOClhyDgpKTgpJUg4KSG4KSX4KWHIOCkleClhyDgpJXgpYvgpKEg4KSV4KWLIOCksOCkqCDgpJXgpLDgpYcgfCc7CiAgICAgICAgICAgICAgICAgIHZhciBleHByZXNzaW9uID0gR2V0Y2xlYW5lZEV4cHJlc3Npb24oZWxlbWVudCk7CiAgICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IGZpbmR0b2tlblBvc2l0aW9uaW5Db2RlKExpbmVieWxpbmVTb3VyY2VkYXRhLCBleHByZXNzaW9uLCB0cnVlKTsKCiAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiAhPSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgICAgICAgICBBZGR0b0V4ZWN1dGlvblN0YWNrKEV4ZWN1dGlvblN0YWNrLCBBY3RpdmVMYW5ndWdhZUtleXdvcmRzLldoaWxlLCBkZXNjcmlwdGlvbiwgZWxlbWVudCwgV2hpbGVMb29wU291cmNlZGF0YVRva2VucywgbWVzc2FnZSwgcG9zaXRpb24pOwogICAgICAgICAgICAgICAgICB9IC8vY29uc3RhbnRseSBhY2Nlc3NpbmcgdGhlIGNvbmRpdGlvbnZhbHVlCgoKICAgICAgICAgICAgICAgICAgd2hpbGUgKEdldENvbmRpdGlvblZhbHVlKGVsZW1lbnQsIG1lbW9yeSwgaiArIDEpKSB7CiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgV2hpbGVMb29wU291cmNlZGF0YVRva2Vucy5sZW5ndGg7IF9pMisrKSB7CiAgICAgICAgICAgICAgICAgICAgICAvL1NFQ1RJT04gd2hpbGUgbG9vcCBjb250ZXh0CiAgICAgICAgICAgICAgICAgICAgICBpZiAoV2hpbGVMb29wU291cmNlZGF0YVRva2Vuc1tfaTJdLnZhbHVlID09PSAnPScpIHsKICAgICAgICAgICAgICAgICAgICAgICAgQXNzaWdub3JVcGRhdGVWYWx1ZXMoV2hpbGVMb29wU291cmNlZGF0YVRva2VucywgX2kyLCBtZW1vcnksICcnLCAnJywgJycsIEV4ZWN1dGlvblN0YWNrLCBMaW5lYnlsaW5lU291cmNlZGF0YSk7CiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnNbX2kyXS50eXBlID09PSAnQWNjZXB0SW5wdXQnKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIEFjY2VwdElucHV0YW5kU2V0VmFsdWUoV2hpbGVMb29wU291cmNlZGF0YVRva2VucywgX2kyLCBtZW1vcnksIEV4ZWN1dGlvblN0YWNrKTsKICAgICAgICAgICAgICAgICAgICAgIH0gLy8gSGFuZGxpbmcgQ09ORElUSU9OQUwgc3RhdGVtZW50cyBpbiBXaGlsZSBsb29wCiAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zW19pMl0udHlwZSA9PT0gJ2NvbmRpdGlvbicpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAvL2lmIGluZGV4IHJldHVybnMgYSB2YWx1ZSwgaXQgbWVhbnMgY29uZGl0aW9uIGlzIGZhbHNlIGFuZCBza2lwIHRoZSBleGVjdXRpb24KICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBIYW5kbGVDb25kaXRpb25zKFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnMsIF9pMiwgbWVtb3J5KTsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9IHVuZGVmaW5lZCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgX2kyID0gaW5kZXg7CiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pMiA9IF9pMjsKICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIH0gLy9IYW5kbGluZyDgpKbgpL/gpJbgpL7gpI8gc3RhdGVtZW50cyBpbiB3aGlsZSBsb29wCiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnNbX2kyXS52YWx1ZSA9PT0gQWN0aXZlTGFuZ3VnYWVLZXl3b3Jkcy5QcmludCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgUHJpbnRFbmdpbmUoV2hpbGVMb29wU291cmNlZGF0YVRva2VucywgbWVtb3J5LCBfaTIsIEV4ZWN1dGlvblN0YWNrKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZQogICAgICAgICAgICAgICAgICAgICAgICAgIH0gLy9vcGVyYXRpb25zIGxpa2UgTnVtYmVyc1thXT0neHl6JwogICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnNbX2kyXS50eXBlID09PSAnU2V0QXJyYXlJbmRleFZhbHVlJykgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZXRBcnJheUluZGV4VmFsdWUoV2hpbGVMb29wU291cmNlZGF0YVRva2VucywgX2kyLCBqLCBtZW1vcnksIHRva2VucywgT3JpZ2luYWxJdGVyYXRvciwgaXRlcmF0b3IsIEV4ZWN1dGlvblN0YWNrLCBMaW5lYnlsaW5lU291cmNlZGF0YSk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICBza2lwSW50ZXJwcmV0YXRpb24gPSBXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zLmxlbmd0aDsgLy9FbmQgb2YgV2hpbGUgbG9vcCBleGVjdXRpb24KICAgICAgICAgICAgICAgICAgLy9IYW5kbGluZyBGb3IgbG9vcHMKICAgICAgICAgICAgICAgIH0pKCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgY2FzZSAnRm9yTG9vcFN0YXJ0JzoKICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICB2YXIgZ2V0U291cmNlZGF0YSA9IGZ1bmN0aW9uIGdldFNvdXJjZWRhdGEoc3RhcnRJbmRleCwgbXV0YWJsZV90b2tlbnMsIFN0b3JlUmVzdWx0KSB7CiAgICAgICAgICAgICAgICAgIHZhciBSZXR1cm52YWx1ZSA9IEhhbmRsZUJsb2NrcyhtdXRhYmxlX3Rva2Vucywgc3RhcnRJbmRleCwgU3RvcmVSZXN1bHQpOwogICAgICAgICAgICAgICAgICBTdG9yZVJlc3VsdCA9IFJldHVybnZhbHVlLlN0b3JlUmVzdWx0OwogICAgICAgICAgICAgICAgICByZXR1cm4gU3RvcmVSZXN1bHQ7CiAgICAgICAgICAgICAgICB9OwoKICAgICAgICAgICAgICAgIHZhciBGbGFnUHJpbWFsTG9vcCA9IDA7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUKCiAgICAgICAgICAgICAgICB2YXIgU291cmNlZGF0YVRva2VucyA9IFtdOwoKICAgICAgICAgICAgICAgIHZhciBfRm9yTG9vcFNldE1ldGFkYXRhID0gRm9yTG9vcFNldE1ldGFkYXRhKG11dGFibGVfdG9rZW5zLCBqLCBtZW1vcnkpLAogICAgICAgICAgICAgICAgICAgIE9yaWdpbmFsSXRlcmF0b3IgPSBfRm9yTG9vcFNldE1ldGFkYXRhLk9yaWdpbmFsSXRlcmF0b3IsCiAgICAgICAgICAgICAgICAgICAgSXRlcmF0aW9uU3RhcnQgPSBfRm9yTG9vcFNldE1ldGFkYXRhLkl0ZXJhdGlvblN0YXJ0LAogICAgICAgICAgICAgICAgICAgIEl0ZXJhdGlvbkVuZCA9IF9Gb3JMb29wU2V0TWV0YWRhdGEuSXRlcmF0aW9uRW5kLAogICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yID0gX0Zvckxvb3BTZXRNZXRhZGF0YS5pdGVyYXRvciwKICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gX0Zvckxvb3BTZXRNZXRhZGF0YS5lbGVtZW50LAogICAgICAgICAgICAgICAgICAgIEZvckxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydCA9IF9Gb3JMb29wU2V0TWV0YWRhdGEuRm9yTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0LAogICAgICAgICAgICAgICAgICAgIEN5Y2xlID0gX0Zvckxvb3BTZXRNZXRhZGF0YS5DeWNsZTsKCiAgICAgICAgICAgICAgICBGb3JMb29wU291cmNlZGF0YUluZGV4U3RhcnQgPSBnZXRMb29wSW5kZXhTdGFydChtdXRhYmxlX3Rva2VucywgaiwgJ3snLCBGb3JMb29wU291cmNlZGF0YUluZGV4U3RhcnQpOwogICAgICAgICAgICAgICAgU291cmNlZGF0YVRva2VucyA9IGdldFNvdXJjZWRhdGEoRm9yTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0LCBtdXRhYmxlX3Rva2VucywgU291cmNlZGF0YVRva2Vucyk7CiAgICAgICAgICAgICAgICBTb3VyY2VkYXRhVG9rZW5zLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7CiAgICAgICAgICAgICAgICAgIGVsLmlzTmVzdGVkTG9vcCA9IGZhbHNlOwogICAgICAgICAgICAgICAgfSk7IC8vQ2hlY2tpbmcgaWYgdGhlIGZvciBsb29wIGhhcyBvbmUgbW9yZSBmb3IgbG9vcCBpbnNpZGUgaXQKCiAgICAgICAgICAgICAgICB2YXIgRmluZE5lc3RlZExvb3AgPSBTb3VyY2VkYXRhVG9rZW5zLmZpbmQoZnVuY3Rpb24gKGVsKSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiBlbC50eXBlID09PSAnRm9yTG9vcFN0YXJ0JzsKICAgICAgICAgICAgICAgIH0pOwoKICAgICAgICAgICAgICAgIGlmIChGaW5kTmVzdGVkTG9vcCAhPSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgICAgICAgdmFyIE5lc3RlZExvb3BpbmRleCA9IFNvdXJjZWRhdGFUb2tlbnMuaW5kZXhPZihGaW5kTmVzdGVkTG9vcCkgKyAzOwogICAgICAgICAgICAgICAgICB2YXIgTmVzdGVkTG9vcGxlbmd0aCA9IFNvdXJjZWRhdGFUb2tlbnNbTmVzdGVkTG9vcGluZGV4XS5FbmRJbmRleCAtIFNvdXJjZWRhdGFUb2tlbnNbTmVzdGVkTG9vcGluZGV4XS5zdGFydEluZGV4ICsgMjsgLy9pZiB3ZSBoYXZlIGEgbmVzdGVkIGxvb3AsIHNldCBpc05lc3RlTG9vcCB0byBUUlVFCgogICAgICAgICAgICAgICAgICBmb3IgKHZhciB4ID0gTmVzdGVkTG9vcGluZGV4OyB4IDwgTmVzdGVkTG9vcGluZGV4ICsgTmVzdGVkTG9vcGxlbmd0aDsgeCsrKSB7CiAgICAgICAgICAgICAgICAgICAgU291cmNlZGF0YVRva2Vuc1t4XS5pc05lc3RlZExvb3AgPSB0cnVlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuaW5jbHVkZXMoJygnKSAmJiBlbGVtZW50LmluY2x1ZGVzKCcsJykpIHsKICAgICAgICAgICAgICAgICAgRmxhZ1ByaW1hbExvb3AgPSAxOwogICAgICAgICAgICAgICAgfSAvL0l0ZXJhdGluZyBvdmVyIGZvcmxvb3Agc291cmNlZGF0YQogICAgICAgICAgICAgICAgLy9zZWxmIGxpbmUgJ2l0ZXJhdG9yIDw9IEN5Y2xlJyBkZXRlcm1pbmVzIHN0YXJ0IG9mIHRoZSBsb29wIGFuZCB0aGUgZHVyYXRpb24gb2YgdGhlIGxvb3AKCgogICAgICAgICAgICAgICAgdmFyIF9tZXNzYWdlMiA9ICfgpKbgpYHgpLngpLDgpL7gpJMg4KSV4KWHIOCkheCkguCkpuCksCDgpLLgpL/gpJbgpYcg4KSX4KSPIOCkleCli+CkoSDgpJXgpYsgJyArIEl0ZXJhdGlvblN0YXJ0ICsgJyDgpLjgpYcgJyArIEl0ZXJhdGlvbkVuZCArICcg4KSk4KSVLCDgpK7gpKTgpLLgpKwgJyArIGV2YWwoSXRlcmF0aW9uRW5kIC0gSXRlcmF0aW9uU3RhcnQgKyAxKSArICcg4KSs4KS+4KSwIFJVTijgpLDgpKgpIOCkleCkv+Ckr+CkviDgpJzgpL7gpK/gpYfgpJfgpL4gfCcgKyAnXG4nICsgJyDgpIfgpLjgpK7gpYfgpIIgQ29tcHV0ZXIsICcgKyAnIicgKyBpdGVyYXRvciArICciJyArICcg4KSV4KWLIE1lbW9yeSDgpK7gpYfgpIIsICcgKyBJdGVyYXRpb25TdGFydCArICcg4KS44KWHICcgKyBJdGVyYXRpb25FbmQgKyAnIOCkpOCklSDgpJXgpLzgpYDgpK7gpKQoVmFsdWVzKSDgpLjgpYfgpJ8g4KSV4KSw4KSk4KS+IOCknOCkvuCkj+Ckl+CkvnwnOyAvL1RoaXMgaXMgdGhlIGV4cGVyZXNzaW9uIHdoY2loIGlzIGdldHRpbmcgZXZhbHVhdGVkLgoKCiAgICAgICAgICAgICAgICB2YXIgX2V4cHJlc3Npb24yID0gJ+CkpuClgeCkueCksOCkvuCkkyAnICsgaXRlcmF0b3IgKyAnIOCkleCliyAnICsgbXV0YWJsZV90b2tlbnNbaiArIDFdLnZhbHVlICsgJyDgpK7gpYcnOwoKICAgICAgICAgICAgICAgIHZhciBfZGVzY3JpcHRpb24yID0gJ+Ckj+CklSDgpLngpYAg4KSV4KWL4KShIOCkleCliyDgpKzgpL7gpLAt4KSs4KS+4KSwIOCkpuCli+CkueCksOCkvuCkqOCkvuClpCAnOwogICAgICAgICAgICAgICAgdmFyIExpbmVudW1iZXIgPSBMaW5lYnlsaW5lU291cmNlZGF0YS5pbmRleE9mKF9leHByZXNzaW9uMik7CiAgICAgICAgICAgICAgICBMaW5lbnVtYmVyICs9IDE7CiAgICAgICAgICAgICAgICBBZGR0b0V4ZWN1dGlvblN0YWNrKEV4ZWN1dGlvblN0YWNrLCBBY3RpdmVMYW5ndWdhZUtleXdvcmRzLkZvciwgX2Rlc2NyaXB0aW9uMiwgU291cmNlZGF0YVRva2VucywgJycsIF9tZXNzYWdlMiwgTGluZW51bWJlcik7CgogICAgICAgICAgICAgICAgZm9yIChpdGVyYXRvciA9IEl0ZXJhdGlvblN0YXJ0OyBpdGVyYXRvciA8PSBDeWNsZTsgaXRlcmF0b3IrKykgewogICAgICAgICAgICAgICAgICB2YXIgZm9ybG9vcGluZGV4ID0gbWVtb3J5LmZpbmQoZnVuY3Rpb24gKGVsKSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsLm5hbWUgPT09IE9yaWdpbmFsSXRlcmF0b3I7CiAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgICBmb3Jsb29waW5kZXgudmFsdWUgPSBpdGVyYXRvcjsgLy9mbGFnIHRvIGF2b2lkIHJ1bm5pbmcgdGhpcyBjb2RlIGlmIGxvb3AgaXMgcHJpbWFsIGJlY2F1c2UgdGhlIHBheWxvYWQgbmVlZHMgdG8gYmUgY29tcGVsdGVseSBkaWZmZXJlbnQKCiAgICAgICAgICAgICAgICAgIGlmIChGbGFnUHJpbWFsTG9vcCA9PT0gMCkgey8vIEZvckxvb3BBcnJheW9yU3RyaW5nT3V0cHV0KGVsZW1lbnRWYWx1ZSwgaXRlcmF0b3IsIG1lbW9yeSwgc2VsZik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUKICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgU291cmNlZGF0YVRva2Vucy5sZW5ndGg7IF9pMysrKSB7CiAgICAgICAgICAgICAgICAgICAgLy8gbGV0IGlzTmVzdGVkID0gU291cmNlZGF0YVRva2Vuc1tpXS5pc05lc3RlZExvb3A7CiAgICAgICAgICAgICAgICAgICAgLy9UaGlzIGNvZGUgcnVucyBvbmx5IGlmIHdlIGhhdmUgYSBuZXN0ZWQgbG9vcCBzaXR1YXRpb24KICAgICAgICAgICAgICAgICAgICBza2lwSW50ZXJwcmV0YXRpb24gPSAwOwoKICAgICAgICAgICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgICAgICAgaW50ZXJwcmV0VG9rZW4oU291cmNlZGF0YVRva2VucywgX2kzLCBtZW1vcnkpOwogICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUsICJlcnJvciBpbiBpbnRlcnByZXRpbmcgZm9yIGxvb3AgIi5jb25jYXQoU291cmNlZGF0YVRva2Vuc1tfaTNdKSk7CiAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICBpZiAoc2tpcEludGVycHJldGF0aW9uICE9IDApIHsKICAgICAgICAgICAgICAgICAgICAgIF9pMyA9IF9pMyArIHNraXBJbnRlcnByZXRhdGlvbjsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICBza2lwSW50ZXJwcmV0YXRpb24gPSBza2lwSW50ZXJwcmV0YXRpb24gKyBTb3VyY2VkYXRhVG9rZW5zLmxlbmd0aDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIC8vRU5EIEZPUiBMT09QIEVYRUNVVElPTgoKICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb25FeGVjdXRpb24nOgogICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIC8vY2hlY2tpbmcgaWYgZnVuY3Rpb24gaXMgaW52b2tlZCBzb21ld2hlcmUgbGF0ZXIgaW4gdGhlIHByb2dyYW0KICAgICAgICAgICAgICAgIC8vSWYgd2Ugc2VlIGEgZnVuY3Rpb24gZXhlY3V0aW9uIGNhbGwsIGZvciBlLmcgQWRkKHgseSksIHdlIHByZXBhcmUgZm9yIGV4ZWN1dGlvbgogICAgICAgICAgICAgICAgdmFyIF9mdW5jdGlvblNvdXJjZURhdGEgPSBbXTsKICAgICAgICAgICAgICAgIHZhciBmdW5jdGlvbk5hbWUgPSB0b2tlbjsKICAgICAgICAgICAgICAgIHZhciBwYXNzZWRWYWx1ZXMgPSBtdXRhYmxlX3Rva2Vuc1tqXS5wYXNzZWRWYWx1ZXM7CiAgICAgICAgICAgICAgICB2YXIgZnVuY3Rpb25Ub2tlbiA9IG11dGFibGVfdG9rZW5zLmZpbmQoZnVuY3Rpb24gKGVsKSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiBlbC52YWx1ZSA9PT0gZnVuY3Rpb25OYW1lOwogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICB2YXIgZnVuY3Rpb25Bcmd1bWVudHMgPSBmdW5jdGlvblRva2VuLmFyZ3VtZW50czsKICAgICAgICAgICAgICAgIF9mdW5jdGlvblNvdXJjZURhdGEgPSBmdW5jdGlvblRva2VuLlNvdXJjZURhdGE7IC8vQ3JlYXRpbmcgYSBzZXBlcmF0ZSBleGVjdXRpb24gY29udGV4dCBhbmQgc2V0dGluZyBmdWNudGlvbiBjb250ZXh0IG5hbWU6dmFsdWUgcGFpciBpbiBmdW5jdGlvbkNvbnRleHRtZW1vcnkKICAgICAgICAgICAgICAgIC8vZm9yIGUuZyB4PTMsIHk9NCBpcyBhbHJlYWR5IGRlZmluZWQgYW5kIHRoZW4gd2UgZXhlY3V0ZSBhZGQoeCx5KQogICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhbiBtZW1vcnkgZm9ybSBsaW1pdGVkIHRvIGZ1bmN0aW9uIGNvbnRleHQKICAgICAgICAgICAgICAgIC8vT3BlcmF0aW5nIG9uIGZ1bmN0aW9uIGFyZ3VtZW50cyBhbmQgc2V0dGluZyB0aGVpciB2YWx1ZXMuIEZvciBlLmcgdGhlIGZ1bmN0aW9uIGFkZCh4LHkpIG1pZ2h0IGJlIGNhbGxlZCBhcyBhZGQoMyw0KQogICAgICAgICAgICAgICAgLy9zbyB3ZSBzZXQgeD0zLCB5PTQgYW5kIHNldCBzZWxmIHZhcmlhYmxlLXZhbHVlIHBhaXIgaW4gZnVuY3Rpb25Db250ZXh0bWVtb3J5CgogICAgICAgICAgICAgICAgZnVuY3Rpb25Bcmd1bWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWwsIGluZGV4KSB7CiAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBwYXNzZWRWYWx1ZXNbaW5kZXhdOwogICAgICAgICAgICAgICAgICB2YWwgPSB2YWwucmVwbGFjZSgvIi9nLCAnJyk7CiAgICAgICAgICAgICAgICAgIHZhbCA9IHZhbC5yZXBsYWNlKC8nL2csICcnKTsKICAgICAgICAgICAgICAgICAgcGFzc2VkVmFsdWVzW2luZGV4XSA9IHZhbDsgLy9pbiBzZWxmIGNvZGUgd2UgYXJlIGZpbHRlcmluZyBvdXQgYXJndW1lbnRzIHBhc3NlZCBiYXNlZCBvbiB3aGV0aGVyIHRoZXkgYWxyZWFkeSBleGlzdCBpbiB1cGRhdGVkIHRva2VucyBvciBub3QKCiAgICAgICAgICAgICAgICAgIHZhciBGaW5kSW5VcGRhdGVkVG9rZW5zID0gbWVtb3J5LmZpbmQoZnVuY3Rpb24gKGVsKSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsLm5hbWUgPT09IHZhbDsKICAgICAgICAgICAgICAgICAgfSk7IC8vRm9yIHBhc3Npbmcgc2FtZSBhcmd1bWVudCBhbmQgc2FtZSB2YWx1ZSB0byBmdW5jdGlvbiAgZS5nIGZ1bmN0aW9uIGZvbyAoZmlib25hY2NpKSBhbmQgZmlib25hY2NpIGlzIGFscmVhZHkgZGVjbGFyZWQgd2l0aCBzb21lIHZhbHVlCgogICAgICAgICAgICAgICAgICBpZiAoRmluZEluVXBkYXRlZFRva2VucyA9PT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25Db250ZXh0bWVtb3J5LnB1c2goewogICAgICAgICAgICAgICAgICAgICAgbmFtZTogZWwsCiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsLAogICAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllcjogaiArIGluZGV4LAogICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3ZhbHVlJywKICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6ICdGdW5jdGlvbkV4ZWN1dGlvbkNvbnRleHQnCiAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICAgIH0gLy9Gb3IgcGFzc2luZyBkaWZmZXJlbnQgYXJndW1lbnQgYW5kIHZhbHVlIHRvIGZ1bmN0aW9uICBlLmcgZnVuY3Rpb24gZm9vIChhcnIpIGFuZCBhcnIgZG9lc24ndCBleGlzdCBhbnl3aGVyZSBpbiB0b2tlbnMuCiAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVsICE9IEZpbmRJblVwZGF0ZWRUb2tlbnMubmFtZSAmJiBGaW5kSW5VcGRhdGVkVG9rZW5zICE9IHVuZGVmaW5lZCkgewogICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25Db250ZXh0bWVtb3J5LnB1c2goewogICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBlbCwKICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IEZpbmRJblVwZGF0ZWRUb2tlbnMudmFsdWUsCiAgICAgICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXI6IGogKyBpbmRleCwKICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogRmluZEluVXBkYXRlZFRva2Vucy50eXBlLAogICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiAnRnVuY3Rpb25FeGVjdXRpb25Db250ZXh0JywKICAgICAgICAgICAgICAgICAgICAgICAgSW50aGVFbmRTZXRWYWx1ZXRvOiB2YWwKICAgICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbkNvbnRleHRtZW1vcnkucHVzaCh7CiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGVsLAogICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsLAogICAgICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVyOiBqICsgaW5kZXgsCiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEZpbmRJblVwZGF0ZWRUb2tlbnMudHlwZSwKICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogJ0Z1bmN0aW9uRXhlY3V0aW9uQ29udGV4dCcsCiAgICAgICAgICAgICAgICAgICAgICAgIEludGhlRW5kU2V0VmFsdWV0bzogdmFsCiAgICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9KTsgLy9CdWlsZGluZyBhIGNvbXBsZXRlIHZhcmlhYmxlLXZhbHVlIHBhaXIgZGF0YXNldAoKICAgICAgICAgICAgICAgIHZhciBDb21wbGV0ZVRva2VuVmFsdWVMaXN0ID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShtZW1vcnkpLCBmdW5jdGlvbkNvbnRleHRtZW1vcnkpOwoKICAgICAgICAgICAgICAgIHZhciBfbWVzc2FnZTMgPSAnQ29tcHV0ZXIgJyArICciJyArIGZ1bmN0aW9uTmFtZSArICciJyArICcg4KSo4KS+4KSuIOCkleClgCDgpLDgpJrgpKjgpL4g4KSV4KWLIOCkleClieCksiAoQ2FsbCkg4KSV4KSw4KSk4KS+IOCkueCliCB8IOCkhuCkquCkqOClhyAnICsgJyIoKSInICsgJyDgpJXgpYcg4KSF4KSC4KSm4KSwIOCkpuCkv+CkjyDgpJfgpI8gTmV3IFZhbHVlcyDgpJXgpL4g4KSw4KSa4KSo4KS+ICcgKyBmdW5jdGlvbk5hbWUgKyAnIOCkruClh+CkgiDgpIngpKrgpK/gpYvgpJcg4KSV4KSw4KSV4KWHLCDgpLDgpJrgpKjgpL4gJyArIGZ1bmN0aW9uTmFtZSArICcg4KSu4KWH4KSCIOCksuCkv+CkluClhyDgpJfgpI8g4KSV4KWL4KShIOCkleCliyDgpLDgpKgg4KSV4KSw4KSk4KS+IOCkueCliCB8JzsKCiAgICAgICAgICAgICAgICB2YXIgX2V4cHJlc3Npb24zID0gZnVuY3Rpb25OYW1lICsgJygnOwoKICAgICAgICAgICAgICAgIHZhciBfZGVzY3JpcHRpb24zID0gJyDgpI/gpJUg4KS14KS/4KS24KS/4KS34KWN4KSfIOCksOClguCkqiDgpLjgpYcg4KSy4KS/4KSW4KS+IOCkl+Ckr+CkviDgpJXgpYvgpKEg4KSc4KS/4KS44KSV4KS+IOCkueCkriDgpKzgpL7gpLAg4KSs4KS+4KSwIOCkieCkquCkr+Cli+CklyDgpJXgpLAg4KS44KSV4KSk4KWHIOCkueCliCB8ICc7CgogICAgICAgICAgICAgICAgdmFyIF9wb3NpdGlvbjIgPSBmaW5kdG9rZW5Qb3NpdGlvbmluQ29kZShMaW5lYnlsaW5lU291cmNlZGF0YSwgX2V4cHJlc3Npb24zLCBmYWxzZSk7CgogICAgICAgICAgICAgICAgaWYgKF9wb3NpdGlvbjIgIT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgICAgICAgIEFkZHRvRXhlY3V0aW9uU3RhY2soRXhlY3V0aW9uU3RhY2ssIEFjdGl2ZUxhbmd1Z2FlS2V5d29yZHMuRnVuY3Rpb24sIF9kZXNjcmlwdGlvbjMsIGZ1bmN0aW9uTmFtZSwgX2Z1bmN0aW9uU291cmNlRGF0YSwgX21lc3NhZ2UzLCBfcG9zaXRpb24yKTsKICAgICAgICAgICAgICAgIH0gLy9Ob3cgd2Ugc3RhcnQgZGlnZ2luZyBpbnRvIHRoZSBmdW5jdGlvbiBleGVjdXRpb24KICAgICAgICAgICAgICAgIC8vbWlnaHQgaGF2ZSB0byBjaGFuZ2UgaSB0byAxCiAgICAgICAgICAgICAgICAvL3NraXAgaW4gZnVuY3Rpb25zb3VyY2VkYXRhCgoKICAgICAgICAgICAgICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IF9mdW5jdGlvblNvdXJjZURhdGEubGVuZ3RoOyBfaTQrKykgewogICAgICAgICAgICAgICAgICBza2lwSW50ZXJwcmV0YXRpb24gPSAwOwoKICAgICAgICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgICAgICBpbnRlcnByZXRUb2tlbihfZnVuY3Rpb25Tb3VyY2VEYXRhLCBfaTQsIENvbXBsZXRlVG9rZW5WYWx1ZUxpc3QpOwogICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZSwgImVycm9yIGluIGludGVycHJldGluZyBmdW5jdGlvbiBleGVjdXRpb24gIi5jb25jYXQoZnVuY3Rpb25OYW1lKSk7CiAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgIGlmIChza2lwSW50ZXJwcmV0YXRpb24gIT0gMCkgewogICAgICAgICAgICAgICAgICAgIF9pNCA9IF9pNCArIHNraXBJbnRlcnByZXRhdGlvbjsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICBjb25zb2xlLmxvZyhlLCAiRXJyb3IgaW4gSW50ZXJwcmV0aW5nIHRva2VuICIuY29uY2F0KG11dGFibGVfdG9rZW5zW2pdKSk7CiAgICAgIH0KICAgICAgLyogZWxzZSBpZiAodG9rZW4gPT09ICLgpIXgpKjgpY3gpK/gpKXgpL4iKSB7CiAgICAgICAgbGV0IHJlc3VsdCA9IEhhbmRsZUJsb2NrcyhtdXRhYmxlX3Rva2VucywgaiwgcmVzdWx0KTsKICAgICAgICAvLyBsZXQgU3RhcnRvZkJsb2NrID0gbXV0YWJsZV90b2tlbnNbaiArIDFdLnN0YXJ0SW5kZXg7CiAgICAgICAgbGV0IEVuZG9mQmxvY2sgPSBtdXRhYmxlX3Rva2Vuc1tqICsgMV0uRW5kSW5kZXg7CiAgICAgICAgICAgbGV0IGxhc3RWYWx1ZSA9IGthbGFhbS5MYXN0Q29uZGl0aW9uVmFsdWUucG9wKCk7CiAgICAgICAgICAgaWYgKGxhc3RWYWx1ZSkgewogICAgICAgICAgaiA9IEVuZG9mQmxvY2s7CiAgICAgICAgfSovCgogICAgfTsgLy8jU1RFUCAxLSBDbGVhbmluZyB0aGUgc291cmNlZGF0YSBhbmQgc2V0dGluZyB0aGUgJ3Jlc3VsdCcgdG8gJ2NsZWFuZWRfc291cmNlZGF0YScKICAgIC8vSWYgYSBjb2RlIGlzIG5vdCB3b3JraW5nLCBpdCBpcyBwcm9iYWJseSBiZWNhdXNlIGl0J3Mgbm90IGNsZWFuZWQgcHJvcGVybHkuCgoKICAgIC8vVGhpcyBpcyB3aGVyZSBlcnJvciBoYW5kbGluZyBraWNrcyBpbgogICAgLy9UbyBmaW5kIHVuZGVmaW5lZCB2YXJpYWJsZXMKICAgIHZhciBvbmx5VW5pcXVlID0gZnVuY3Rpb24gb25seVVuaXF1ZSh2YWx1ZSwgaW5kZXgsIGFycikgewogICAgICByZXR1cm4gYXJyLmluZGV4T2YodmFsdWUpID09PSBpbmRleDsKICAgIH07CgogICAgLy90MCBhbG9uZyB3aXRoIHQxIHRha2VzIHJlY29yZCBvZiBUaW1lIHRha2VuIHRvIHJ1biB0aGUgY29kZS4gdDEtdDAgZ2l2ZXMgdXMgdGhlIGV4YWN0IHRpbWUgdGFrZW4uCiAgICB2YXIgdDAgPSBwZXJmb3JtYW5jZS5ub3coKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZQogICAgLy9Tb3VyY2VkYXRhIGlzIHRoZSByYXcgY29kZSBwcm92aWRlZCBieSB1c2VyCgogICAgdmFyIHNvdXJjZWRhdGEgPSBzb3VyY2Vjb2RlOwogICAgdmFyIExpbmVieWxpbmVTb3VyY2VkYXRhID0gc291cmNlZGF0YS5yZXBsYWNlKC8oPzpcclxufFxyfFxuKS9nLCAnYnJlYWtwb2ludCcpLnNwbGl0KCdicmVha3BvaW50Jyk7IC8vVGhpcyBpcyB3aGVyZSBmb3JtYXR0ZWQgYW5kIGNsZWFuZWQgc291cmNlZGF0YSB3aWxsIGdvLgoKICAgIHZhciBjbGVhbmVkX3NvdXJjZWRhdGEgPSBbXTsKICAgIHZhciBFeGVjdXRpb25TdGFjayA9IFtdOwogICAgdmFyIGkgPSAwOyAvL1RoaXMgaXMgd2hlcmUgdG9rZW5zIHdpbGwgYmUgcHVzaGVkIGRlcGVuZGluZyB1cG9uIHRoZWlyIHR5cGVzIGxpa2UgVmFyaWFibGUsIGZ1bmN0aW9uLCBsb29wcyBldGMuCgogICAgdmFyIHRva2VucyA9IFtdOyAvL0V4cGVyaW1lbnRhbAoKICAgIHZhciBtaXhlZGltcHVyaXR5ID0gW107IC8vVGhlIHZhcmlhYmxlcyB3aXRoIHRoZWlyIGNhbGN1bGF0ZWQgdmFsdWVzIGFyZSBwdXNoZWQgaGVyZS4gSWYgYz1hK2IsIG1lbW9yeSBpcyB3aGVyZSB5b3Ugd2lsbCBmaW5kIHRoZSBjYWxjdWxhdGVkIHZhbHVlCgogICAgdmFyIG1lbW9yeSA9IFtdOyAvL1ZhcmlhYmxlLXZhbHVlIHBhaXJzIHNpbWlsYXIgdG8gbWVtb3J5IGJ1dCBsaW1pdHMgaXRzZWxmIHRvIGEgdXNlciBjcmVhdGVkIGZ1bmN0aW9uLgoKICAgIHZhciBmdW5jdGlvbkNvbnRleHRtZW1vcnkgPSBbXTsKICAgIHZhciB2YXJpYWJsZXNfYXJyYXkgPSBbXTsgLy9QdXNoaW5nIHRoZSB2YXJpYWJsZXMgdGhhdCBhcmUgYXNzaWduZWQgdG8gZmlsdGVyIG91dCBkZWZpbmVkIGFuZCB1bmRlZmluZWQgdmFyaWFibGVzLiBVc2VmdWwgaW4gZXJyb3IgaGFuZGxpbmcKCiAgICB2YXIgYXNzaWduZWRfdmFyaWFibGVzID0gW107IC8vVE8gUkVNT1ZFIERVUExJQ0FURSBWQVJJQUJMRVMsCiAgICAvLyB2YXIgdmFyaWFibGVBcnJheSA9IFtdOwogICAgLy9BIHRlbXBvcmFyeSBpbnN0YW5jZSBvZiBhIGdsb2JhbCB2YXJpYWJsZS4gVXNlZCBiZWNhdXNlIG9mIHNjb3BpbmcgaXNzdWUsIHRoZXJlIGFyZSBiZXR0ZXIgc291bHRpb25zIGFuZCB3ZSB3aWxsIGRvIHRoYXQuCiAgICAvL2VtcHR5aW5nIGFjY3VtdWxhdGVkIHZhbHVlCiAgICAvL1NlZSBBc3NpZ25vclVwZGF0ZVZhbHVlcyBmdW5jdGlvbiBmb3IgbW9yZQoKICAgIHZhciBza2lwUGFyc2luZyA9IDA7CiAgICB2YXIgc2tpcEludGVycHJldGF0aW9uID0gMDsKICAgIFJlc2V0VmFsdWUoKTsKICAgIHZhciBrYWxhYW0gPSB7fTsgLy9JZiBhbiBlcnJvciBpcyBlbmNvdW50ZXJlZCB3ZSBzZXQgdGhlIHZhbHVlIHRvIHRydWUgYW5kIHB1c2ggdGhlIGVycm9yIHRvIGVycm9ycyBhcnJheS4KCiAgICBrYWxhYW0uaXNFcnJvciA9IGZhbHNlOwogICAgc291cmNlY29kZSA9IGVhcmx5Q2xlYW5pbmcoc291cmNlY29kZSk7CiAgICBrYWxhYW0ub3V0cHV0ID0gJyc7CiAgICBrYWxhYW0uTGFzdENvbmRpdGlvblZhbHVlID0gW107CiAgICBrYWxhYW0uRXhlY3V0aW9uU3RhY2sgPSBbXTsKICAgIGthbGFhbS5saW5lYnlsaW5lT3V0cHV0ID0ga2FsYWFtLm91dHB1dC5zcGxpdCgnXG4nKTsKICAgIGthbGFhbS5lcnJvciA9IFtdOwogICAga2FsYWFtLk9wZXJhdGlvbk9iamVjdHMgPSBbXTsgLy9TRUNUSU9OIC0gQ2hlY2tpbmcgZm9yIHR5cGUgb2YgY2hhcmFjdGVycy4gVHlwZUNoZWNrIGlzIGFuIG9iamVjdCB3aGljaCBjb25zaXN0cyBhbGwgc2VsZiBmdW5jdGlvbnMuIENoZWNrIExpbmUgMTAyCgogICAgdmFyIGlzVmFyaWFibGUgPSBUeXBlQ2hlY2suaXNWYXJpYWJsZSgpOwogICAgdmFyIGlzTnVtYmVyID0gVHlwZUNoZWNrLmlzTnVtYmVyKCk7CiAgICB2YXIgaXNXaGlsZUxvb3AgPSBUeXBlQ2hlY2suaXNXaGlsZUxvb3AoKTsKICAgIHZhciBpc1B1cmVFdmFsID0gQWR2YW5jZWRUeXBlQ2hlY2suaXNQdXJlRXZhbCgpOyAvL2lmIF90b2tlbnNyIGVuY291bnRlcnMgYW55dGhpbmcgbGlrZSAoIiBvciAoLCB0aGVuIHRoYXQncyBhIHJlYWx0aW1lIHByaW50LgogICAgLy9idWlsZHN0cmluZyB3aWxsIGJlIGFwcGxpZWQgbm93IHRvIGNyZWF0ZSBhIHN0cmluZyBhbmQgcHVzaCBpdCBpbnRvIHRva2Vucy4gQnVpbGRzdHJpbmcgaXMgdXNlZCB0byBjb21iaW5lIHN0cmluZyB0b2tlbnMgbGlrZQogICAgLy9bJ2hlbGxvJywgJ0thbGFhbScsICdkZXZlbG9wZXJzJywgIiEiXSBpbnRvICdoZWxsbyBrYWxhYW0gZGV2ZWxvcGVycyEnLgogICAgLy9JdCdzIGJlY2F1c2UgY2xlYW5lZF9zb3VyY2VkYXRhIGlzIGFuIGFycmF5IG9mIHRva2VucyBhbmQgZWFjaCB0b2tlbiBpcyBhbiBpbmRpdmlkdWFsIHdvcmQgaW4gYSBwcm9ncmFtLgogICAgLy9JdCdzIHJlY29tbWVuZGVkIHRvIGxvb2sgYXQgY2xlYW5lZF9zb3VyY2VkYXRhIG9mIGV2ZXJ5IHByb2dyYW0gdG8gdW5kZXJzdGFuZCBob3cgaXQgY29udmVydHMgcGxhaW4gdGV4dCBpbnRvIGFycmF5IG9mIGluZGl2aWR1YWwgd29yZHMuCgogICAgdmFyIGlzUmVhbFRpbWVQcmludE11bHRpcGxlU3RyaW5nID0gQWR2YW5jZWRUeXBlQ2hlY2suaXNSZWFsVGltZVByaW50TXVsdGlwbGVTdHJpbmcoKTsgLy9jb25zdCBpc1N0cmluZ2FuZFZhbHVlID0gQWR2YW5jZWRUeXBlQ2hlY2suaXNTdHJpbmdhbmRWYWx1ZSgpCgogICAgdmFyIGlzQ2FsY3VsYXRpb24gPSBBZHZhbmNlZFR5cGVDaGVjay5pc0NhbGN1bGF0aW9uKCk7IC8vIGNvbnN0IGlzRGlyZWN0UHJpbnRBcml0aG1ldGljID0gQWR2YW5jZWRUeXBlQ2hlY2suaXNEaXJlY3RQcmludEFyaXRobWV0aWMoKQogICAgLy9TRUNUSU9OIC0gQnVpbGQgT3BlcmF0aW9ucwogICAgLy9UbyBjb252ZXJ0IFsnaGVsbG8nLCAnS2FsYWFtJywgJ2RldmVsb3BlcnMnLCAiISJdIGludG8gJ2hlbGxvIGthbGFhbSBkZXZlbG9wZXJzIScuCgogICAgdmFyIEJ1aWxkU3RyaW5nID0gQnVpbGRPcGVyYXRpb24uQnVpbGRTdHJpbmcoKTsgLy9UbyBjb252ZXJ0IFsnWycsICd4JywneScsJ3onLCddJ10gaW50byBbJ3gnLCd5JywneiddCgogICAgdmFyIEJ1aWxkQXJyYXkgPSBCdWlsZE9wZXJhdGlvbi5CdWlsZEFycmF5KCk7IC8vc2VsZiBmdW5jdGlvbiBpcyB0aGUgZmlyc3Qgc3RlcCB0byBoYW5kbGxlIG9wZXJhdGlvbnMgbGlrZSDgpIXgpJfgpLAgKGFnZW9uZT09PTEwICYmIEF2ZXJhZ2VBZ2U8MTAwMCAmJiBhZ2V0d28+MTAwIHx8IGFnZW9uZT09PTEwKSBPUiAoYWdlb25lPT09MTAgKQoKICAgIHZhciBCdWlsZENvbmRpdGlvbiA9IEJ1aWxkT3BlcmF0aW9uLkJ1aWxkQ29uZGl0aW9uKCk7CiAgICBjbGVhbmVkX3NvdXJjZWRhdGEgPSBHZXRDbGVhblNvdXJjZWRhdGEoc291cmNlZGF0YSwgY2xlYW5lZF9zb3VyY2VkYXRhLCBtaXhlZGltcHVyaXR5KTsKICAgIGNvbnNvbGUubG9nKCdjbGVhbmVkX3NvdXJjZWRhdGE6JywgY2xlYW5lZF9zb3VyY2VkYXRhKSAvLyNTVEVQIDItIC0gUGFyc2luZyBjbGVhbmVkX3NvdXJjZWRhdGEsIGFkZGluZyBlYWNoIGl0ZW0gZGVwZW5kaW5nIG9uIGl0J3MgdHlwZSB0byB0b2tlbnMgYXJyYXkKICAgIC8vIFBBUlNJTkcgSU5JVElBVElPTgogICAgKGZ1bmN0aW9uIF9wYXJzZXIoKSB7CiAgICAgIGZvciAoaTsgaSA8IGNsZWFuZWRfc291cmNlZGF0YS5sZW5ndGg7IGkrKykgewogICAgICAgIF9hbmFseXplVG9rZW4oY2xlYW5lZF9zb3VyY2VkYXRhLCBpLCB0b2tlbnMpOyAvL0NvZGUgdG8gc2tpcCBpbXByb3ZlIGEgcGFydGljdWxhciBwYXJ0IG9mIGNsZWFuZWRfc291cmNlZGF0YSBpZiBpdCdzIGJlaW5nIG9wZXJhdGVkIGJ5IHR3byBkaWZmZXJlbnQgZnVuY3Rpb25zLgoKCiAgICAgICAgaWYgKHNraXBQYXJzaW5nICE9IDApIHsKICAgICAgICAgIGkgPSBpICsgc2tpcFBhcnNpbmc7CiAgICAgICAgfQogICAgICB9CiAgICB9KSgpOyAvL0NMRUFOSU5HIFVQIFRIRSBUT0tFTlMgQVJSQVkKICAgIC8vUmVtb3ZpbmcgdG9rZW5zIHdpdGggdmFsdWUgPSAnJywgSXQgd2FzIGdlbmVyYXRlZCBkdWUgdG8gIiBjbGVhbmVkX3NvdXJjZWRhdGEgPSBjbGVhbmVkX3NvdXJjZWRhdGEucmVwbGFjZSgvKDt8XG58XHIpL2dtLCAiICIpLnNwbGl0KCcgJykiCiAgICAvL0ZpbHRlcmluZyBzZWVtZWQgdW5uZWNlc3NhcnksIHJlbW92ZWQgZm9yIG5vdy4KICAgIC8vdG9rZW5zID0gdG9rZW5zLmZpbHRlcihlbCA9PiBlbC52YWx1ZSAhPSAnJykKICAgIC8vdmFyaWFibGVBcnJheSA9IHRva2Vucy5maWx0ZXIoKGVsKSA9PiBlbC50eXBlID09PSAndmFyaWFibGUnKTsKICAgIC8vQXMgb2Ygbm93LCB0aGlzIGlzIGhvdyB0aGUgdGltZWxpbmUgbG9va3MKICAgIC8vcmF3IHNvdXJjZWNvZGUgLT4gY2xlYW5lZF9zb3VyY2VkYXRhIC0+IHRva2VucwogICAgLy8jU1RFUCAzIC0gZXZhbHVhdGluZyBjb25kaXRpb25zLCBydW5uaW5nIGxvb3BzLCBleGVjdXRpbmcgZnVuY3Rpb25zIGZpbmRpbmcgdmFsdWVzIGluIG1lbW9yeSBhbmQgcHJpbnRpbmcgb3V0cHV0cwogICAgLy9UaGlzIGlzIHRoZSBmaW5hbCBzZWN0aW9uCiAgICAvL2ludGVycHJldGluZyB0aGUgY29kZSBmcm9tIHN5bnRheCB0cmVlCgogICAgKGZ1bmN0aW9uIF9pbnRlcnByZXRvcigpIHsKICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB0b2tlbnMubGVuZ3RoOyB4KyspIHsKICAgICAgICAvL1dlIHdpbGwgYmUgaGF2aW5nIGEgY29weSBvZiB0b2tlbnMgYXMgbXV0YWJsZV90b2tlbnMKICAgICAgICBpbnRlcnByZXRUb2tlbih0b2tlbnMsIHgsIG1lbW9yeSk7CgogICAgICAgIGlmIChza2lwSW50ZXJwcmV0YXRpb24gIT0gMCkgewogICAgICAgICAgeCA9IHggKyBza2lwSW50ZXJwcmV0YXRpb247CiAgICAgICAgfQogICAgICB9CiAgICB9KSgpOwoKICAgIHZhciBhc3NpZ25lZF92YXJpYWJsZXMgPSBhc3NpZ25lZF92YXJpYWJsZXMuZmlsdGVyKG9ubHlVbmlxdWUpOwogICAgdmFyIGRpZmZlcmVuY2UgPSB2YXJpYWJsZXNfYXJyYXkuZmlsdGVyKGZ1bmN0aW9uICh4KSB7CiAgICAgIHJldHVybiAhYXNzaWduZWRfdmFyaWFibGVzLmluY2x1ZGVzKHgpOwogICAgfSk7CgogICAgaWYgKGRpZmZlcmVuY2UubGVuZ3RoID4gMCkgewogICAgICBkaWZmZXJlbmNlLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7CiAgICAgICAga2FsYWFtLmVycm9yLnB1c2goIlZhcmlhYmxlICIuY29uY2F0KGVsLCAiIGlzIHVuZGVmaW5lZCIpKTsKICAgICAgfSk7CiAgICB9CgogICAga2FsYWFtLmxpbmVieWxpbmVPdXRwdXQgPSBrYWxhYW0uZXJyb3IubGVuZ3RoID4gMCA/IGthbGFhbS5lcnJvciA6IGthbGFhbS5vdXRwdXQuc3BsaXQoJ1xuJyk7IC8vdGltZSB0YWtlbiB0byB0cmFuc3BpbGUgdGhlIGNvZGUgaXMgdDEtdDAKCiAgICB2YXIgdDEgPSBwZXJmb3JtYW5jZS5ub3coKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZQoKICAgIGlmIChrYWxhYW0uZXJyb3IubGVuZ3RoID09PSAwKSB7CiAgICAgIHZhciBzID0gKHQxIC0gdDApLnRvUHJlY2lzaW9uKDQpOwogICAgICBrYWxhYW0uVGltZVRha2VuID0gIlx1MDkzOFx1MDkyQlx1MDkzMiB8IHNwZWVkIC0gIi5jb25jYXQocywgIiBtcyIpOwogICAgfSBlbHNlIHsKICAgICAga2FsYWFtLmlzRXJyb3IgPSB0cnVlOwogICAgICBrYWxhYW0uVGltZVRha2VuID0gJ0NvbXBpbGF0aW9uIEVycm9yOiBDaGVjayBmb3IgYXNzaWduZW1lbnQgYW5kIGRlY2xhcmF0aW9uIG1pc3R5cGluZyc7CiAgICB9IC8va2FsYWFtLmxpbmVieWxpbmVvdXRwdXQgaXMgd2hhdCB5b3Ugd2lsbCBmaW5hbGx5IHNlZSBvbiBvdXRwdXQgc2NyZWVuCgoKICAgIGthbGFhbS5saW5lYnlsaW5lT3V0cHV0ID0ga2FsYWFtLmxpbmVieWxpbmVPdXRwdXQuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7CiAgICAgIHJldHVybiBpdGVtICE9PSAnJzsKICAgIH0pOwogICAga2FsYWFtLkV4ZWN1dGlvblN0YWNrID0gRXhlY3V0aW9uU3RhY2s7CiAgICByZXR1cm4ga2FsYWFtOwogIH0gY2F0Y2ggKGUpIHsKICAgIGNvbnNvbGUubG9nKGUpOwogIH0KfQoKY29uc29sZS5sb2coJ0NvbXBpbGU6JywgQ29tcGlsZSk7CmV4cG9ydCB7IENvbXBpbGUsIEthbGFhbUtleXdvcmRzIH07"},{"version":3,"sources":["/Users/jonny/Desktop/myProjects/Kalaam-BE/Compiler/main.js"],"names":["TypeCheck","ActiveLangugaeKeywords","KalaamKeywords","console","log","AdvancedTypeCheck","BuildOperation","RemoveQuotes","RemoveBrackets","earlyCleaning","PushArray","PushCalculation","PushConditionalKeyword","PushCondition","PushForLoop","PushWhileLoop","PushForLoopAruguments","PushExpression","PushNativeOperation","PushKeyword","PushNumber","PushOperator","PushRealTimePrintOperation","PushString","PushVariable","PushVariableValue","PushFunctionData","PushFunctionExecution","PushToArray","PushInput","GetCleanSourcedata","GetcleanedExpression","AddElementToArray","ResetValue","CreateArrayElement","CalculateValues","GetArrayorStringElement","HandleBlocks","SplitElementsArray","SetValues","PushSetArrayIndexValue","PushGetArrayIndexValue","GetConditionValue","AcceptInputandSetValue","AssignorUpdateValues","HandleConditions","getLoopIndexStart","ForLoopSetMetadata","SetArrayIndexValue","AddtoExecutionStack","scanner","handleRealtimePrint","handleVariable","handleOutput","prepareFunction","findtokenPositioninCode","isInterpretableType","Compile","sourcecode","PrintEngine","Tokens","memory","j","iterator","OriginalIterator","StringVar","token","value","NextTokenValue","nextElement","VariableToPrint","forEach","el","name","assigned_variables","includes","kalaam","isNumber","push","isPureEval","outputpure","eval","type","toString","undefined","IndexInput","Value","ArrayElement","output","IndexToChange","element","replace","Split","split","join","find","Print","a","mode","x","isCalculation","message","expression","description","position","LinebylineSourcedata","ExecutionStack","_analyzeToken","cleaned_sourcedata","i","tokens","skipParsing","nextEl","prevEl","prevElement","token_type","handled_variable","h","e","length","charAt","ExpressiontoPrint","isRealTimePrintMultipleString","BuiltArray","BuildArray","splice","isWhileLoop","foundcondition","BuildCondition","isMultiCalculation","c","op","s","d","cal","count","multiCal","foundString","skip","BuildString","CheckFunctionExpression","passedValues","interpretToken","t","skipInterpretation","mutable_tokens","token_subtype","subtype","functionSourceData","SourceData","Function","ConditionValue","LastConditionValue","Returnvalue","If","getWhileLoopSourcedata","startIndex","StoreResult","ExtratcedVariable","variable","WhileLoopSourcedataIndexStart","WhileLoopSourcedataTokens","isVariable","While","index","getSourcedata","FlagPrimalLoop","SourcedataTokens","IterationStart","IterationEnd","ForLoopSourcedataIndexStart","Cycle","isNestedLoop","FindNestedLoop","NestedLoopindex","indexOf","NestedLooplength","EndIndex","Linenumber","For","forloopindex","functionName","functionToken","functionArguments","arguments","val","FindInUpdatedTokens","functionContextmemory","identifier","context","IntheEndSetValueto","CompleteTokenValueList","onlyUnique","arr","t0","performance","now","sourcedata","mixedimpurity","variables_array","isError","linebylineOutput","error","OperationObjects","_parser","_interpretor","filter","difference","t1","toPrecision","TimeTaken","item"],"mappings":"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","sourcesContent":["/*!\n * Kalaam v1.0.0\n * (C) 2020-21 Swanand Kadam\n * Released under the MIT License.\n */\n\n//SECTION - Importing function modules\n\n//To check variable types: Number, String, Array etc.\nimport * as TypeCheck from '../TypeCheck/TypeChecking';\n\nimport { ActiveLangugaeKeywords, KalaamKeywords } from '../Compiler/constants';\nconsole.log('ActiveLangugaeKeywords:', ActiveLangugaeKeywords);\n\n//To check other operations like MultiString, Arithmetic Operation etc.\nimport * as AdvancedTypeCheck from '../TypeCheck/AdvancedTypeChecking';\n\n//To format user input into a proper String, Array or Condition.\nimport * as BuildOperation from '../Scripts/BuildOperations';\n\nimport { RemoveQuotes, RemoveBrackets, earlyCleaning } from '../Scripts/Helpers';\n\n//Functions imported to push a particular data to our Tokens array.\n//Tokens array is basically a clean, formatted and a word by word version of raw code provided by user\nimport { PushArray, PushCalculation, PushConditionalKeyword, PushCondition, PushForLoop, PushWhileLoop, PushForLoopAruguments, PushExpression, PushNativeOperation, PushKeyword, PushNumber, PushOperator, PushRealTimePrintOperation, PushString, PushVariable, PushVariableValue, PushFunctionData, PushFunctionExecution, PushToArray, PushInput } from '../PushTokens/main';\n\n//This are other helper functions that we need for a particular task. All of this functions will be explained indepth as we see them in codebase.\nimport {\n  GetCleanSourcedata,\n  GetcleanedExpression,\n  AddElementToArray,\n  ResetValue,\n  CreateArrayElement,\n  CalculateValues,\n  GetArrayorStringElement,\n  HandleBlocks,\n  SplitElementsArray,\n  SetValues,\n  PushSetArrayIndexValue,\n  PushGetArrayIndexValue,\n  GetConditionValue,\n  AcceptInputandSetValue,\n  AssignorUpdateValues,\n  HandleConditions,\n  getLoopIndexStart,\n  ForLoopSetMetadata,\n  SetArrayIndexValue,\n  AddtoExecutionStack,\n} from '../Scripts/main.js';\n\nimport scanner from '../scanner/main';\n\nimport '../HelperLibrary/main';\nimport { handleRealtimePrint, handleVariable, handleOutput, prepareFunction } from '../Scripts/Handlers';\nimport { findtokenPositioninCode } from '../Scripts/finders';\nimport { isInterpretableType } from '../Scripts/testers';\n//We will be importing this whole function to practise.vue and it will be executed when user clicks on 'RUN'\n\nfunction Compile(sourcecode) {\n  try {\n    //t0 along with t1 takes record of Time taken to run the code. t1-t0 gives us the exact time taken.\n    var t0 = performance.now(); // eslint-disable-line\n\n    //Sourcedata is the raw code provided by user\n    const sourcedata = sourcecode;\n\n    var LinebylineSourcedata = sourcedata.replace(/(?:\\r\\n|\\r|\\n)/g, 'breakpoint').split('breakpoint');\n\n    //This is where formatted and cleaned sourcedata will go.\n    var cleaned_sourcedata = [];\n    var ExecutionStack = [];\n    var i = 0;\n    //This is where tokens will be pushed depending upon their types like Variable, function, loops etc.\n    var tokens = [];\n\n    //Experimental\n    var mixedimpurity = [];\n\n    //The variables with their calculated values are pushed here. If c=a+b, memory is where you will find the calculated value\n    var memory = [];\n\n    //Variable-value pairs similar to memory but limits itself to a user created function.\n    var functionContextmemory = [];\n\n    var variables_array = [];\n\n    //Pushing the variables that are assigned to filter out defined and undefined variables. Useful in error handling\n    var assigned_variables = [];\n\n    //TO REMOVE DUPLICATE VARIABLES,\n\n    // var variableArray = [];\n    //A temporary instance of a global variable. Used because of scoping issue, there are better soultions and we will do that.\n\n    //emptying accumulated value\n    //See AssignorUpdateValues function for more\n\n    var skipParsing = 0;\n    var skipInterpretation = 0;\n\n    ResetValue();\n    var kalaam = {};\n    //If an error is encountered we set the value to true and push the error to errors array.\n    kalaam.isError = false;\n\n    sourcecode = earlyCleaning(sourcecode);\n\n    kalaam.output = '';\n    kalaam.LastConditionValue = [];\n    kalaam.ExecutionStack = [];\n\n    kalaam.linebylineOutput = kalaam.output.split('\\n');\n    kalaam.error = [];\n    kalaam.OperationObjects = [];\n\n    //SECTION - Checking for type of characters. TypeCheck is an object which consists all self functions. Check Line 102\n\n    const isVariable = TypeCheck.isVariable();\n\n    const isNumber = TypeCheck.isNumber();\n\n    const isWhileLoop = TypeCheck.isWhileLoop();\n\n    const isPureEval = AdvancedTypeCheck.isPureEval();\n\n    //if _tokensr encounters anything like (\" or (, then that's a realtime print.\n\n    //buildstring will be applied now to create a string and push it into tokens. Buildstring is used to combine string tokens like\n    //['hello', 'Kalaam', 'developers', \"!\"] into 'hello kalaam developers!'.\n\n    //It's because cleaned_sourcedata is an array of tokens and each token is an individual word in a program.\n\n    //It's recommended to look at cleaned_sourcedata of every program to understand how it converts plain text into array of individual words.\n\n    const isRealTimePrintMultipleString = AdvancedTypeCheck.isRealTimePrintMultipleString();\n\n    //const isStringandValue = AdvancedTypeCheck.isStringandValue()\n\n    const isCalculation = AdvancedTypeCheck.isCalculation();\n\n    // const isDirectPrintArithmetic = AdvancedTypeCheck.isDirectPrintArithmetic()\n\n    //SECTION - Build Operations\n\n    //To convert ['hello', 'Kalaam', 'developers', \"!\"] into 'hello kalaam developers!'.\n\n    const BuildString = BuildOperation.BuildString();\n\n    //To convert ['[', 'x','y','z',']'] into ['x','y','z']\n\n    const BuildArray = BuildOperation.BuildArray();\n\n    //self function is the first step to handlle operations like  (ageone===10 && AverageAge<1000 && agetwo>100 || ageone===10) OR (ageone===10 )\n\n    const BuildCondition = BuildOperation.BuildCondition();\n\n    //This will run for every () statement encountered in the program, not just for loops\n\n    //ARGUMENTS TO PrintEngine are:\n    //Tokens- Tokens array\n    //memory- Variable-value pairs of variables\n    //j- Index of a token in Tokens array\n    //global- self or self\n    //iterator and OriginalIterator are used to print values in for and while loops.\n\n    function PrintEngine(Tokens, memory, j, iterator, OriginalIterator) {\n      //To understand what kind of data is necessary to print a value\n\n      //Getting the current token as token and value to be printed as NextTokenValue\n      //e.g. For (Name), Name is the NextTokenValue and it is the one which we will have to print\n\n      var StringVar = [];\n\n      var token = Tokens[j].value;\n\n      var NextTokenValue = Tokens.nextElement(j).value;\n      //Removing the brackets, if any.\n      var VariableToPrint = RemoveBrackets(NextTokenValue);\n\n      //SECTION - Outputting the code\n      // finding the variable value in memory. memory is where our Variable-value pairs exists.\n\n      //This loop is only for printing direct values like print(name), print(array)\n\n      memory.forEach((el) => {\n        //If we have a variable-value pair sitting in memory\n\n        if (el.name === VariableToPrint) {\n          //for calculations like x=ageone+agetwo\n\n          //If we have already calculated value in assigned_variables, use that or else move forward\n\n          if (assigned_variables.includes(el) || assigned_variables.includes(el.name)) {\n            handleOutput(el.value, kalaam);\n          } else {\n            //if the value found is a Number\n\n            if (isNumber(el.value)) {\n              handleOutput(el.value, kalaam);\n\n              assigned_variables.push(el.name);\n            }\n\n            //if the value found is operations like age=2020-1996\n            else if (isPureEval(el.value)) {\n              //we are using Javascript's eval function to calculate direct arithmetic operations\n              let outputpure = eval(el.value);\n\n              el.value = outputpure;\n\n              handleOutput(el.value, kalaam);\n\n              assigned_variables.push(el.name);\n            }\n\n            //We will simplify this conditions as we move forward\n            else if (!isPureEval(el.value) && !isNumber(el.value)) {\n              if (!(el.name.includes(']') && el.name.includes('['))) {\n                if (el.type === 'Array') {\n                  if (!el.value.includes('[')) {\n                    el.value = '[' + el.value.toString() + ']';\n                  }\n                }\n\n                handleOutput(el.value, kalaam);\n\n                assigned_variables.push(el.name);\n              }\n            }\n          }\n        }\n      });\n\n      //This is how we print Array in Kalaam\n      if (Tokens[j + 1].type === 'Array') {\n        //To run only if iterator is present\n\n        //This runs on for loop - (Array[a]) etc\n\n        //self runs only if for(i) and in the loop, array[i], not on array[x]. For loop Iterator and index should be same, in self case 'i'\n\n        if (iterator != undefined && Tokens[j + 1].IndexInput === OriginalIterator) {\n          let Value = NextTokenValue;\n\n          let ArrayElement = CreateArrayElement(Value, iterator);\n\n          let output = GetArrayorStringElement(ArrayElement, memory);\n\n          output = RemoveQuotes(output);\n\n          handleOutput(output, kalaam);\n\n          assigned_variables.push(Tokens[j + 1]);\n        }\n\n        //This runs to Print(Array[2]) like specific array values\n        else if (Tokens[j + 1].IndexInput != OriginalIterator) {\n          let Value = NextTokenValue;\n\n          let IndexToChange = Tokens[j + 1].IndexInput;\n\n          let ArrayElement = CreateArrayElement(Value, IndexToChange);\n\n          let element = ArrayElement.replace(']', '');\n\n          let Split = element.split('[');\n\n          if (Split[1].includes('-') || Split[1].includes('+')) {\n            let output = CalculateValues(Split[1], j, memory);\n\n            Split[1] = output;\n\n            Split = Split.join('[') + ']';\n            ArrayElement = Split;\n          }\n\n          let token = memory.find((el) => el.name === Split[1]);\n\n          if (token != undefined && OriginalIterator != Split[1]) {\n            Split[1] = token.value;\n\n            Split = Split.join('[') + ']';\n            ArrayElement = Split;\n          } else {\n            ArrayElement = ArrayElement;\n            ////\n          }\n\n          let output = GetArrayorStringElement(ArrayElement, memory);\n\n          handleOutput(output, kalaam);\n        }\n      }\n\n      //printing direct numbers and direct calcultions like print(10), print(10*10)\n      else if (token === ActiveLangugaeKeywords.Print && (isPureEval(RemoveBrackets(NextTokenValue)) || isNumber(RemoveBrackets(NextTokenValue)))) {\n        NextTokenValue = RemoveBrackets(NextTokenValue);\n\n        if (isNumber(NextTokenValue) && Tokens[j + 1].type != 'Calculation') {\n          handleOutput(NextTokenValue, kalaam);\n        } else {\n          let a = eval(NextTokenValue);\n\n          handleOutput(a, kalaam);\n        }\n      }\n\n      //foroperations like print('you live, you learn')\n      else if (Tokens[j + 1].mode === 'RealTimePrint' && !NextTokenValue.includes('+') /*&& !NextTokenValue.includes('=')*/) {\n        let output = RemoveBrackets(NextTokenValue);\n\n        output = RemoveQuotes(output);\n\n        handleOutput(output + '\\n', kalaam);\n      }\n\n      //operations like print(Age + 'is young age') i.e string concatenations\n      else if (Tokens[j + 1].mode === 'RealTimePrint' && NextTokenValue.includes('+')) {\n        let x = SplitElementsArray(NextTokenValue);\n\n        x = x.join('').split('+');\n\n        StringVar = SetValues(x, memory);\n\n        let output = StringVar.join(' ');\n\n        output = RemoveBrackets(output);\n        output = RemoveQuotes(output);\n\n        handleOutput(output + '\\n', kalaam);\n      } else if (isCalculation(RemoveBrackets(NextTokenValue)) && Tokens[j + 1].mode != 'RealTimePrint') {\n        NextTokenValue = RemoveBrackets(NextTokenValue);\n\n        let output = CalculateValues(NextTokenValue, j, memory);\n\n        handleOutput(output + '\\n', kalaam);\n      }\n\n      let message = ' Computer     , ' + '\"' + RemoveBrackets(NextTokenValue) + '\"' + '    |';\n\n      //This is the experession whcih is getting evaluated.\n\n      let expression = token + NextTokenValue;\n      let description = ' VALUE  OUTPUT SCREEN     ()    ';\n\n      expression = GetcleanedExpression(expression);\n\n      let position = findtokenPositioninCode(LinebylineSourcedata, expression, true);\n      if (position != undefined) {\n        AddtoExecutionStack(ExecutionStack, ActiveLangugaeKeywords.Print, description, VariableToPrint, null, message, position);\n      }\n    }\n\n    //END OF Functions and Imported Functions\n\n    //Out of all self function, PrintEngine is very important function. It prints variable values by searching their value in memory.\n\n    //SECTION - Checking each token and adding to tokens array\n\n    //_tokens takes two arguments. The cleaned_sourcedata array and current index of cleaned_sourcedata array\n\n    //_tokens is used to create a tokens array with each token having it's name, value, type and other metadata\n\n    //It performs operations depending upon whether the element is variable, array, function, loop etc.\n\n    //scanning every single element from cleaned_sourcedata array and pushing it to Tokens depending upon the type pf element\n\n    function _analyzeToken(cleaned_sourcedata, i, tokens) {\n      let element = cleaned_sourcedata[i];\n\n      skipParsing = 0;\n\n      let nextEl = cleaned_sourcedata.nextElement(i);\n      let prevEl = cleaned_sourcedata.prevElement(i);\n\n      let token_type = scanner(cleaned_sourcedata, i, tokens);\n      console.log('token_type:', token_type);\n      //Push variables to tokens\n      //Format: {type: \"variable\", value: \"ReverseString\"}\n\n      //whenever we need a certain handling, handlers.js is used\n      switch (token_type) {\n        case 'VARIABLE':\n          //Here we seperate Message = 'Hello' into following three tokens :\n\n          //1:{type:\"variable\",value:\"Message\"}\n\n          //2:{type:\"operator\",value:\"=\"}\n\n          //3:{type:\"value\",value:\"Hello\"}\n\n          let handled_variable = handleVariable(element, tokens, cleaned_sourcedata, i, nextEl, prevEl);\n          let h = handled_variable;\n          if (h != undefined) {\n            try {\n              h.type === 'variable' ? PushVariable(h, tokens) : console.log(`error in setting ${element}`);\n            } catch (e) {\n              console.log(e, `error in setting ${element}`);\n            }\n          }\n          break;\n        //Push variables to tokens\n        case 'NUMBER':\n          PushNumber(element, tokens);\n          break;\n\n        //Push EmptyStrings to tokens\n        case 'EMPTY_STRING':\n          //In some cases empty strings will be modified into something like \"'\" or '\"'\n          //We convert it back to \" \"\n          try {\n            let e = element;\n            e = e.length > 1 && (e.charAt(0) === \"'\" || e.charAt(0) === '\"') ? (e = e.replace(/['\"]+/g, '')) : (e = ' ');\n\n            PushVariableValue(e, tokens);\n          } catch (e) {\n            console.log(e, `Error in setting Empty string ${element}`);\n          }\n          break;\n\n        //Push Input to tokens\n        //Format: {type:\"AcceptInput\",value:\" \",AcceptAs:\"Message\"}\n        case 'INPUT':\n          try {\n            PushInput(element, tokens, cleaned_sourcedata, i);\n          } catch (e) {\n            console.log(e, `Error in setting Input ${element}`);\n          }\n          break;\n        //Push operators to tokens. The accepted operators are =,},{\n        //Format:{type:\"operator\",value:\"=\"}\n        case 'OPERATOR':\n          try {\n            PushOperator(element, tokens);\n          } catch (e) {\n            console.log(e, `Error in setting operator ${element}`);\n          }\n          break;\n\n        //Push keyowrds to tokens. The accepted keywords is \n\n        //Format: {type:\"keyword\",value:ActiveLangugaeKeywords.Print}\n        case 'PRINT':\n          try {\n            PushKeyword(element, tokens);\n\n            let ExpressiontoPrint = nextEl;\n            console.log('ExpressiontoPrint:', ExpressiontoPrint);\n\n            if (!isRealTimePrintMultipleString(ExpressiontoPrint)) {\n              PushExpression(ExpressiontoPrint, tokens);\n            }\n          } catch (e) {\n            console.log(e, `Error in printing ${element}`);\n          }\n          break;\n        //Push functions to tokens\n        //Format: {type: \"function\", value: \"First\", arguments: Array(2), FunctionInvocationExists: false, FunctionStack: Array(0), }\n        case 'FUNCTION':\n          try {\n            PushFunctionData(element, tokens, cleaned_sourcedata, i);\n          } catch (e) {\n            console.log(e, `Error in handling function ${element}`);\n          }\n          break;\n\n        // Push array to tokens\n\n        case 'ARRAY':\n          //Format: {type: \"Array\", value: \"[]\"}\n          //if empty array else build the array (To convert '[',1,2,3,4,']'  into [1,2,3,4]\n          try {\n            let e = element;\n            e.charAt(e.length - 1) === ']'\n              ? PushArray(e, tokens)\n              : function () {\n                let BuiltArray = BuildArray(e, i, cleaned_sourcedata);\n\n                PushArray(BuiltArray, tokens);\n              };\n          } catch (e) {\n            console.log(e, `Error in handling Array ${element}`);\n          }\n\n          break;\n\n        //For operations like Numbers[a]=a\n        //Format: {type:\"SetArrayIndexValue\",value:\"Fibonacci[a]\",ValueToSet:\"a\"}\n        case 'SET_ARRAY_INDEX':\n          try {\n            PushSetArrayIndexValue(element, tokens, cleaned_sourcedata, i);\n\n            cleaned_sourcedata.splice(i + 1, 1);\n          } catch (e) {\n            console.log(e, `Error in setting array index value ${element}`);\n          }\n\n          break;\n\n        //For operations like a=Numbers[a], reverse of above\n        //Format: {type:\"GetArrayIndexValue\",value:\"Fibonacci[a-2]\"}\n        case 'GET_ARRAY_INDEX':\n          try {\n            PushGetArrayIndexValue(element, tokens, cleaned_sourcedata, i);\n          } catch (e) {\n            console.log(e, `Error in getting array index value ${element}`);\n          }\n          break;\n\n        //Push conditions to tokens. The accepted keywords are , , \n        // Format: {type:\"conditionalkeyword\",value:\"\"}\n        //Push while loops to tokens\n        //Format: {type: \"WhileLoopStart\", value: \"\"}, {type: \"condition\", value: \"count<25\"}\n\n        case 'CONDITIONAL_KEYWORD':\n          try {\n            isWhileLoop(element) ? PushWhileLoop(element, tokens) : PushConditionalKeyword(element, tokens);\n\n            //This is how we push conditions encountered in the sourcecode\n            //Format:{type:\"condition\",value:\"a<3\"}\n            let foundcondition = BuildCondition(element, i, cleaned_sourcedata);\n\n            //Push conditions to tokens array\n\n            if (foundcondition != '') {\n              PushCondition(foundcondition, tokens);\n            }\n          } catch (e) {\n            console.log(e, `Error in operating on conditionals ${element}`);\n          }\n\n          break;\n\n        //Finding operations like Numbers.(x)\n        //Format: {type: \"PushToArray\", value: \"Numbers.(x)\"}\n        case 'PUSH_TO_ARRAY':\n          try {\n            PushToArray(element, tokens);\n          } catch (e) {\n            console.log(e, `Error in pushing the values to array ${element}`);\n          }\n          break;\n\n        //Push For loop to tokens\n        // Format:\n        // {type:\"ForLoopStart\",value:\"\"}\n        //{type:\"ForLoopArguments\",iterator:\"a\",value:\"(0,25)\",iterationStart:\"0\",iterationEnd:\"25\"}\n        case 'FOR_LOOP':\n          try {\n            PushForLoop(element, tokens);\n            PushForLoopAruguments(element, cleaned_sourcedata, i, tokens);\n\n            memory.push({\n              name: nextEl,\n              value: 0,\n              type: 'ForLoopIterator',\n            });\n          } catch (e) {\n            console.log(e, `Error in operating on for loop ${element}`);\n          }\n          break;\n\n        //Pushing basic Calculations like 'length-1' to tokens\n        //Format: {type:\"Calculation\",value:\"length-1\"}\n        case 'CALCULATION':\n          /* red zone\n  \n          if (nextEl != undefined) {\n            // this is to perform long calculations like AverageAge=(ageone+agetwo)/2 + (ageone+agetwo)*2\n  \n            while (isCalculation(cleaned_sourcedata[i])) {\n              el = el + cleaned_sourcedata[i];\n  \n              i++;\n            }\n          }\n  \n          console.log(\"el:\", el);\n  */\n          /*error prone*/\n\n          try {\n            let el = element;\n            let cal = '';\n            let count = 0;\n            //   function findCalculation(cleaned_sourcedata, i) {\n            let x = i;\n            let d = 0;\n\n            while (isCalculation(cleaned_sourcedata[x]) || cleaned_sourcedata[x] == '+') {\n              cal = cal + cleaned_sourcedata[x];\n              count += 1;\n              x++;\n            }\n\n            function isMultiCalculation(c, op = '*+/-') {\n              if (c.includes('(') && c.includes(')')) {\n                let s = c.split('');\n                s.forEach((el) => {\n                  if (op.includes(el)) {\n                    d = d + 1;\n                  }\n                });\n\n                if (d > 1) {\n                  return true;\n                } else {\n                  return false;\n                }\n              }\n            }\n\n            let multiCal = isMultiCalculation(cal);\n\n            //  console.log(\"x\", x, i);\n            skipParsing = count - 1;\n            // cal = RemoveBrackets(cal);\n\n            //let c_el = RemoveBrackets(cal);\n\n            //  let cal = findCalculation();\n\n            // to stop prevention of expressions like is\"+ getting added as a calculation\n            !cal.includes('\"') && !['/', '*', \"'\", '\"'].includes(el.charAt(0)) ? PushCalculation(cal, tokens, cleaned_sourcedata, i, multiCal) : console.log(`impure calculation terms ${el}`);\n          } catch (e) {\n            console.log(e, `Error in completing calculation ${element}`);\n          }\n          break;\n\n        case 'REALTIME_PRINT':\n          //finding operations like print(x + 'y'). The RealTimePrint operations\n\n          //Format: {type:\"value\",value:\"('Reversed String-'+ ReverseString)\",mode:\"RealTimePrint\"}\n          try {\n            let { foundString, skip } = handleRealtimePrint(cleaned_sourcedata, i);\n\n            PushRealTimePrintOperation(foundString, tokens);\n\n            skipParsing = skip;\n          } catch (e) {\n            console.log(e, `Error in real time print ${element}`);\n          }\n\n          break;\n\n        case 'STRING':\n          //storing only the string values to tokens ( not the strings in print statements)\n          try {\n            let s = BuildString(element, i, cleaned_sourcedata);\n\n            s = s.replace(/['\"]+/g, '');\n\n            !s.includes(ActiveLangugaeKeywords.Print) ? PushString(s, tokens) : console.log(`error in pushing string ${(s, element)}`);\n          } catch (e) {\n            console.log(e, `error in operating on string ${element}`);\n          }\n          break;\n\n        //An extension of isPrintOperation() function\n        // Needs improvement\n\n        /*     else if (/^(?=.*?)(?=.*[a-z])/.test(element)) {\n                \n    \n                PushKeyword(element.slice(0, 6), tokens); //Pushing print keyword only\n    \n                PushExpression(element.slice(6), tokens); //Pushing remaining expression like (a), (Message) etc\n            }\n            */\n\n        //error prone change made here- Pushing expression in here\n        //Used to push functions and expressions\n        //Unnecessary data is being passed through kalaam.\n        //This was created for a temporary fix\n        case 'FUNCTION_CALL':\n          try {\n            let CheckFunctionExpression = element.split('(');\n\n            let passedValues = RemoveBrackets(CheckFunctionExpression[1]);\n            passedValues = passedValues.split(',');\n\n            PushFunctionExecution(element, tokens, cleaned_sourcedata, i, passedValues);\n          } catch (e) {\n            console.log(e, `error in pushing function execution ${element}`);\n          }\n          break;\n\n        case 'NATIVE_OPERATION':\n          try {\n            PushNativeOperation(element, tokens);\n          } catch (e) {\n            console.log(e, `error in pushing native operaion ${element}`);\n          }\n          break;\n\n        case 'ARRAY_PUSH':\n          try {\n            PushArray(element, tokens);\n          } catch (e) {\n            console.log(e, `error in array push ${element}`);\n          }\n          break;\n      }\n    }\n\n    //making sense of tokens array coming from _parser.\n    function interpretToken(t, j, memory) {\n      skipInterpretation = 0;\n      let mutable_tokens = t;\n\n      let token = mutable_tokens[j].value;\n\n      let token_type = mutable_tokens[j].type;\n      let token_subtype = mutable_tokens[j].subtype;\n\n      let type = token === ActiveLangugaeKeywords.Print || token_type === 'operator' ? token_subtype : token_type;\n      //need to skip over some unncessary types\n\n      //operators are not working correctly\n      // no need to interpret over non-types\n      try {\n        if (isInterpretableType(type)) {\n          switch (type) {\n            case 'SetArrayIndexValue':\n              {\n                SetArrayIndexValue(mutable_tokens, j, j, memory, tokens, OriginalIterator, iterator, ExecutionStack, LinebylineSourcedata);\n              }\n              break;\n\n            case 'assignment': {\n              AssignorUpdateValues(mutable_tokens, j, memory, iterator, OriginalIterator, kalaam, ExecutionStack, LinebylineSourcedata); // eslint-disable-line\n\n              break;\n            }\n            //type=assignment\n\n            case 'PushToArray':\n              {\n                AddElementToArray(mutable_tokens, j, memory, ExecutionStack, LinebylineSourcedata);\n              }\n              break;\n            case 'AcceptInput':\n              {\n                AcceptInputandSetValue(mutable_tokens, j, memory, ExecutionStack, LinebylineSourcedata);\n              }\n              break;\n\n            //Whenever we encounter a function, we create a seperate execution context\n            case 'function':\n              {\n                //We are preparing the required data to execute a function call later in the prgroam\n\n                //functionsourcedata includes all the tokens from tokens array which belongs to a particular function\n                skipInterpretation = 0;\n                //We find self range or a function block through HandleBlocks function\n                let { functionSourceData } = prepareFunction(mutable_tokens, j);\n\n                mutable_tokens[j].SourceData = functionSourceData;\n\n                let message = ` ${ActiveLangugaeKeywords.Function}   ${token}        NEW VALUES      |`;\n\n                let expression = `${ActiveLangugaeKeywords.Function} ${token}`;\n                let description = '                | ';\n\n                let position = findtokenPositioninCode(LinebylineSourcedata, expression, true);\n                if (position != undefined) {\n                  AddtoExecutionStack(ExecutionStack, ActiveLangugaeKeywords.Function, description, mutable_tokens[j].value, functionSourceData, message, position);\n                }\n                skipInterpretation = functionSourceData.length;\n              }\n              break;\n            //We are out of the fucntion execution context and back to global execution context\n            case 'condition':\n              {\n                let element = token;\n\n                var message;\n\n                //this function is the first step to calculate value of operations like  (ageone===10 && AverageAge<1000 && agetwo>100 || ageone===10) OR (ageone===10 )\n\n                let ConditionValue = GetConditionValue(element, memory, j);\n\n                kalaam.LastConditionValue.push(ConditionValue);\n\n                //if value is false, just skip the if loop context, if not it will be ran in final print module\n\n                if (!ConditionValue) {\n                  //  let InitializeLoop = tokens.indexOf(mutable_tokens[j]);\n\n                  //Handle Blocks is a function which takes care of nested block by taking care of nested { and } brackets\n                  //it uses the stack to push and pop brackets to accurately identify start and the end of the block\n                  let Returnvalue = HandleBlocks(mutable_tokens, j);\n\n                  //amount to skip if condition is false\n                  skipInterpretation = Returnvalue.j - j;\n\n                  message = `  ${element}  , FALSE()    COMPUTER        `;\n                } else {\n                  message = ` ${element}  , TRUE()    COMPUTER       `;\n                }\n\n                let expression = element;\n                let description = ' Certain Condition    Execution  Allow   ';\n\n                expression = GetcleanedExpression(expression);\n\n                let position = findtokenPositioninCode(LinebylineSourcedata, expression, true);\n                if (position != undefined) {\n                  AddtoExecutionStack(ExecutionStack, ActiveLangugaeKeywords.If, description, element, ConditionValue, message, position);\n                }\n              }\n\n              break;\n            //So that we don't print a same value twice. First in global execution context and the in function context\n\n            //This one prints the global context values\n            case 'print':\n              {\n                console.log('hrloo');\n                PrintEngine(mutable_tokens, memory, j); // eslint-disable-line\n              }\n              break;\n\n            //This runs our while loop .i.e \n            case 'WhileLoopStart':\n              {\n                skipInterpretation = 0;\n                let element = mutable_tokens[j + 1].value;\n\n                let ExtratcedVariable = [];\n\n                let variable = '';\n                let WhileLoopSourcedataIndexStart = 0;\n                let WhileLoopSourcedataTokens = [];\n\n                for (let i = 0; i < element.length; i++) {\n                  let x = element.charAt(i);\n\n                  if (isVariable(x)) {\n                    variable = variable + x;\n                  }\n                  if (!isVariable(element.charAt(i + 1)) && isVariable(x)) {\n                    let token = memory.find((el) => el.name === variable);\n\n                    ExtratcedVariable.push({\n                      variable: variable,\n                      value: token.value,\n                    });\n\n                    variable = '';\n                  }\n                }\n\n                function getWhileLoopSourcedata(startIndex, mutable_tokens, StoreResult) {\n                  StoreResult = HandleBlocks(mutable_tokens, startIndex, StoreResult);\n\n                  return StoreResult;\n                }\n\n                WhileLoopSourcedataIndexStart = getLoopIndexStart(mutable_tokens, j, '{', WhileLoopSourcedataIndexStart);\n\n                WhileLoopSourcedataTokens = getWhileLoopSourcedata(WhileLoopSourcedataIndexStart, mutable_tokens, WhileLoopSourcedataTokens).StoreResult;\n\n                let message = ' ' + element + '           ';\n\n                let description = '    (Condition)           |';\n\n                let expression = GetcleanedExpression(element);\n\n                let position = findtokenPositioninCode(LinebylineSourcedata, expression, true);\n                if (position != undefined) {\n                  AddtoExecutionStack(ExecutionStack, ActiveLangugaeKeywords.While, description, element, WhileLoopSourcedataTokens, message, position);\n                }\n\n                //constantly accessing the conditionvalue\n\n                while (GetConditionValue(element, memory, j + 1)) {\n                  for (let i = 0; i < WhileLoopSourcedataTokens.length; i++) {\n                    //SECTION while loop context\n\n                    if (WhileLoopSourcedataTokens[i].value === '=') {\n                      AssignorUpdateValues(WhileLoopSourcedataTokens, i, memory, '', '', '', ExecutionStack, LinebylineSourcedata);\n                    } else if (WhileLoopSourcedataTokens[i].type === 'AcceptInput') {\n                      AcceptInputandSetValue(WhileLoopSourcedataTokens, i, memory, ExecutionStack);\n                    }\n\n                    // Handling CONDITIONAL statements in While loop\n                    else if (WhileLoopSourcedataTokens[i].type === 'condition') {\n                      //if index returns a value, it means condition is false and skip the execution\n\n                      let index = HandleConditions(WhileLoopSourcedataTokens, i, memory);\n\n                      if (index != undefined) {\n                        i = index;\n                      } else {\n                        i = i;\n                      }\n                    }\n\n                    //Handling  statements in while loop\n                    else if (WhileLoopSourcedataTokens[i].value === ActiveLangugaeKeywords.Print) {\n                      PrintEngine(WhileLoopSourcedataTokens, memory, i, ExecutionStack); // eslint-disable-line\n                    }\n\n                    //operations like Numbers[a]='xyz'\n                    else if (WhileLoopSourcedataTokens[i].type === 'SetArrayIndexValue') {\n                      SetArrayIndexValue(WhileLoopSourcedataTokens, i, j, memory, tokens, OriginalIterator, iterator, ExecutionStack, LinebylineSourcedata);\n                    }\n                  }\n                }\n                skipInterpretation = WhileLoopSourcedataTokens.length;\n\n                //End of While loop execution\n\n                //Handling For loops\n              }\n              break;\n\n            case 'ForLoopStart':\n              {\n                var FlagPrimalLoop = 0; // eslint-disable-line\n\n                var SourcedataTokens = [];\n\n                var { OriginalIterator, IterationStart, IterationEnd, iterator, element, ForLoopSourcedataIndexStart, Cycle } = ForLoopSetMetadata(mutable_tokens, j, memory);\n\n                function getSourcedata(startIndex, mutable_tokens, StoreResult) {\n                  let Returnvalue = HandleBlocks(mutable_tokens, startIndex, StoreResult);\n                  StoreResult = Returnvalue.StoreResult;\n\n                  return StoreResult;\n                }\n\n                ForLoopSourcedataIndexStart = getLoopIndexStart(mutable_tokens, j, '{', ForLoopSourcedataIndexStart);\n\n                SourcedataTokens = getSourcedata(ForLoopSourcedataIndexStart, mutable_tokens, SourcedataTokens);\n\n                SourcedataTokens.forEach((el) => {\n                  el.isNestedLoop = false;\n                });\n\n                //Checking if the for loop has one more for loop inside it\n                let FindNestedLoop = SourcedataTokens.find((el) => el.type === 'ForLoopStart');\n\n                if (FindNestedLoop != undefined) {\n                  let NestedLoopindex = SourcedataTokens.indexOf(FindNestedLoop) + 3;\n                  let NestedLooplength = SourcedataTokens[NestedLoopindex].EndIndex - SourcedataTokens[NestedLoopindex].startIndex + 2;\n\n                  //if we have a nested loop, set isNesteLoop to TRUE\n\n                  for (let x = NestedLoopindex; x < NestedLoopindex + NestedLooplength; x++) {\n                    SourcedataTokens[x].isNestedLoop = true;\n                  }\n                }\n\n                if (element.includes('(') && element.includes(',')) {\n                  FlagPrimalLoop = 1;\n                }\n\n                //Iterating over forloop sourcedata\n                //self line 'iterator <= Cycle' determines start of the loop and the duration of the loop\n\n                let message = '       ' + IterationStart + '  ' + IterationEnd + ' ,  ' + eval(IterationEnd - IterationStart + 1) + '  RUN()   |' + '\\n' + '  Computer, ' + '\"' + iterator + '\"' + '  Memory , ' + IterationStart + '  ' + IterationEnd + '  (Values)   |';\n\n                //This is the experession whcih is getting evaluated.\n                let expression = ' ' + iterator + '  ' + mutable_tokens[j + 1].value + ' ';\n                let description = '    -  ';\n                let Linenumber = LinebylineSourcedata.indexOf(expression);\n                Linenumber += 1;\n\n                AddtoExecutionStack(ExecutionStack, ActiveLangugaeKeywords.For, description, SourcedataTokens, '', message, Linenumber);\n\n                for (iterator = IterationStart; iterator <= Cycle; iterator++) {\n                  let forloopindex = memory.find((el) => el.name === OriginalIterator);\n\n                  forloopindex.value = iterator;\n\n                  //flag to avoid running this code if loop is primal because the payload needs to be compeltely different\n                  if (FlagPrimalLoop === 0) {\n                    // ForLoopArrayorStringOutput(elementValue, iterator, memory, self); // eslint-disable-line\n                  }\n\n                  for (let i = 0; i < SourcedataTokens.length; i++) {\n                    // let isNested = SourcedataTokens[i].isNestedLoop;\n\n                    //This code runs only if we have a nested loop situation\n                    skipInterpretation = 0;\n                    try {\n                      interpretToken(SourcedataTokens, i, memory);\n                    } catch (e) {\n                      console.log(e, `error in interpreting for loop ${SourcedataTokens[i]}`);\n                    }\n                    if (skipInterpretation != 0) {\n                      i = i + skipInterpretation;\n                    }\n                  }\n                }\n\n                skipInterpretation = skipInterpretation + SourcedataTokens.length;\n              }\n\n              break;\n            //END FOR LOOP EXECUTION\n            case 'functionExecution': {\n              //checking if function is invoked somewhere later in the program\n\n              //If we see a function execution call, for e.g Add(x,y), we prepare for execution\n\n              let functionSourceData = [];\n              let functionName = token;\n\n              let passedValues = mutable_tokens[j].passedValues;\n\n              let functionToken = mutable_tokens.find((el) => el.value === functionName);\n\n              let functionArguments = functionToken.arguments;\n\n              functionSourceData = functionToken.SourceData;\n\n              //Creating a seperate execution context and setting fucntion context name:value pair in functionContextmemory\n\n              //for e.g x=3, y=4 is already defined and then we execute add(x,y)\n\n              // This is an memory form limited to function context\n\n              //Operating on function arguments and setting their values. For e.g the function add(x,y) might be called as add(3,4)\n\n              //so we set x=3, y=4 and set self variable-value pair in functionContextmemory\n\n              functionArguments.forEach((el, index) => {\n                let val = passedValues[index];\n\n                val = val.replace(/\"/g, '');\n                val = val.replace(/'/g, '');\n\n                passedValues[index] = val;\n\n                //in self code we are filtering out arguments passed based on whether they already exist in updated tokens or not\n\n                let FindInUpdatedTokens = memory.find((el) => el.name === val);\n\n                //For passing same argument and same value to function  e.g function foo (fibonacci) and fibonacci is already declared with some value\n                if (FindInUpdatedTokens === undefined) {\n                  functionContextmemory.push({\n                    name: el,\n\n                    value: val,\n\n                    identifier: j + index,\n                    type: 'value',\n                    context: 'FunctionExecutionContext',\n                  });\n                }\n\n                //For passing different argument and value to function  e.g function foo (arr) and arr doesn't exist anywhere in tokens.\n                else if (el != FindInUpdatedTokens.name && FindInUpdatedTokens != undefined) {\n                  functionContextmemory.push({\n                    name: el,\n\n                    value: FindInUpdatedTokens.value,\n\n                    identifier: j + index,\n                    type: FindInUpdatedTokens.type,\n                    context: 'FunctionExecutionContext',\n                    IntheEndSetValueto: val,\n                  });\n                } else {\n                  functionContextmemory.push({\n                    name: el,\n\n                    value: val,\n\n                    identifier: j + index,\n                    type: FindInUpdatedTokens.type,\n                    context: 'FunctionExecutionContext',\n                    IntheEndSetValueto: val,\n                  });\n                }\n              });\n\n              //Building a complete variable-value pair dataset\n\n              var CompleteTokenValueList = [...memory, ...functionContextmemory];\n\n              let message = 'Computer ' + '\"' + functionName + '\"' + '      (Call)   |  ' + '\"()\"' + '     New Values   ' + functionName + '   ,  ' + functionName + '         |';\n\n              let expression = functionName + '(';\n\n              let description = '                | ';\n\n              let position = findtokenPositioninCode(LinebylineSourcedata, expression, false);\n\n              if (position != undefined) {\n                AddtoExecutionStack(ExecutionStack, ActiveLangugaeKeywords.Function, description, functionName, functionSourceData, message, position);\n              }\n\n              //Now we start digging into the function execution\n              //might have to change i to 1\n              //skip in functionsourcedata\n              for (let i = 0; i < functionSourceData.length; i++) {\n                skipInterpretation = 0;\n                try {\n                  interpretToken(functionSourceData, i, CompleteTokenValueList);\n                } catch (e) {\n                  console.log(e, `error in interpreting function execution ${functionName}`);\n                }\n                if (skipInterpretation != 0) {\n                  i = i + skipInterpretation;\n                }\n              }\n              break;\n            }\n          }\n        }\n      } catch (e) {\n        console.log(e, `Error in Interpreting token ${mutable_tokens[j]}`);\n      }\n      /* else if (token === \"\") {\n        let result = HandleBlocks(mutable_tokens, j, result);\n        // let StartofBlock = mutable_tokens[j + 1].startIndex;\n        let EndofBlock = mutable_tokens[j + 1].EndIndex;\n  \n        let lastValue = kalaam.LastConditionValue.pop();\n  \n        if (lastValue) {\n          j = EndofBlock;\n        }*/\n    }\n\n    //#STEP 1- Cleaning the sourcedata and setting the 'result' to 'cleaned_sourcedata'\n\n    //If a code is not working, it is probably because it's not cleaned properly.\n\n    cleaned_sourcedata = GetCleanSourcedata(sourcedata, cleaned_sourcedata, mixedimpurity);\n    console.log('cleaned_sourcedata:', cleaned_sourcedata)\n\n      //#STEP 2- - Parsing cleaned_sourcedata, adding each item depending on it's type to tokens array\n\n      // PARSING INITIATION\n      (function _parser() {\n        for (i; i < cleaned_sourcedata.length; i++) {\n          _analyzeToken(cleaned_sourcedata, i, tokens);\n\n          //Code to skip improve a particular part of cleaned_sourcedata if it's being operated by two different functions.\n          if (skipParsing != 0) {\n            i = i + skipParsing;\n          }\n        }\n      })();\n\n    //CLEANING UP THE TOKENS ARRAY\n    //Removing tokens with value = '', It was generated due to \" cleaned_sourcedata = cleaned_sourcedata.replace(/(;|\\n|\\r)/gm, \" \").split(' ')\"\n\n    //Filtering seemed unnecessary, removed for now.\n    //tokens = tokens.filter(el => el.value != '')\n\n    //variableArray = tokens.filter((el) => el.type === 'variable');\n\n    //As of now, this is how the timeline looks\n\n    //raw sourcecode -> cleaned_sourcedata -> tokens\n\n    //#STEP 3 - evaluating conditions, running loops, executing functions finding values in memory and printing outputs\n\n    //This is the final section\n    //interpreting the code from syntax tree\n    (function _interpretor() {\n      for (let x = 0; x < tokens.length; x++) {\n        //We will be having a copy of tokens as mutable_tokens\n        interpretToken(tokens, x, memory);\n        if (skipInterpretation != 0) {\n          x = x + skipInterpretation;\n        }\n      }\n    })();\n\n    //This is where error handling kicks in\n\n    //To find undefined variables\n\n    function onlyUnique(value, index, arr) {\n      return arr.indexOf(value) === index;\n    }\n\n    var assigned_variables = assigned_variables.filter(onlyUnique);\n\n    var difference = variables_array.filter((x) => !assigned_variables.includes(x));\n\n    if (difference.length > 0) {\n      difference.forEach((el) => {\n        kalaam.error.push(`Variable ${el} is undefined`);\n      });\n    }\n\n    kalaam.linebylineOutput = kalaam.error.length > 0 ? kalaam.error : kalaam.output.split('\\n');\n\n    //time taken to transpile the code is t1-t0\n    var t1 = performance.now(); // eslint-disable-line\n\n    if (kalaam.error.length === 0) {\n      let s = (t1 - t0).toPrecision(4);\n      kalaam.TimeTaken = ` | speed - ${s} ms`;\n    } else {\n      kalaam.isError = true;\n\n      kalaam.TimeTaken = 'Compilation Error: Check for assignement and declaration mistyping';\n    }\n\n    //kalaam.linebylineoutput is what you will finally see on output screen\n\n    kalaam.linebylineOutput = kalaam.linebylineOutput.filter(function (item) {\n      return item !== '';\n    });\n\n    kalaam.ExecutionStack = ExecutionStack;\n    return kalaam;\n  } catch (e) {\n    console.log(e);\n  }\n}\nconsole.log('Compile:', Compile);\n\nexport { Compile, KalaamKeywords };\n"]}]}