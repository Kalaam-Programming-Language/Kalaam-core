{"remainingRequest":"/Users/jonny/Desktop/myProjects/Kalaam-BE/FE/node_modules/babel-loader/lib/index.js!/Users/jonny/Desktop/myProjects/Kalaam-BE/Compiler/main.js","dependencies":[{"path":"/Users/jonny/Desktop/myProjects/Kalaam-BE/Compiler/main.js","mtime":1652753433898},{"path":"/Users/jonny/Desktop/myProjects/Kalaam-BE/FE/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/jonny/Desktop/myProjects/Kalaam-BE/FE/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0IjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmlsdGVyIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmluZCI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZvci1lYWNoIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaW5jbHVkZXMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pbmRleC1vZiI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmpvaW4iOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zcGxpY2UiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5kYXRlLnRvLXN0cmluZyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmZ1bmN0aW9uLm5hbWUiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5udW1iZXIudG8tcHJlY2lzaW9uIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnRvLXN0cmluZyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pbmNsdWRlcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5yZXBsYWNlIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnNwbGl0IjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5mb3ItZWFjaCI7CmltcG9ydCBfdG9Db25zdW1hYmxlQXJyYXkgZnJvbSAiL1VzZXJzL2pvbm55L0Rlc2t0b3AvbXlQcm9qZWN0cy9LYWxhYW0tQkUvRkUvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3RvQ29uc3VtYWJsZUFycmF5IjsKCi8qIQogKiBLYWxhYW0gdjEuMC4wCiAqIChDKSAyMDIwLTIxIFN3YW5hbmQgS2FkYW0KICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLgogKi8KLy9TRUNUSU9OIC0gSW1wb3J0aW5nIGZ1bmN0aW9uIG1vZHVsZXMKLy9UbyBjaGVjayB2YXJpYWJsZSB0eXBlczogTnVtYmVyLCBTdHJpbmcsIEFycmF5IGV0Yy4KaW1wb3J0ICogYXMgVHlwZUNoZWNrIGZyb20gJy4uL1R5cGVDaGVjay9UeXBlQ2hlY2tpbmcnOwppbXBvcnQgeyBBY3RpdmVMYW5ndWdhZUtleXdvcmRzLCBLYWxhYW1LZXl3b3JkcyB9IGZyb20gJy4uL0NvbXBpbGVyL2NvbnN0YW50cyc7IC8vVG8gY2hlY2sgb3RoZXIgb3BlcmF0aW9ucyBsaWtlIE11bHRpU3RyaW5nLCBBcml0aG1ldGljIE9wZXJhdGlvbiBldGMuCgppbXBvcnQgKiBhcyBBZHZhbmNlZFR5cGVDaGVjayBmcm9tICcuLi9UeXBlQ2hlY2svQWR2YW5jZWRUeXBlQ2hlY2tpbmcnOyAvL1RvIGZvcm1hdCB1c2VyIGlucHV0IGludG8gYSBwcm9wZXIgU3RyaW5nLCBBcnJheSBvciBDb25kaXRpb24uCgppbXBvcnQgKiBhcyBCdWlsZE9wZXJhdGlvbiBmcm9tICcuLi9TY3JpcHRzL0J1aWxkT3BlcmF0aW9ucyc7CmltcG9ydCB7IFJlbW92ZVF1b3RlcywgUmVtb3ZlQnJhY2tldHMsIGVhcmx5Q2xlYW5pbmcgfSBmcm9tICcuLi9TY3JpcHRzL0hlbHBlcnMnOyAvL0Z1bmN0aW9ucyBpbXBvcnRlZCB0byBwdXNoIGEgcGFydGljdWxhciBkYXRhIHRvIG91ciBUb2tlbnMgYXJyYXkuCi8vVG9rZW5zIGFycmF5IGlzIGJhc2ljYWxseSBhIGNsZWFuLCBmb3JtYXR0ZWQgYW5kIGEgd29yZCBieSB3b3JkIHZlcnNpb24gb2YgcmF3IGNvZGUgcHJvdmlkZWQgYnkgdXNlcgoKaW1wb3J0IHsgUHVzaEFycmF5LCBQdXNoQ2FsY3VsYXRpb24sIFB1c2hDb25kaXRpb25hbEtleXdvcmQsIFB1c2hDb25kaXRpb24sIFB1c2hGb3JMb29wLCBQdXNoV2hpbGVMb29wLCBQdXNoRm9yTG9vcEFydWd1bWVudHMsIFB1c2hFeHByZXNzaW9uLCBQdXNoTmF0aXZlT3BlcmF0aW9uLCBQdXNoS2V5d29yZCwgUHVzaE51bWJlciwgUHVzaE9wZXJhdG9yLCBQdXNoUmVhbFRpbWVQcmludE9wZXJhdGlvbiwgUHVzaFN0cmluZywgUHVzaFZhcmlhYmxlLCBQdXNoVmFyaWFibGVWYWx1ZSwgUHVzaEZ1bmN0aW9uRGF0YSwgUHVzaEZ1bmN0aW9uRXhlY3V0aW9uLCBQdXNoVG9BcnJheSwgUHVzaElucHV0IH0gZnJvbSAnLi4vUHVzaFRva2Vucy9tYWluJzsgLy9UaGlzIGFyZSBvdGhlciBoZWxwZXIgZnVuY3Rpb25zIHRoYXQgd2UgbmVlZCBmb3IgYSBwYXJ0aWN1bGFyIHRhc2suIEFsbCBvZiB0aGlzIGZ1bmN0aW9ucyB3aWxsIGJlIGV4cGxhaW5lZCBpbmRlcHRoIGFzIHdlIHNlZSB0aGVtIGluIGNvZGViYXNlLgoKaW1wb3J0IHsgR2V0Q2xlYW5Tb3VyY2VkYXRhLCBHZXRjbGVhbmVkRXhwcmVzc2lvbiwgQWRkRWxlbWVudFRvQXJyYXksIFJlc2V0VmFsdWUsIENyZWF0ZUFycmF5RWxlbWVudCwgQ2FsY3VsYXRlVmFsdWVzLCBHZXRBcnJheW9yU3RyaW5nRWxlbWVudCwgSGFuZGxlQmxvY2tzLCBTcGxpdEVsZW1lbnRzQXJyYXksIFNldFZhbHVlcywgUHVzaFNldEFycmF5SW5kZXhWYWx1ZSwgUHVzaEdldEFycmF5SW5kZXhWYWx1ZSwgR2V0Q29uZGl0aW9uVmFsdWUsIEFjY2VwdElucHV0YW5kU2V0VmFsdWUsIEFzc2lnbm9yVXBkYXRlVmFsdWVzLCBIYW5kbGVDb25kaXRpb25zLCBnZXRMb29wSW5kZXhTdGFydCwgRm9yTG9vcFNldE1ldGFkYXRhLCBTZXRBcnJheUluZGV4VmFsdWUsIEFkZHRvRXhlY3V0aW9uU3RhY2sgfSBmcm9tICcuLi9TY3JpcHRzL21haW4uanMnOwppbXBvcnQgc2Nhbm5lciBmcm9tICcuLi9zY2FubmVyL21haW4nOwppbXBvcnQgJy4uL0hlbHBlckxpYnJhcnkvbWFpbic7CmltcG9ydCB7IGhhbmRsZVJlYWx0aW1lUHJpbnQsIGhhbmRsZVZhcmlhYmxlLCBoYW5kbGVPdXRwdXQsIHByZXBhcmVGdW5jdGlvbiB9IGZyb20gJy4uL1NjcmlwdHMvSGFuZGxlcnMnOwppbXBvcnQgeyBmaW5kdG9rZW5Qb3NpdGlvbmluQ29kZSB9IGZyb20gJy4uL1NjcmlwdHMvZmluZGVycyc7CmltcG9ydCB7IGlzSW50ZXJwcmV0YWJsZVR5cGUgfSBmcm9tICcuLi9TY3JpcHRzL3Rlc3RlcnMnOyAvL1dlIHdpbGwgYmUgaW1wb3J0aW5nIHRoaXMgd2hvbGUgZnVuY3Rpb24gdG8gcHJhY3Rpc2UudnVlIGFuZCBpdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gdXNlciBjbGlja3Mgb24gJ1JVTicKCmZ1bmN0aW9uIENvbXBpbGUoc291cmNlY29kZSkgewogIHRyeSB7CiAgICAvL1RoaXMgd2lsbCBydW4gZm9yIGV2ZXJ5IOCkpuCkv+CkluCkvuCkjygpIHN0YXRlbWVudCBlbmNvdW50ZXJlZCBpbiB0aGUgcHJvZ3JhbSwgbm90IGp1c3QgZm9yIGxvb3BzCiAgICAvL0FSR1VNRU5UUyBUTyBQcmludEVuZ2luZSBhcmU6CiAgICAvL1Rva2Vucy0gVG9rZW5zIGFycmF5CiAgICAvL21lbW9yeS0gVmFyaWFibGUtdmFsdWUgcGFpcnMgb2YgdmFyaWFibGVzCiAgICAvL2otIEluZGV4IG9mIGEgdG9rZW4gaW4gVG9rZW5zIGFycmF5CiAgICAvL2dsb2JhbC0gc2VsZiBvciBzZWxmCiAgICAvL2l0ZXJhdG9yIGFuZCBPcmlnaW5hbEl0ZXJhdG9yIGFyZSB1c2VkIHRvIHByaW50IHZhbHVlcyBpbiBmb3IgYW5kIHdoaWxlIGxvb3BzLgogICAgdmFyIFByaW50RW5naW5lID0gZnVuY3Rpb24gUHJpbnRFbmdpbmUoVG9rZW5zLCBtZW1vcnksIGosIGl0ZXJhdG9yLCBPcmlnaW5hbEl0ZXJhdG9yKSB7CiAgICAgIC8vVG8gdW5kZXJzdGFuZCB3aGF0IGtpbmQgb2YgZGF0YSBpcyBuZWNlc3NhcnkgdG8gcHJpbnQgYSB2YWx1ZQogICAgICAvL0dldHRpbmcgdGhlIGN1cnJlbnQgdG9rZW4gYXMgdG9rZW4gYW5kIHZhbHVlIHRvIGJlIHByaW50ZWQgYXMgTmV4dFRva2VuVmFsdWUKICAgICAgLy9lLmcuIEZvciDgpKbgpL/gpJbgpL7gpI8oTmFtZSksIE5hbWUgaXMgdGhlIE5leHRUb2tlblZhbHVlIGFuZCBpdCBpcyB0aGUgb25lIHdoaWNoIHdlIHdpbGwgaGF2ZSB0byBwcmludAogICAgICB2YXIgU3RyaW5nVmFyID0gW107CiAgICAgIHZhciB0b2tlbiA9IFRva2Vuc1tqXS52YWx1ZTsKICAgICAgdmFyIE5leHRUb2tlblZhbHVlID0gVG9rZW5zLm5leHRFbGVtZW50KGopLnZhbHVlOyAvL1JlbW92aW5nIHRoZSBicmFja2V0cywgaWYgYW55LgoKICAgICAgdmFyIFZhcmlhYmxlVG9QcmludCA9IFJlbW92ZUJyYWNrZXRzKE5leHRUb2tlblZhbHVlKTsgLy9TRUNUSU9OIC0gT3V0cHV0dGluZyB0aGUgY29kZQogICAgICAvLyBmaW5kaW5nIHRoZSB2YXJpYWJsZSB2YWx1ZSBpbiBtZW1vcnkuIG1lbW9yeSBpcyB3aGVyZSBvdXIgVmFyaWFibGUtdmFsdWUgcGFpcnMgZXhpc3RzLgogICAgICAvL1RoaXMgbG9vcCBpcyBvbmx5IGZvciBwcmludGluZyBkaXJlY3QgdmFsdWVzIGxpa2UgcHJpbnQobmFtZSksIHByaW50KGFycmF5KQoKICAgICAgbWVtb3J5LmZvckVhY2goZnVuY3Rpb24gKGVsKSB7CiAgICAgICAgLy9JZiB3ZSBoYXZlIGEgdmFyaWFibGUtdmFsdWUgcGFpciBzaXR0aW5nIGluIG1lbW9yeQogICAgICAgIGlmIChlbC5uYW1lID09PSBWYXJpYWJsZVRvUHJpbnQpIHsKICAgICAgICAgIC8vZm9yIGNhbGN1bGF0aW9ucyBsaWtlIHg9YWdlb25lK2FnZXR3bwogICAgICAgICAgLy9JZiB3ZSBoYXZlIGFscmVhZHkgY2FsY3VsYXRlZCB2YWx1ZSBpbiBhc3NpZ25lZF92YXJpYWJsZXMsIHVzZSB0aGF0IG9yIGVsc2UgbW92ZSBmb3J3YXJkCiAgICAgICAgICBpZiAoYXNzaWduZWRfdmFyaWFibGVzLmluY2x1ZGVzKGVsKSB8fCBhc3NpZ25lZF92YXJpYWJsZXMuaW5jbHVkZXMoZWwubmFtZSkpIHsKICAgICAgICAgICAgaGFuZGxlT3V0cHV0KGVsLnZhbHVlLCBrYWxhYW0pOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgLy9pZiB0aGUgdmFsdWUgZm91bmQgaXMgYSBOdW1iZXIKICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGVsLnZhbHVlKSkgewogICAgICAgICAgICAgIGhhbmRsZU91dHB1dChlbC52YWx1ZSwga2FsYWFtKTsKICAgICAgICAgICAgICBhc3NpZ25lZF92YXJpYWJsZXMucHVzaChlbC5uYW1lKTsKICAgICAgICAgICAgfSAvL2lmIHRoZSB2YWx1ZSBmb3VuZCBpcyBvcGVyYXRpb25zIGxpa2UgYWdlPTIwMjAtMTk5NgogICAgICAgICAgICBlbHNlIGlmIChpc1B1cmVFdmFsKGVsLnZhbHVlKSkgewogICAgICAgICAgICAgICAgLy93ZSBhcmUgdXNpbmcgSmF2YXNjcmlwdCdzIGV2YWwgZnVuY3Rpb24gdG8gY2FsY3VsYXRlIGRpcmVjdCBhcml0aG1ldGljIG9wZXJhdGlvbnMKICAgICAgICAgICAgICAgIHZhciBvdXRwdXRwdXJlID0gZXZhbChlbC52YWx1ZSk7CiAgICAgICAgICAgICAgICBlbC52YWx1ZSA9IG91dHB1dHB1cmU7CiAgICAgICAgICAgICAgICBoYW5kbGVPdXRwdXQoZWwudmFsdWUsIGthbGFhbSk7CiAgICAgICAgICAgICAgICBhc3NpZ25lZF92YXJpYWJsZXMucHVzaChlbC5uYW1lKTsKICAgICAgICAgICAgICB9IC8vV2Ugd2lsbCBzaW1wbGlmeSB0aGlzIGNvbmRpdGlvbnMgYXMgd2UgbW92ZSBmb3J3YXJkCiAgICAgICAgICAgICAgZWxzZSBpZiAoIWlzUHVyZUV2YWwoZWwudmFsdWUpICYmICFpc051bWJlcihlbC52YWx1ZSkpIHsKICAgICAgICAgICAgICAgICAgaWYgKCEoZWwubmFtZS5pbmNsdWRlcygnXScpICYmIGVsLm5hbWUuaW5jbHVkZXMoJ1snKSkpIHsKICAgICAgICAgICAgICAgICAgICBpZiAoZWwudHlwZSA9PT0gJ0FycmF5JykgewogICAgICAgICAgICAgICAgICAgICAgaWYgKCFlbC52YWx1ZS5pbmNsdWRlcygnWycpKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGVsLnZhbHVlID0gJ1snICsgZWwudmFsdWUudG9TdHJpbmcoKSArICddJzsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgIGhhbmRsZU91dHB1dChlbC52YWx1ZSwga2FsYWFtKTsKICAgICAgICAgICAgICAgICAgICBhc3NpZ25lZF92YXJpYWJsZXMucHVzaChlbC5uYW1lKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSk7IC8vVGhpcyBpcyBob3cgd2UgcHJpbnQgQXJyYXkgaW4gS2FsYWFtCgogICAgICBpZiAoVG9rZW5zW2ogKyAxXS50eXBlID09PSAnQXJyYXknKSB7CiAgICAgICAgLy9UbyBydW4gb25seSBpZiBpdGVyYXRvciBpcyBwcmVzZW50CiAgICAgICAgLy9UaGlzIHJ1bnMgb24gZm9yIGxvb3AgLSDgpKbgpL/gpJbgpL7gpI8oQXJyYXlbYV0pIGV0YwogICAgICAgIC8vc2VsZiBydW5zIG9ubHkgaWYgZm9yKGkpIGFuZCBpbiB0aGUgbG9vcCwgYXJyYXlbaV0sIG5vdCBvbiBhcnJheVt4XS4gRm9yIGxvb3AgSXRlcmF0b3IgYW5kIGluZGV4IHNob3VsZCBiZSBzYW1lLCBpbiBzZWxmIGNhc2UgJ2knCiAgICAgICAgaWYgKGl0ZXJhdG9yICE9IHVuZGVmaW5lZCAmJiBUb2tlbnNbaiArIDFdLkluZGV4SW5wdXQgPT09IE9yaWdpbmFsSXRlcmF0b3IpIHsKICAgICAgICAgIHZhciBWYWx1ZSA9IE5leHRUb2tlblZhbHVlOwogICAgICAgICAgdmFyIEFycmF5RWxlbWVudCA9IENyZWF0ZUFycmF5RWxlbWVudChWYWx1ZSwgaXRlcmF0b3IpOwogICAgICAgICAgdmFyIG91dHB1dCA9IEdldEFycmF5b3JTdHJpbmdFbGVtZW50KEFycmF5RWxlbWVudCwgbWVtb3J5KTsKICAgICAgICAgIG91dHB1dCA9IFJlbW92ZVF1b3RlcyhvdXRwdXQpOwogICAgICAgICAgaGFuZGxlT3V0cHV0KG91dHB1dCwga2FsYWFtKTsKICAgICAgICAgIGFzc2lnbmVkX3ZhcmlhYmxlcy5wdXNoKFRva2Vuc1tqICsgMV0pOwogICAgICAgIH0gLy9UaGlzIHJ1bnMgdG8gUHJpbnQoQXJyYXlbMl0pIGxpa2Ugc3BlY2lmaWMgYXJyYXkgdmFsdWVzCiAgICAgICAgZWxzZSBpZiAoVG9rZW5zW2ogKyAxXS5JbmRleElucHV0ICE9IE9yaWdpbmFsSXRlcmF0b3IpIHsKICAgICAgICAgICAgdmFyIF9WYWx1ZSA9IE5leHRUb2tlblZhbHVlOwogICAgICAgICAgICB2YXIgSW5kZXhUb0NoYW5nZSA9IFRva2Vuc1tqICsgMV0uSW5kZXhJbnB1dDsKCiAgICAgICAgICAgIHZhciBfQXJyYXlFbGVtZW50ID0gQ3JlYXRlQXJyYXlFbGVtZW50KF9WYWx1ZSwgSW5kZXhUb0NoYW5nZSk7CgogICAgICAgICAgICB2YXIgZWxlbWVudCA9IF9BcnJheUVsZW1lbnQucmVwbGFjZSgnXScsICcnKTsKCiAgICAgICAgICAgIHZhciBTcGxpdCA9IGVsZW1lbnQuc3BsaXQoJ1snKTsKCiAgICAgICAgICAgIGlmIChTcGxpdFsxXS5pbmNsdWRlcygnLScpIHx8IFNwbGl0WzFdLmluY2x1ZGVzKCcrJykpIHsKICAgICAgICAgICAgICB2YXIgX291dHB1dDIgPSBDYWxjdWxhdGVWYWx1ZXMoU3BsaXRbMV0sIGosIG1lbW9yeSk7CgogICAgICAgICAgICAgIFNwbGl0WzFdID0gX291dHB1dDI7CiAgICAgICAgICAgICAgU3BsaXQgPSBTcGxpdC5qb2luKCdbJykgKyAnXSc7CiAgICAgICAgICAgICAgX0FycmF5RWxlbWVudCA9IFNwbGl0OwogICAgICAgICAgICB9CgogICAgICAgICAgICB2YXIgX3Rva2VuID0gbWVtb3J5LmZpbmQoZnVuY3Rpb24gKGVsKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGVsLm5hbWUgPT09IFNwbGl0WzFdOwogICAgICAgICAgICB9KTsKCiAgICAgICAgICAgIGlmIChfdG9rZW4gIT0gdW5kZWZpbmVkICYmIE9yaWdpbmFsSXRlcmF0b3IgIT0gU3BsaXRbMV0pIHsKICAgICAgICAgICAgICBTcGxpdFsxXSA9IF90b2tlbi52YWx1ZTsKICAgICAgICAgICAgICBTcGxpdCA9IFNwbGl0LmpvaW4oJ1snKSArICddJzsKICAgICAgICAgICAgICBfQXJyYXlFbGVtZW50ID0gU3BsaXQ7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgX0FycmF5RWxlbWVudCA9IF9BcnJheUVsZW1lbnQ7IC8vLy8KICAgICAgICAgICAgfQoKICAgICAgICAgICAgdmFyIF9vdXRwdXQgPSBHZXRBcnJheW9yU3RyaW5nRWxlbWVudChfQXJyYXlFbGVtZW50LCBtZW1vcnkpOwoKICAgICAgICAgICAgaGFuZGxlT3V0cHV0KF9vdXRwdXQsIGthbGFhbSk7CiAgICAgICAgICB9CiAgICAgIH0gLy9wcmludGluZyBkaXJlY3QgbnVtYmVycyBhbmQgZGlyZWN0IGNhbGN1bHRpb25zIGxpa2UgcHJpbnQoMTApLCBwcmludCgxMCoxMCkKICAgICAgZWxzZSBpZiAodG9rZW4gPT09IEFjdGl2ZUxhbmd1Z2FlS2V5d29yZHMuUHJpbnQgJiYgKGlzUHVyZUV2YWwoUmVtb3ZlQnJhY2tldHMoTmV4dFRva2VuVmFsdWUpKSB8fCBpc051bWJlcihSZW1vdmVCcmFja2V0cyhOZXh0VG9rZW5WYWx1ZSkpKSkgewogICAgICAgICAgTmV4dFRva2VuVmFsdWUgPSBSZW1vdmVCcmFja2V0cyhOZXh0VG9rZW5WYWx1ZSk7CgogICAgICAgICAgaWYgKGlzTnVtYmVyKE5leHRUb2tlblZhbHVlKSAmJiBUb2tlbnNbaiArIDFdLnR5cGUgIT0gJ0NhbGN1bGF0aW9uJykgewogICAgICAgICAgICBoYW5kbGVPdXRwdXQoTmV4dFRva2VuVmFsdWUsIGthbGFhbSk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB2YXIgYSA9IGV2YWwoTmV4dFRva2VuVmFsdWUpOwogICAgICAgICAgICBoYW5kbGVPdXRwdXQoYSwga2FsYWFtKTsKICAgICAgICAgIH0KICAgICAgICB9IC8vZm9yb3BlcmF0aW9ucyBsaWtlIHByaW50KCd5b3UgbGl2ZSwgeW91IGxlYXJuJykKICAgICAgICBlbHNlIGlmIChUb2tlbnNbaiArIDFdLm1vZGUgPT09ICdSZWFsVGltZVByaW50JyAmJiAhTmV4dFRva2VuVmFsdWUuaW5jbHVkZXMoJysnKQogICAgICAgICAgLyomJiAhTmV4dFRva2VuVmFsdWUuaW5jbHVkZXMoJz0nKSovCiAgICAgICAgICApIHsKICAgICAgICAgICAgICB2YXIgX291dHB1dDMgPSBSZW1vdmVCcmFja2V0cyhOZXh0VG9rZW5WYWx1ZSk7CgogICAgICAgICAgICAgIF9vdXRwdXQzID0gUmVtb3ZlUXVvdGVzKF9vdXRwdXQzKTsKICAgICAgICAgICAgICBoYW5kbGVPdXRwdXQoX291dHB1dDMgKyAnXG4nLCBrYWxhYW0pOwogICAgICAgICAgICB9IC8vb3BlcmF0aW9ucyBsaWtlIHByaW50KEFnZSArICdpcyB5b3VuZyBhZ2UnKSBpLmUgc3RyaW5nIGNvbmNhdGVuYXRpb25zCiAgICAgICAgICBlbHNlIGlmIChUb2tlbnNbaiArIDFdLm1vZGUgPT09ICdSZWFsVGltZVByaW50JyAmJiBOZXh0VG9rZW5WYWx1ZS5pbmNsdWRlcygnKycpKSB7CiAgICAgICAgICAgICAgdmFyIHggPSBTcGxpdEVsZW1lbnRzQXJyYXkoTmV4dFRva2VuVmFsdWUpOwogICAgICAgICAgICAgIHggPSB4LmpvaW4oJycpLnNwbGl0KCcrJyk7CiAgICAgICAgICAgICAgU3RyaW5nVmFyID0gU2V0VmFsdWVzKHgsIG1lbW9yeSk7CgogICAgICAgICAgICAgIHZhciBfb3V0cHV0NCA9IFN0cmluZ1Zhci5qb2luKCcgJyk7CgogICAgICAgICAgICAgIF9vdXRwdXQ0ID0gUmVtb3ZlQnJhY2tldHMoX291dHB1dDQpOwogICAgICAgICAgICAgIF9vdXRwdXQ0ID0gUmVtb3ZlUXVvdGVzKF9vdXRwdXQ0KTsKICAgICAgICAgICAgICBoYW5kbGVPdXRwdXQoX291dHB1dDQgKyAnXG4nLCBrYWxhYW0pOwogICAgICAgICAgICB9IGVsc2UgaWYgKGlzQ2FsY3VsYXRpb24oUmVtb3ZlQnJhY2tldHMoTmV4dFRva2VuVmFsdWUpKSAmJiBUb2tlbnNbaiArIDFdLm1vZGUgIT0gJ1JlYWxUaW1lUHJpbnQnKSB7CiAgICAgICAgICAgICAgTmV4dFRva2VuVmFsdWUgPSBSZW1vdmVCcmFja2V0cyhOZXh0VG9rZW5WYWx1ZSk7CgogICAgICAgICAgICAgIHZhciBfb3V0cHV0NSA9IENhbGN1bGF0ZVZhbHVlcyhOZXh0VG9rZW5WYWx1ZSwgaiwgbWVtb3J5KTsKCiAgICAgICAgICAgICAgaGFuZGxlT3V0cHV0KF9vdXRwdXQ1ICsgJ1xuJywga2FsYWFtKTsKICAgICAgICAgICAgfQoKICAgICAgdmFyIG1lc3NhZ2UgPSAnIENvbXB1dGVyIOCkqOClhyDgpIbgpKrgpJXgpYAg4KSm4KWAIOCkl+Ckr+ClgCDgpLXgpYjgpLLgpY3gpK/gpYIsICcgKyAnIicgKyBSZW1vdmVCcmFja2V0cyhOZXh0VG9rZW5WYWx1ZSkgKyAnIicgKyAnIOCkleCliyDgpKbgpL/gpJbgpL7gpK/gpL4g4KS54KWIIHwnOyAvL1RoaXMgaXMgdGhlIGV4cGVyZXNzaW9uIHdoY2loIGlzIGdldHRpbmcgZXZhbHVhdGVkLgoKICAgICAgdmFyIGV4cHJlc3Npb24gPSB0b2tlbiArIE5leHRUb2tlblZhbHVlOwogICAgICB2YXIgZGVzY3JpcHRpb24gPSAn4KSV4KS/4KS44KWAIFZBTFVFIOCkleCliyBPVVRQVVQgU0NSRUVOIOCkquClhyDgpKbgpL/gpJbgpL7gpKjgpYcg4KSV4KWHIOCksuCkv+CkjyDgpKbgpL/gpJbgpL7gpI8oKSDgpJXgpL4g4KSJ4KSq4KSv4KWL4KSXIOCkueCli+CkpOCkviDgpLngpYjgpaQnOwogICAgICBleHByZXNzaW9uID0gR2V0Y2xlYW5lZEV4cHJlc3Npb24oZXhwcmVzc2lvbik7CiAgICAgIHZhciBwb3NpdGlvbiA9IGZpbmR0b2tlblBvc2l0aW9uaW5Db2RlKExpbmVieWxpbmVTb3VyY2VkYXRhLCBleHByZXNzaW9uLCB0cnVlKTsKCiAgICAgIGlmIChwb3NpdGlvbiAhPSB1bmRlZmluZWQpIHsKICAgICAgICBBZGR0b0V4ZWN1dGlvblN0YWNrKEV4ZWN1dGlvblN0YWNrLCBBY3RpdmVMYW5ndWdhZUtleXdvcmRzLlByaW50LCBkZXNjcmlwdGlvbiwgVmFyaWFibGVUb1ByaW50LCBudWxsLCBtZXNzYWdlLCBwb3NpdGlvbik7CiAgICAgIH0KICAgIH07IC8vRU5EIE9GIEZ1bmN0aW9ucyBhbmQgSW1wb3J0ZWQgRnVuY3Rpb25zCiAgICAvL091dCBvZiBhbGwgc2VsZiBmdW5jdGlvbiwgUHJpbnRFbmdpbmUgaXMgdmVyeSBpbXBvcnRhbnQgZnVuY3Rpb24uIEl0IHByaW50cyB2YXJpYWJsZSB2YWx1ZXMgYnkgc2VhcmNoaW5nIHRoZWlyIHZhbHVlIGluIG1lbW9yeS4KICAgIC8vU0VDVElPTiAtIENoZWNraW5nIGVhY2ggdG9rZW4gYW5kIGFkZGluZyB0byB0b2tlbnMgYXJyYXkKICAgIC8vX3Rva2VucyB0YWtlcyB0d28gYXJndW1lbnRzLiBUaGUgY2xlYW5lZF9zb3VyY2VkYXRhIGFycmF5IGFuZCBjdXJyZW50IGluZGV4IG9mIGNsZWFuZWRfc291cmNlZGF0YSBhcnJheQogICAgLy9fdG9rZW5zIGlzIHVzZWQgdG8gY3JlYXRlIGEgdG9rZW5zIGFycmF5IHdpdGggZWFjaCB0b2tlbiBoYXZpbmcgaXQncyBuYW1lLCB2YWx1ZSwgdHlwZSBhbmQgb3RoZXIgbWV0YWRhdGEKICAgIC8vSXQgcGVyZm9ybXMgb3BlcmF0aW9ucyBkZXBlbmRpbmcgdXBvbiB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHZhcmlhYmxlLCBhcnJheSwgZnVuY3Rpb24sIGxvb3AgZXRjLgogICAgLy9zY2FubmluZyBldmVyeSBzaW5nbGUgZWxlbWVudCBmcm9tIGNsZWFuZWRfc291cmNlZGF0YSBhcnJheSBhbmQgcHVzaGluZyBpdCB0byBUb2tlbnMgZGVwZW5kaW5nIHVwb24gdGhlIHR5cGUgcGYgZWxlbWVudAoKCiAgICB2YXIgX2FuYWx5emVUb2tlbiA9IGZ1bmN0aW9uIF9hbmFseXplVG9rZW4oY2xlYW5lZF9zb3VyY2VkYXRhLCBpLCB0b2tlbnMpIHsKICAgICAgdmFyIGVsZW1lbnQgPSBjbGVhbmVkX3NvdXJjZWRhdGFbaV07CiAgICAgIHNraXBQYXJzaW5nID0gMDsKICAgICAgdmFyIG5leHRFbCA9IGNsZWFuZWRfc291cmNlZGF0YS5uZXh0RWxlbWVudChpKTsKICAgICAgdmFyIHByZXZFbCA9IGNsZWFuZWRfc291cmNlZGF0YS5wcmV2RWxlbWVudChpKTsKICAgICAgdmFyIHRva2VuX3R5cGUgPSBzY2FubmVyKGNsZWFuZWRfc291cmNlZGF0YSwgaSwgdG9rZW5zKTsgLy9QdXNoIHZhcmlhYmxlcyB0byB0b2tlbnMKICAgICAgLy9Gb3JtYXQ6IHt0eXBlOiAidmFyaWFibGUiLCB2YWx1ZTogIlJldmVyc2VTdHJpbmcifQogICAgICAvL3doZW5ldmVyIHdlIG5lZWQgYSBjZXJ0YWluIGhhbmRsaW5nLCBoYW5kbGVycy5qcyBpcyB1c2VkCgogICAgICBzd2l0Y2ggKHRva2VuX3R5cGUpIHsKICAgICAgICBjYXNlICdWQVJJQUJMRSc6CiAgICAgICAgICAvL0hlcmUgd2Ugc2VwZXJhdGUgTWVzc2FnZSA9ICdIZWxsbycgaW50byBmb2xsb3dpbmcgdGhyZWUgdG9rZW5zIDoKICAgICAgICAgIC8vMTrCoHt0eXBlOsKgInZhcmlhYmxlIizCoHZhbHVlOsKgIk1lc3NhZ2UifQogICAgICAgICAgLy8yOsKge3R5cGU6wqAib3BlcmF0b3IiLMKgdmFsdWU6wqAiPSJ9CiAgICAgICAgICAvLzM6wqB7dHlwZTrCoCJ2YWx1ZSIswqB2YWx1ZTrCoCJIZWxsbyJ9CiAgICAgICAgICB2YXIgaGFuZGxlZF92YXJpYWJsZSA9IGhhbmRsZVZhcmlhYmxlKGVsZW1lbnQsIHRva2VucywgY2xlYW5lZF9zb3VyY2VkYXRhLCBpLCBuZXh0RWwsIHByZXZFbCk7CiAgICAgICAgICB2YXIgaCA9IGhhbmRsZWRfdmFyaWFibGU7CgogICAgICAgICAgaWYgKGggIT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgaC50eXBlID09PSAndmFyaWFibGUnID8gUHVzaFZhcmlhYmxlKGgsIHRva2VucykgOiBjb25zb2xlLmxvZygiZXJyb3IgaW4gc2V0dGluZyAiLmNvbmNhdChlbGVtZW50KSk7CiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlLCAiZXJyb3IgaW4gc2V0dGluZyAiLmNvbmNhdChlbGVtZW50KSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KCiAgICAgICAgICBicmVhazsKICAgICAgICAvL1B1c2ggdmFyaWFibGVzIHRvIHRva2VucwoKICAgICAgICBjYXNlICdOVU1CRVInOgogICAgICAgICAgUHVzaE51bWJlcihlbGVtZW50LCB0b2tlbnMpOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgLy9QdXNoIEVtcHR5U3RyaW5ncyB0byB0b2tlbnMKCiAgICAgICAgY2FzZSAnRU1QVFlfU1RSSU5HJzoKICAgICAgICAgIC8vSW4gc29tZSBjYXNlcyBlbXB0eSBzdHJpbmdzIHdpbGwgYmUgbW9kaWZpZWQgaW50byBzb21ldGhpbmcgbGlrZSAiJyIgb3IgJyInCiAgICAgICAgICAvL1dlIGNvbnZlcnQgaXQgYmFjayB0byAiICIKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIHZhciBlID0gZWxlbWVudDsKICAgICAgICAgICAgZSA9IGUubGVuZ3RoID4gMSAmJiAoZS5jaGFyQXQoMCkgPT09ICInIiB8fCBlLmNoYXJBdCgwKSA9PT0gJyInKSA/IGUgPSBlLnJlcGxhY2UoL1snIl0rL2csICcnKSA6IGUgPSAnICc7CiAgICAgICAgICAgIFB1c2hWYXJpYWJsZVZhbHVlKGUsIHRva2Vucyk7CiAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUsICJFcnJvciBpbiBzZXR0aW5nIEVtcHR5IHN0cmluZyAiLmNvbmNhdChlbGVtZW50KSk7CiAgICAgICAgICB9CgogICAgICAgICAgYnJlYWs7CiAgICAgICAgLy9QdXNoIElucHV0IHRvIHRva2VucwogICAgICAgIC8vRm9ybWF0OiB7dHlwZTrCoCJBY2NlcHRJbnB1dCIswqB2YWx1ZTrCoCIgIizCoEFjY2VwdEFzOsKgIk1lc3NhZ2UifQoKICAgICAgICBjYXNlICdJTlBVVCc6CiAgICAgICAgICB0cnkgewogICAgICAgICAgICBQdXNoSW5wdXQoZWxlbWVudCwgdG9rZW5zLCBjbGVhbmVkX3NvdXJjZWRhdGEsIGkpOwogICAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICBjb25zb2xlLmxvZyhlLCAiRXJyb3IgaW4gc2V0dGluZyBJbnB1dCAiLmNvbmNhdChlbGVtZW50KSk7CiAgICAgICAgICB9CgogICAgICAgICAgYnJlYWs7CiAgICAgICAgLy9QdXNoIG9wZXJhdG9ycyB0byB0b2tlbnMuIFRoZSBhY2NlcHRlZCBvcGVyYXRvcnMgYXJlID0sfSx7CiAgICAgICAgLy9Gb3JtYXQ6wqB7dHlwZTrCoCJvcGVyYXRvciIswqB2YWx1ZTrCoCI9In0KCiAgICAgICAgY2FzZSAnT1BFUkFUT1InOgogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgUHVzaE9wZXJhdG9yKGVsZW1lbnQsIHRva2Vucyk7CiAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUsICJFcnJvciBpbiBzZXR0aW5nIG9wZXJhdG9yICIuY29uY2F0KGVsZW1lbnQpKTsKICAgICAgICAgIH0KCiAgICAgICAgICBicmVhazsKICAgICAgICAvL1B1c2gga2V5b3dyZHMgdG8gdG9rZW5zLiBUaGUgYWNjZXB0ZWQga2V5d29yZHMgaXMg4KSm4KS/4KSW4KS+4KSPCiAgICAgICAgLy9Gb3JtYXQ6IHt0eXBlOsKgImtleXdvcmQiLMKgdmFsdWU6wqBBY3RpdmVMYW5ndWdhZUtleXdvcmRzLlByaW50fQoKICAgICAgICBjYXNlICdQUklOVCc6CiAgICAgICAgICB0cnkgewogICAgICAgICAgICBQdXNoS2V5d29yZChlbGVtZW50LCB0b2tlbnMpOwogICAgICAgICAgICB2YXIgRXhwcmVzc2lvbnRvUHJpbnQgPSBuZXh0RWw7CgogICAgICAgICAgICBpZiAoIWlzUmVhbFRpbWVQcmludE11bHRpcGxlU3RyaW5nKEV4cHJlc3Npb250b1ByaW50KSkgewogICAgICAgICAgICAgIFB1c2hFeHByZXNzaW9uKEV4cHJlc3Npb250b1ByaW50LCB0b2tlbnMpOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUsICJFcnJvciBpbiBwcmludGluZyAiLmNvbmNhdChlbGVtZW50KSk7CiAgICAgICAgICB9CgogICAgICAgICAgYnJlYWs7CiAgICAgICAgLy9QdXNoIGZ1bmN0aW9ucyB0byB0b2tlbnMKICAgICAgICAvL0Zvcm1hdDoge3R5cGU6ICJmdW5jdGlvbiIsIHZhbHVlOiAiRmlyc3QiLCBhcmd1bWVudHM6IEFycmF5KDIpLCBGdW5jdGlvbkludm9jYXRpb25FeGlzdHM6IGZhbHNlLCBGdW5jdGlvblN0YWNrOiBBcnJheSgwKSwg4oCmfQoKICAgICAgICBjYXNlICdGVU5DVElPTic6CiAgICAgICAgICB0cnkgewogICAgICAgICAgICBQdXNoRnVuY3Rpb25EYXRhKGVsZW1lbnQsIHRva2VucywgY2xlYW5lZF9zb3VyY2VkYXRhLCBpKTsKICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgY29uc29sZS5sb2coZSwgIkVycm9yIGluIGhhbmRsaW5nIGZ1bmN0aW9uICIuY29uY2F0KGVsZW1lbnQpKTsKICAgICAgICAgIH0KCiAgICAgICAgICBicmVhazsKICAgICAgICAvLyBQdXNoIGFycmF5IHRvIHRva2VucwoKICAgICAgICBjYXNlICdBUlJBWSc6CiAgICAgICAgICAvL0Zvcm1hdDoge3R5cGU6ICJBcnJheSIsIHZhbHVlOiAiW10ifQogICAgICAgICAgLy9pZiBlbXB0eSBhcnJheSBlbHNlIGJ1aWxkIHRoZSBhcnJheSAoVG8gY29udmVydCAnWycsMSwyLDMsNCwnXScgIGludG8gWzEsMiwzLDRdCiAgICAgICAgICB0cnkgewogICAgICAgICAgICB2YXIgX2UgPSBlbGVtZW50OwogICAgICAgICAgICBfZS5jaGFyQXQoX2UubGVuZ3RoIC0gMSkgPT09ICddJyA/IFB1c2hBcnJheShfZSwgdG9rZW5zKSA6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICB2YXIgQnVpbHRBcnJheSA9IEJ1aWxkQXJyYXkoX2UsIGksIGNsZWFuZWRfc291cmNlZGF0YSk7CiAgICAgICAgICAgICAgUHVzaEFycmF5KEJ1aWx0QXJyYXksIHRva2Vucyk7CiAgICAgICAgICAgIH07CiAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUsICJFcnJvciBpbiBoYW5kbGluZyBBcnJheSAiLmNvbmNhdChlbGVtZW50KSk7CiAgICAgICAgICB9CgogICAgICAgICAgYnJlYWs7CiAgICAgICAgLy9Gb3Igb3BlcmF0aW9ucyBsaWtlIE51bWJlcnNbYV09YQogICAgICAgIC8vRm9ybWF0OiB7dHlwZTrCoCJTZXRBcnJheUluZGV4VmFsdWUiLMKgdmFsdWU6wqAiRmlib25hY2NpW2FdIizCoFZhbHVlVG9TZXQ6wqAiYSJ9CgogICAgICAgIGNhc2UgJ1NFVF9BUlJBWV9JTkRFWCc6CiAgICAgICAgICB0cnkgewogICAgICAgICAgICBQdXNoU2V0QXJyYXlJbmRleFZhbHVlKGVsZW1lbnQsIHRva2VucywgY2xlYW5lZF9zb3VyY2VkYXRhLCBpKTsKICAgICAgICAgICAgY2xlYW5lZF9zb3VyY2VkYXRhLnNwbGljZShpICsgMSwgMSk7CiAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUsICJFcnJvciBpbiBzZXR0aW5nIGFycmF5IGluZGV4IHZhbHVlICIuY29uY2F0KGVsZW1lbnQpKTsKICAgICAgICAgIH0KCiAgICAgICAgICBicmVhazsKICAgICAgICAvL0ZvciBvcGVyYXRpb25zIGxpa2UgYT1OdW1iZXJzW2FdLCByZXZlcnNlIG9mIGFib3ZlCiAgICAgICAgLy9Gb3JtYXQ6IHt0eXBlOsKgIkdldEFycmF5SW5kZXhWYWx1ZSIswqB2YWx1ZTrCoCJGaWJvbmFjY2lbYS0yXSJ9CgogICAgICAgIGNhc2UgJ0dFVF9BUlJBWV9JTkRFWCc6CiAgICAgICAgICB0cnkgewogICAgICAgICAgICBQdXNoR2V0QXJyYXlJbmRleFZhbHVlKGVsZW1lbnQsIHRva2VucywgY2xlYW5lZF9zb3VyY2VkYXRhLCBpKTsKICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgY29uc29sZS5sb2coZSwgIkVycm9yIGluIGdldHRpbmcgYXJyYXkgaW5kZXggdmFsdWUgIi5jb25jYXQoZWxlbWVudCkpOwogICAgICAgICAgfQoKICAgICAgICAgIGJyZWFrOwogICAgICAgIC8vUHVzaCBjb25kaXRpb25zIHRvIHRva2Vucy4gVGhlIGFjY2VwdGVkIGtleXdvcmRzIGFyZSDgpIXgpJfgpLAsIOCknOCkrOCkpOCklSwg4KSF4KSo4KWN4KSv4KSl4KS+CiAgICAgICAgLy8gRm9ybWF0OiB7dHlwZTrCoCJjb25kaXRpb25hbGtleXdvcmQiLMKgdmFsdWU6wqAi4KSF4KSX4KSwIn0KICAgICAgICAvL1B1c2ggd2hpbGUgbG9vcHMgdG8gdG9rZW5zCiAgICAgICAgLy9Gb3JtYXQ6IHt0eXBlOiAiV2hpbGVMb29wU3RhcnQiLCB2YWx1ZTogIuCknOCkrOCkpOCklSJ9LCB7dHlwZTogImNvbmRpdGlvbiIsIHZhbHVlOiAiY291bnQ8MjUifQoKICAgICAgICBjYXNlICdDT05ESVRJT05BTF9LRVlXT1JEJzoKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIGlzV2hpbGVMb29wKGVsZW1lbnQpID8gUHVzaFdoaWxlTG9vcChlbGVtZW50LCB0b2tlbnMpIDogUHVzaENvbmRpdGlvbmFsS2V5d29yZChlbGVtZW50LCB0b2tlbnMpOyAvL1RoaXMgaXMgaG93IHdlIHB1c2ggY29uZGl0aW9ucyBlbmNvdW50ZXJlZCBpbiB0aGUgc291cmNlY29kZQogICAgICAgICAgICAvL0Zvcm1hdDp7dHlwZTrCoCJjb25kaXRpb24iLMKgdmFsdWU6wqAiYTwzIn0KCiAgICAgICAgICAgIHZhciBmb3VuZGNvbmRpdGlvbiA9IEJ1aWxkQ29uZGl0aW9uKGVsZW1lbnQsIGksIGNsZWFuZWRfc291cmNlZGF0YSk7IC8vUHVzaCBjb25kaXRpb25zIHRvIHRva2VucyBhcnJheQoKICAgICAgICAgICAgaWYgKGZvdW5kY29uZGl0aW9uICE9ICcnKSB7CiAgICAgICAgICAgICAgUHVzaENvbmRpdGlvbihmb3VuZGNvbmRpdGlvbiwgdG9rZW5zKTsKICAgICAgICAgICAgfQogICAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICBjb25zb2xlLmxvZyhlLCAiRXJyb3IgaW4gb3BlcmF0aW5nIG9uIGNvbmRpdGlvbmFscyAiLmNvbmNhdChlbGVtZW50KSk7CiAgICAgICAgICB9CgogICAgICAgICAgYnJlYWs7CiAgICAgICAgLy9GaW5kaW5nIG9wZXJhdGlvbnMgbGlrZSBOdW1iZXJzLuCkquClgeCktih4KQogICAgICAgIC8vRm9ybWF0OiB7dHlwZTogIlB1c2hUb0FycmF5IiwgdmFsdWU6ICJOdW1iZXJzLuCkquClgeCktih4KSJ9CgogICAgICAgIGNhc2UgJ1BVU0hfVE9fQVJSQVknOgogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgUHVzaFRvQXJyYXkoZWxlbWVudCwgdG9rZW5zKTsKICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgY29uc29sZS5sb2coZSwgIkVycm9yIGluIHB1c2hpbmcgdGhlIHZhbHVlcyB0byBhcnJheSAiLmNvbmNhdChlbGVtZW50KSk7CiAgICAgICAgICB9CgogICAgICAgICAgYnJlYWs7CiAgICAgICAgLy9QdXNoIEZvciBsb29wIHRvIHRva2VucwogICAgICAgIC8vIEZvcm1hdDoKICAgICAgICAvLyB7dHlwZTrCoCJGb3JMb29wU3RhcnQiLMKgdmFsdWU6wqAi4KSm4KWB4KS54KSw4KS+4KSTIn0KICAgICAgICAvL8Kge3R5cGU6wqAiRm9yTG9vcEFyZ3VtZW50cyIswqBpdGVyYXRvcjrCoCJhIizCoHZhbHVlOsKgIigwLDI1KSIswqBpdGVyYXRpb25TdGFydDrCoCIwIizCoGl0ZXJhdGlvbkVuZDrCoCIyNSJ9CgogICAgICAgIGNhc2UgJ0ZPUl9MT09QJzoKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIFB1c2hGb3JMb29wKGVsZW1lbnQsIHRva2Vucyk7CiAgICAgICAgICAgIFB1c2hGb3JMb29wQXJ1Z3VtZW50cyhlbGVtZW50LCBjbGVhbmVkX3NvdXJjZWRhdGEsIGksIHRva2Vucyk7CiAgICAgICAgICAgIG1lbW9yeS5wdXNoKHsKICAgICAgICAgICAgICBuYW1lOiBuZXh0RWwsCiAgICAgICAgICAgICAgdmFsdWU6IDAsCiAgICAgICAgICAgICAgdHlwZTogJ0Zvckxvb3BJdGVyYXRvcicKICAgICAgICAgICAgfSk7CiAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUsICJFcnJvciBpbiBvcGVyYXRpbmcgb24gZm9yIGxvb3AgIi5jb25jYXQoZWxlbWVudCkpOwogICAgICAgICAgfQoKICAgICAgICAgIGJyZWFrOwogICAgICAgIC8vUHVzaGluZyBiYXNpYyBDYWxjdWxhdGlvbnMgbGlrZSAnbGVuZ3RoLTEnIHRvIHRva2VucwogICAgICAgIC8vRm9ybWF0OiB7dHlwZTrCoCJDYWxjdWxhdGlvbiIswqB2YWx1ZTrCoCJsZW5ndGgtMSJ9CgogICAgICAgIGNhc2UgJ0NBTENVTEFUSU9OJzoKICAgICAgICAgIC8qIHJlZCB6b25lCiAgICAgICAgICAgICBpZiAobmV4dEVsICE9IHVuZGVmaW5lZCkgewogICAgICAgICAgICAvLyB0aGlzIGlzIHRvIHBlcmZvcm0gbG9uZyBjYWxjdWxhdGlvbnMgbGlrZSBBdmVyYWdlQWdlPShhZ2VvbmUrYWdldHdvKS8yICsgKGFnZW9uZSthZ2V0d28pKjIKICAgICAgICAgICAgICAgd2hpbGUgKGlzQ2FsY3VsYXRpb24oY2xlYW5lZF9zb3VyY2VkYXRhW2ldKSkgewogICAgICAgICAgICAgIGVsID0gZWwgKyBjbGVhbmVkX3NvdXJjZWRhdGFbaV07CiAgICAgICAgICAgICAgICAgaSsrOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICAgICBjb25zb2xlLmxvZygiZWw6IiwgZWwpOwogICAgICAgICAgKi8KCiAgICAgICAgICAvKmVycm9yIHByb25lKi8KICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIHZhciBpc011bHRpQ2FsY3VsYXRpb24gPSBmdW5jdGlvbiBpc011bHRpQ2FsY3VsYXRpb24oYykgewogICAgICAgICAgICAgIHZhciBvcCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJyorLy0nOwoKICAgICAgICAgICAgICBpZiAoYy5pbmNsdWRlcygnKCcpICYmIGMuaW5jbHVkZXMoJyknKSkgewogICAgICAgICAgICAgICAgdmFyIHMgPSBjLnNwbGl0KCcnKTsKICAgICAgICAgICAgICAgIHMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHsKICAgICAgICAgICAgICAgICAgaWYgKG9wLmluY2x1ZGVzKGVsKSkgewogICAgICAgICAgICAgICAgICAgIGQgPSBkICsgMTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSk7CgogICAgICAgICAgICAgICAgaWYgKGQgPiAxKSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfTsKCiAgICAgICAgICAgIHZhciBlbCA9IGVsZW1lbnQ7CiAgICAgICAgICAgIHZhciBjYWwgPSAnJzsKICAgICAgICAgICAgdmFyIGNvdW50ID0gMDsgLy8gICBmdW5jdGlvbiBmaW5kQ2FsY3VsYXRpb24oY2xlYW5lZF9zb3VyY2VkYXRhLCBpKSB7CgogICAgICAgICAgICB2YXIgeCA9IGk7CiAgICAgICAgICAgIHZhciBkID0gMDsKCiAgICAgICAgICAgIHdoaWxlIChpc0NhbGN1bGF0aW9uKGNsZWFuZWRfc291cmNlZGF0YVt4XSkgfHwgY2xlYW5lZF9zb3VyY2VkYXRhW3hdID09ICcrJykgewogICAgICAgICAgICAgIGNhbCA9IGNhbCArIGNsZWFuZWRfc291cmNlZGF0YVt4XTsKICAgICAgICAgICAgICBjb3VudCArPSAxOwogICAgICAgICAgICAgIHgrKzsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgdmFyIG11bHRpQ2FsID0gaXNNdWx0aUNhbGN1bGF0aW9uKGNhbCk7IC8vICBjb25zb2xlLmxvZygieCIsIHgsIGkpOwoKICAgICAgICAgICAgc2tpcFBhcnNpbmcgPSBjb3VudCAtIDE7IC8vIGNhbCA9IFJlbW92ZUJyYWNrZXRzKGNhbCk7CiAgICAgICAgICAgIC8vbGV0IGNfZWwgPSBSZW1vdmVCcmFja2V0cyhjYWwpOwogICAgICAgICAgICAvLyAgbGV0IGNhbCA9IGZpbmRDYWxjdWxhdGlvbigpOwogICAgICAgICAgICAvLyB0byBzdG9wIHByZXZlbnRpb24gb2YgZXhwcmVzc2lvbnMgbGlrZSBpcyIrIGdldHRpbmcgYWRkZWQgYXMgYSBjYWxjdWxhdGlvbgoKICAgICAgICAgICAgIWNhbC5pbmNsdWRlcygnIicpICYmICFbJy8nLCAnKicsICInIiwgJyInXS5pbmNsdWRlcyhlbC5jaGFyQXQoMCkpID8gUHVzaENhbGN1bGF0aW9uKGNhbCwgdG9rZW5zLCBjbGVhbmVkX3NvdXJjZWRhdGEsIGksIG11bHRpQ2FsKSA6IGNvbnNvbGUubG9nKCJpbXB1cmUgY2FsY3VsYXRpb24gdGVybXMgIi5jb25jYXQoZWwpKTsKICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgY29uc29sZS5sb2coZSwgIkVycm9yIGluIGNvbXBsZXRpbmcgY2FsY3VsYXRpb24gIi5jb25jYXQoZWxlbWVudCkpOwogICAgICAgICAgfQoKICAgICAgICAgIGJyZWFrOwoKICAgICAgICBjYXNlICdSRUFMVElNRV9QUklOVCc6CiAgICAgICAgICAvL2ZpbmRpbmcgb3BlcmF0aW9ucyBsaWtlIHByaW50KHggKyAneScpLiBUaGUgUmVhbFRpbWVQcmludCBvcGVyYXRpb25zCiAgICAgICAgICAvL0Zvcm1hdDoge3R5cGU6wqAidmFsdWUiLMKgdmFsdWU6wqAiKCdSZXZlcnNlZCBTdHJpbmctJysgUmV2ZXJzZVN0cmluZykiLMKgbW9kZTrCoCJSZWFsVGltZVByaW50In0KICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIHZhciBfaGFuZGxlUmVhbHRpbWVQcmludCA9IGhhbmRsZVJlYWx0aW1lUHJpbnQoY2xlYW5lZF9zb3VyY2VkYXRhLCBpKSwKICAgICAgICAgICAgICAgIGZvdW5kU3RyaW5nID0gX2hhbmRsZVJlYWx0aW1lUHJpbnQuZm91bmRTdHJpbmcsCiAgICAgICAgICAgICAgICBza2lwID0gX2hhbmRsZVJlYWx0aW1lUHJpbnQuc2tpcDsKCiAgICAgICAgICAgIFB1c2hSZWFsVGltZVByaW50T3BlcmF0aW9uKGZvdW5kU3RyaW5nLCB0b2tlbnMpOwogICAgICAgICAgICBza2lwUGFyc2luZyA9IHNraXA7CiAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUsICJFcnJvciBpbiByZWFsIHRpbWUgcHJpbnQgIi5jb25jYXQoZWxlbWVudCkpOwogICAgICAgICAgfQoKICAgICAgICAgIGJyZWFrOwoKICAgICAgICBjYXNlICdTVFJJTkcnOgogICAgICAgICAgLy9zdG9yaW5nIG9ubHkgdGhlIHN0cmluZyB2YWx1ZXMgdG8gdG9rZW5zICggbm90IHRoZSBzdHJpbmdzIGluIHByaW50IHN0YXRlbWVudHMpCiAgICAgICAgICB0cnkgewogICAgICAgICAgICB2YXIgcyA9IEJ1aWxkU3RyaW5nKGVsZW1lbnQsIGksIGNsZWFuZWRfc291cmNlZGF0YSk7CiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoL1snIl0rL2csICcnKTsKICAgICAgICAgICAgIXMuaW5jbHVkZXMoQWN0aXZlTGFuZ3VnYWVLZXl3b3Jkcy5QcmludCkgPyBQdXNoU3RyaW5nKHMsIHRva2VucykgOiBjb25zb2xlLmxvZygiZXJyb3IgaW4gcHVzaGluZyBzdHJpbmcgIi5jb25jYXQoKHMsIGVsZW1lbnQpKSk7CiAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUsICJlcnJvciBpbiBvcGVyYXRpbmcgb24gc3RyaW5nICIuY29uY2F0KGVsZW1lbnQpKTsKICAgICAgICAgIH0KCiAgICAgICAgICBicmVhazsKICAgICAgICAvL0FuIGV4dGVuc2lvbiBvZiBpc1ByaW50T3BlcmF0aW9uKCkgZnVuY3Rpb24KICAgICAgICAvLyBOZWVkcyBpbXByb3ZlbWVudAoKICAgICAgICAvKiAgICAgZWxzZSBpZiAoL14oPz0uKj/gpKbgpL/gpJbgpL7gpI8pKD89LipbYS16XSkvLnRlc3QoZWxlbWVudCkpIHsKICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICBQdXNoS2V5d29yZChlbGVtZW50LnNsaWNlKDAsIDYpLCB0b2tlbnMpOyAvL1B1c2hpbmcgcHJpbnQga2V5d29yZCBvbmx5CiAgICAgICAgICAgICAgICAgICAgIFB1c2hFeHByZXNzaW9uKGVsZW1lbnQuc2xpY2UoNiksIHRva2Vucyk7IC8vUHVzaGluZyByZW1haW5pbmcgZXhwcmVzc2lvbiBsaWtlIChhKSwgKE1lc3NhZ2UpIGV0YwogICAgICAgICAgICB9CiAgICAgICAgICAgICovCiAgICAgICAgLy9lcnJvciBwcm9uZSBjaGFuZ2UgbWFkZSBoZXJlLSBQdXNoaW5nIGV4cHJlc3Npb24gaW4gaGVyZQogICAgICAgIC8vVXNlZCB0byBwdXNoIGZ1bmN0aW9ucyBhbmQgZXhwcmVzc2lvbnMKICAgICAgICAvL1VubmVjZXNzYXJ5IGRhdGEgaXMgYmVpbmcgcGFzc2VkIHRocm91Z2gga2FsYWFtLgogICAgICAgIC8vVGhpcyB3YXMgY3JlYXRlZCBmb3IgYSB0ZW1wb3JhcnkgZml4CgogICAgICAgIGNhc2UgJ0ZVTkNUSU9OX0NBTEwnOgogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgdmFyIENoZWNrRnVuY3Rpb25FeHByZXNzaW9uID0gZWxlbWVudC5zcGxpdCgnKCcpOwogICAgICAgICAgICB2YXIgcGFzc2VkVmFsdWVzID0gUmVtb3ZlQnJhY2tldHMoQ2hlY2tGdW5jdGlvbkV4cHJlc3Npb25bMV0pOwogICAgICAgICAgICBwYXNzZWRWYWx1ZXMgPSBwYXNzZWRWYWx1ZXMuc3BsaXQoJywnKTsKICAgICAgICAgICAgUHVzaEZ1bmN0aW9uRXhlY3V0aW9uKGVsZW1lbnQsIHRva2VucywgY2xlYW5lZF9zb3VyY2VkYXRhLCBpLCBwYXNzZWRWYWx1ZXMpOwogICAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICBjb25zb2xlLmxvZyhlLCAiZXJyb3IgaW4gcHVzaGluZyBmdW5jdGlvbiBleGVjdXRpb24gIi5jb25jYXQoZWxlbWVudCkpOwogICAgICAgICAgfQoKICAgICAgICAgIGJyZWFrOwoKICAgICAgICBjYXNlICdOQVRJVkVfT1BFUkFUSU9OJzoKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIFB1c2hOYXRpdmVPcGVyYXRpb24oZWxlbWVudCwgdG9rZW5zKTsKICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgY29uc29sZS5sb2coZSwgImVycm9yIGluIHB1c2hpbmcgbmF0aXZlIG9wZXJhaW9uICIuY29uY2F0KGVsZW1lbnQpKTsKICAgICAgICAgIH0KCiAgICAgICAgICBicmVhazsKCiAgICAgICAgY2FzZSAnQVJSQVlfUFVTSCc6CiAgICAgICAgICB0cnkgewogICAgICAgICAgICBQdXNoQXJyYXkoZWxlbWVudCwgdG9rZW5zKTsKICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgY29uc29sZS5sb2coZSwgImVycm9yIGluIGFycmF5IHB1c2ggIi5jb25jYXQoZWxlbWVudCkpOwogICAgICAgICAgfQoKICAgICAgICAgIGJyZWFrOwogICAgICB9CiAgICB9OyAvL21ha2luZyBzZW5zZSBvZiB0b2tlbnMgYXJyYXkgY29taW5nIGZyb20gX3BhcnNlci4KCgogICAgdmFyIGludGVycHJldFRva2VuID0gZnVuY3Rpb24gaW50ZXJwcmV0VG9rZW4odCwgaiwgbWVtb3J5KSB7CiAgICAgIHNraXBJbnRlcnByZXRhdGlvbiA9IDA7CiAgICAgIHZhciBtdXRhYmxlX3Rva2VucyA9IHQ7CiAgICAgIHZhciB0b2tlbiA9IG11dGFibGVfdG9rZW5zW2pdLnZhbHVlOwogICAgICB2YXIgdG9rZW5fdHlwZSA9IG11dGFibGVfdG9rZW5zW2pdLnR5cGU7CiAgICAgIHZhciB0b2tlbl9zdWJ0eXBlID0gbXV0YWJsZV90b2tlbnNbal0uc3VidHlwZTsKICAgICAgdmFyIHR5cGUgPSB0b2tlbiA9PT0gQWN0aXZlTGFuZ3VnYWVLZXl3b3Jkcy5QcmludCB8fCB0b2tlbl90eXBlID09PSAnb3BlcmF0b3InID8gdG9rZW5fc3VidHlwZSA6IHRva2VuX3R5cGU7IC8vbmVlZCB0byBza2lwIG92ZXIgc29tZSB1bm5jZXNzYXJ5IHR5cGVzCiAgICAgIC8vb3BlcmF0b3JzIGFyZSBub3Qgd29ya2luZyBjb3JyZWN0bHkKICAgICAgLy8gbm8gbmVlZCB0byBpbnRlcnByZXQgb3ZlciBub24tdHlwZXMKCiAgICAgIHRyeSB7CiAgICAgICAgaWYgKGlzSW50ZXJwcmV0YWJsZVR5cGUodHlwZSkpIHsKICAgICAgICAgIHN3aXRjaCAodHlwZSkgewogICAgICAgICAgICBjYXNlICdTZXRBcnJheUluZGV4VmFsdWUnOgogICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIFNldEFycmF5SW5kZXhWYWx1ZShtdXRhYmxlX3Rva2VucywgaiwgaiwgbWVtb3J5LCB0b2tlbnMsIE9yaWdpbmFsSXRlcmF0b3IsIGl0ZXJhdG9yLCBFeGVjdXRpb25TdGFjaywgTGluZWJ5bGluZVNvdXJjZWRhdGEpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgIGNhc2UgJ2Fzc2lnbm1lbnQnOgogICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIEFzc2lnbm9yVXBkYXRlVmFsdWVzKG11dGFibGVfdG9rZW5zLCBqLCBtZW1vcnksIGl0ZXJhdG9yLCBPcmlnaW5hbEl0ZXJhdG9yLCBrYWxhYW0sIEV4ZWN1dGlvblN0YWNrLCBMaW5lYnlsaW5lU291cmNlZGF0YSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUKCiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIC8vdHlwZT1hc3NpZ25tZW50CgogICAgICAgICAgICBjYXNlICdQdXNoVG9BcnJheSc6CiAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgQWRkRWxlbWVudFRvQXJyYXkobXV0YWJsZV90b2tlbnMsIGosIG1lbW9yeSwgRXhlY3V0aW9uU3RhY2ssIExpbmVieWxpbmVTb3VyY2VkYXRhKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICBjYXNlICdBY2NlcHRJbnB1dCc6CiAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgQWNjZXB0SW5wdXRhbmRTZXRWYWx1ZShtdXRhYmxlX3Rva2VucywgaiwgbWVtb3J5LCBFeGVjdXRpb25TdGFjaywgTGluZWJ5bGluZVNvdXJjZWRhdGEpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgLy9XaGVuZXZlciB3ZSBlbmNvdW50ZXIgYSBmdW5jdGlvbiwgd2UgY3JlYXRlIGEgc2VwZXJhdGUgZXhlY3V0aW9uIGNvbnRleHQKCiAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzoKICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAvL1dlIGFyZSBwcmVwYXJpbmcgdGhlIHJlcXVpcmVkIGRhdGEgdG8gZXhlY3V0ZSBhIGZ1bmN0aW9uIGNhbGwgbGF0ZXIgaW4gdGhlIHByZ3JvYW0KICAgICAgICAgICAgICAgIC8vZnVuY3Rpb25zb3VyY2VkYXRhIGluY2x1ZGVzIGFsbCB0aGUgdG9rZW5zIGZyb20gdG9rZW5zIGFycmF5IHdoaWNoIGJlbG9uZ3MgdG8gYSBwYXJ0aWN1bGFyIGZ1bmN0aW9uCiAgICAgICAgICAgICAgICBza2lwSW50ZXJwcmV0YXRpb24gPSAwOyAvL1dlIGZpbmQgc2VsZiByYW5nZSBvciBhIGZ1bmN0aW9uIGJsb2NrIHRocm91Z2ggSGFuZGxlQmxvY2tzIGZ1bmN0aW9uCgogICAgICAgICAgICAgICAgdmFyIF9wcmVwYXJlRnVuY3Rpb24gPSBwcmVwYXJlRnVuY3Rpb24obXV0YWJsZV90b2tlbnMsIGopLAogICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uU291cmNlRGF0YSA9IF9wcmVwYXJlRnVuY3Rpb24uZnVuY3Rpb25Tb3VyY2VEYXRhOwoKICAgICAgICAgICAgICAgIG11dGFibGVfdG9rZW5zW2pdLlNvdXJjZURhdGEgPSBmdW5jdGlvblNvdXJjZURhdGE7CgogICAgICAgICAgICAgICAgdmFyIF9tZXNzYWdlID0gIlx1MDkwN1x1MDkzOCAiLmNvbmNhdChBY3RpdmVMYW5ndWdhZUtleXdvcmRzLkZ1bmN0aW9uLCAiIFx1MDkxNVx1MDkzRSBcdTA5MjhcdTA5M0VcdTA5MkUgIikuY29uY2F0KHRva2VuLCAiIFx1MDkzOVx1MDk0OCBcdTA5MUNcdTA5M0ZcdTA5MzhcdTA5NDcgXHUwOTM5XHUwOTJFIFx1MDkxNVx1MDk0Qlx1MDkyMSBcdTA5MkVcdTA5NDdcdTA5MDIgXHUwOTJDXHUwOTNFXHUwOTI2IFx1MDkyRVx1MDk0N1x1MDkwMiBORVcgVkFMVUVTIFx1MDkyQVx1MDkzRVx1MDkzOCBcdTA5MTVcdTA5MzBcdTA5MTVcdTA5NDcgXHUwOTA5XHUwOTJBXHUwOTJGXHUwOTRCXHUwOTE3IFx1MDkxNVx1MDkzMCBcdTA5MzhcdTA5MTVcdTA5MjRcdTA5NDcgXHUwOTM5XHUwOTQ4fCIpOwoKICAgICAgICAgICAgICAgIHZhciBleHByZXNzaW9uID0gIiIuY29uY2F0KEFjdGl2ZUxhbmd1Z2FlS2V5d29yZHMuRnVuY3Rpb24sICIgIikuY29uY2F0KHRva2VuKTsKICAgICAgICAgICAgICAgIHZhciBkZXNjcmlwdGlvbiA9ICcg4KSP4KSVIOCkteCkv+CktuCkv+Ckt+CljeCknyDgpLDgpYLgpKog4KS44KWHIOCksuCkv+CkluCkviDgpJfgpK/gpL4g4KSV4KWL4KShIOCknOCkv+CkuOCkleCkviDgpLngpK4g4KSs4KS+4KSwIOCkrOCkvuCksCDgpIngpKrgpK/gpYvgpJcg4KSV4KSwIOCkuOCkleCkpOClhyDgpLngpYggfCAnOwogICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gZmluZHRva2VuUG9zaXRpb25pbkNvZGUoTGluZWJ5bGluZVNvdXJjZWRhdGEsIGV4cHJlc3Npb24sIHRydWUpOwoKICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiAhPSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgICAgICAgQWRkdG9FeGVjdXRpb25TdGFjayhFeGVjdXRpb25TdGFjaywgQWN0aXZlTGFuZ3VnYWVLZXl3b3Jkcy5GdW5jdGlvbiwgZGVzY3JpcHRpb24sIG11dGFibGVfdG9rZW5zW2pdLnZhbHVlLCBmdW5jdGlvblNvdXJjZURhdGEsIF9tZXNzYWdlLCBwb3NpdGlvbik7CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgc2tpcEludGVycHJldGF0aW9uID0gZnVuY3Rpb25Tb3VyY2VEYXRhLmxlbmd0aDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIC8vV2UgYXJlIG91dCBvZiB0aGUgZnVjbnRpb24gZXhlY3V0aW9uIGNvbnRleHQgYW5kIGJhY2sgdG8gZ2xvYmFsIGV4ZWN1dGlvbiBjb250ZXh0CgogICAgICAgICAgICBjYXNlICdjb25kaXRpb24nOgogICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIHZhciBfZWxlbWVudCA9IHRva2VuOwogICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2U7IC8vdGhpcyBmdW5jdGlvbiBpcyB0aGUgZmlyc3Qgc3RlcCB0byBjYWxjdWxhdGUgdmFsdWUgb2Ygb3BlcmF0aW9ucyBsaWtlIOCkheCkl+CksCAoYWdlb25lPT09MTAgJiYgQXZlcmFnZUFnZTwxMDAwICYmIGFnZXR3bz4xMDAgfHwgYWdlb25lPT09MTApIE9SIChhZ2VvbmU9PT0xMCApCgogICAgICAgICAgICAgICAgdmFyIENvbmRpdGlvblZhbHVlID0gR2V0Q29uZGl0aW9uVmFsdWUoX2VsZW1lbnQsIG1lbW9yeSwgaik7CiAgICAgICAgICAgICAgICBrYWxhYW0uTGFzdENvbmRpdGlvblZhbHVlLnB1c2goQ29uZGl0aW9uVmFsdWUpOyAvL2lmIHZhbHVlIGlzIGZhbHNlLCBqdXN0IHNraXAgdGhlIGlmIGxvb3AgY29udGV4dCwgaWYgbm90IGl0IHdpbGwgYmUgcmFuIGluIGZpbmFsIHByaW50IG1vZHVsZQoKICAgICAgICAgICAgICAgIGlmICghQ29uZGl0aW9uVmFsdWUpIHsKICAgICAgICAgICAgICAgICAgLy8gIGxldCBJbml0aWFsaXplTG9vcCA9IHRva2Vucy5pbmRleE9mKG11dGFibGVfdG9rZW5zW2pdKTsKICAgICAgICAgICAgICAgICAgLy9IYW5kbGUgQmxvY2tzIGlzIGEgZnVuY3Rpb24gd2hpY2ggdGFrZXMgY2FyZSBvZiBuZXN0ZWQgYmxvY2sgYnkgdGFraW5nIGNhcmUgb2YgbmVzdGVkIHsgYW5kIH0gYnJhY2tldHMKICAgICAgICAgICAgICAgICAgLy9pdCB1c2VzIHRoZSBzdGFjayB0byBwdXNoIGFuZCBwb3AgYnJhY2tldHMgdG8gYWNjdXJhdGVseSBpZGVudGlmeSBzdGFydCBhbmQgdGhlIGVuZCBvZiB0aGUgYmxvY2sKICAgICAgICAgICAgICAgICAgdmFyIFJldHVybnZhbHVlID0gSGFuZGxlQmxvY2tzKG11dGFibGVfdG9rZW5zLCBqKTsgLy9hbW91bnQgdG8gc2tpcCBpZiBjb25kaXRpb24gaXMgZmFsc2UKCiAgICAgICAgICAgICAgICAgIHNraXBJbnRlcnByZXRhdGlvbiA9IFJldHVybnZhbHVlLmogLSBqOwogICAgICAgICAgICAgICAgICBtZXNzYWdlID0gIlx1MDkxNVx1MDkwMlx1MDkyMVx1MDk0MFx1MDkzNlx1MDkyOCAgIi5jb25jYXQoX2VsZW1lbnQsICIgICwgRkFMU0UoXHUwOTE3XHUwOTMyXHUwOTI0KSBcdTA5MzlcdTA5NEJcdTA5MjhcdTA5NDcgXHUwOTE1XHUwOTQ3IFx1MDkxNVx1MDkzRVx1MDkzMFx1MDkyOCBDT01QVVRFUiBcdTA5MDZcdTA5MTdcdTA5NDcgXHUwOTE1XHUwOTQ3IFx1MDkxNVx1MDk0Qlx1MDkyMSBcdTA5MTVcdTA5NEIgXHUwOTMwXHUwOTI4IFx1MDkyOFx1MDkzOVx1MDk0MFx1MDkwMiBcdTA5MTVcdTA5MzBcdTA5NDdcdTA5MTdcdTA5M0UgIik7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICBtZXNzYWdlID0gIlx1MDkxNVx1MDkwMlx1MDkyMVx1MDk0MFx1MDkzNlx1MDkyOCAiLmNvbmNhdChfZWxlbWVudCwgIiAgLCBUUlVFKFx1MDkzOFx1MDkyNFx1MDk0RFx1MDkyRikgXHUwOTM5XHUwOTRCXHUwOTI4XHUwOTQ3IFx1MDkxNVx1MDk0NyBcdTA5MTVcdTA5M0VcdTA5MzBcdTA5MjggQ09NUFVURVIgXHUwOTA2XHUwOTE3XHUwOTQ3IFx1MDkxNVx1MDk0NyBcdTA5MTVcdTA5NEJcdTA5MjEgXHUwOTE1XHUwOTRCIFx1MDkzMFx1MDkyOCBcdTA5MTVcdTA5MzBcdTA5NDdcdTA5MTdcdTA5M0UgIik7CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgdmFyIF9leHByZXNzaW9uID0gX2VsZW1lbnQ7CiAgICAgICAgICAgICAgICB2YXIgX2Rlc2NyaXB0aW9uID0gJ+Ckj+CklSBDZXJ0YWluIENvbmRpdGlvbiDgpJXgpYcg4KSk4KS54KSkIOCkleCli+CkoSBFeGVjdXRpb24g4KSV4KWLIEFsbG93IOCkleCksOCkpOCkviDgpLngpYjgpaQgJzsKICAgICAgICAgICAgICAgIF9leHByZXNzaW9uID0gR2V0Y2xlYW5lZEV4cHJlc3Npb24oX2V4cHJlc3Npb24pOwoKICAgICAgICAgICAgICAgIHZhciBfcG9zaXRpb24gPSBmaW5kdG9rZW5Qb3NpdGlvbmluQ29kZShMaW5lYnlsaW5lU291cmNlZGF0YSwgX2V4cHJlc3Npb24sIHRydWUpOwoKICAgICAgICAgICAgICAgIGlmIChfcG9zaXRpb24gIT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgICAgICAgIEFkZHRvRXhlY3V0aW9uU3RhY2soRXhlY3V0aW9uU3RhY2ssIEFjdGl2ZUxhbmd1Z2FlS2V5d29yZHMuSWYsIF9kZXNjcmlwdGlvbiwgX2VsZW1lbnQsIENvbmRpdGlvblZhbHVlLCBtZXNzYWdlLCBfcG9zaXRpb24pOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgLy9TbyB0aGF0IHdlIGRvbid0IHByaW50IGEgc2FtZSB2YWx1ZSB0d2ljZS4gRmlyc3QgaW4gZ2xvYmFsIGV4ZWN1dGlvbiBjb250ZXh0IGFuZCB0aGUgaW4gZnVuY3Rpb24gY29udGV4dAogICAgICAgICAgICAvL1RoaXMgb25lIHByaW50cyB0aGUgZ2xvYmFsIGNvbnRleHQgdmFsdWVzCgogICAgICAgICAgICBjYXNlICdwcmludCc6CiAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgUHJpbnRFbmdpbmUobXV0YWJsZV90b2tlbnMsIG1lbW9yeSwgaik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIC8vVGhpcyBydW5zIG91ciB3aGlsZSBsb29wIC5pLmUg4KSc4KSs4KSk4KSVCgogICAgICAgICAgICBjYXNlICdXaGlsZUxvb3BTdGFydCc6CiAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgKGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgICAgdmFyIGdldFdoaWxlTG9vcFNvdXJjZWRhdGEgPSBmdW5jdGlvbiBnZXRXaGlsZUxvb3BTb3VyY2VkYXRhKHN0YXJ0SW5kZXgsIG11dGFibGVfdG9rZW5zLCBTdG9yZVJlc3VsdCkgewogICAgICAgICAgICAgICAgICAgIFN0b3JlUmVzdWx0ID0gSGFuZGxlQmxvY2tzKG11dGFibGVfdG9rZW5zLCBzdGFydEluZGV4LCBTdG9yZVJlc3VsdCk7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN0b3JlUmVzdWx0OwogICAgICAgICAgICAgICAgICB9OwoKICAgICAgICAgICAgICAgICAgc2tpcEludGVycHJldGF0aW9uID0gMDsKICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBtdXRhYmxlX3Rva2Vuc1tqICsgMV0udmFsdWU7CiAgICAgICAgICAgICAgICAgIHZhciBFeHRyYXRjZWRWYXJpYWJsZSA9IFtdOwogICAgICAgICAgICAgICAgICB2YXIgdmFyaWFibGUgPSAnJzsKICAgICAgICAgICAgICAgICAgdmFyIFdoaWxlTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0ID0gMDsKICAgICAgICAgICAgICAgICAgdmFyIFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnMgPSBbXTsKCiAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBlbGVtZW50Lmxlbmd0aDsgX2krKykgewogICAgICAgICAgICAgICAgICAgIHZhciB4ID0gZWxlbWVudC5jaGFyQXQoX2kpOwoKICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYXJpYWJsZSh4KSkgewogICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGUgPSB2YXJpYWJsZSArIHg7CiAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVmFyaWFibGUoZWxlbWVudC5jaGFyQXQoX2kgKyAxKSkgJiYgaXNWYXJpYWJsZSh4KSkgewogICAgICAgICAgICAgICAgICAgICAgdmFyIF90b2tlbjIgPSBtZW1vcnkuZmluZChmdW5jdGlvbiAoZWwpIHsKICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsLm5hbWUgPT09IHZhcmlhYmxlOwogICAgICAgICAgICAgICAgICAgICAgfSk7CgogICAgICAgICAgICAgICAgICAgICAgRXh0cmF0Y2VkVmFyaWFibGUucHVzaCh7CiAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlOiB2YXJpYWJsZSwKICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IF90b2tlbjIudmFsdWUKICAgICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGUgPSAnJzsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgIFdoaWxlTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0ID0gZ2V0TG9vcEluZGV4U3RhcnQobXV0YWJsZV90b2tlbnMsIGosICd7JywgV2hpbGVMb29wU291cmNlZGF0YUluZGV4U3RhcnQpOwogICAgICAgICAgICAgICAgICBXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zID0gZ2V0V2hpbGVMb29wU291cmNlZGF0YShXaGlsZUxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydCwgbXV0YWJsZV90b2tlbnMsIFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnMpLlN0b3JlUmVzdWx0OwogICAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9ICfgpJzgpKzgpKTgpJUgJyArIGVsZW1lbnQgKyAnIOCkuOCkueClgCDgpLngpYvgpJfgpL4g4KSk4KSsIOCkpOCklSDgpIbgpJfgpYcg4KSV4KS+IOCkleCli+CkoSDgpLDgpKgg4KSV4KS/4KSv4KS+IOCknOCkvuCkr+Clh+Ckl+CkviAnOwogICAgICAgICAgICAgICAgICB2YXIgZGVzY3JpcHRpb24gPSAn4KSc4KSs4KSk4KSVIOCkruClh+CkgiDgpKbgpL/gpI8g4KS54KWB4KSPIOCktuCksOCljeCkpChDb25kaXRpb24pIOCkleClhyDgpKrgpYLgpLDgpL4g4KS54KWL4KSo4KWHIOCkpOCklSDgpIbgpJfgpYcg4KSV4KWHIOCkleCli+CkoSDgpJXgpYsg4KSw4KSoIOCkleCksOClhyB8JzsKICAgICAgICAgICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBHZXRjbGVhbmVkRXhwcmVzc2lvbihlbGVtZW50KTsKICAgICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gZmluZHRva2VuUG9zaXRpb25pbkNvZGUoTGluZWJ5bGluZVNvdXJjZWRhdGEsIGV4cHJlc3Npb24sIHRydWUpOwoKICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uICE9IHVuZGVmaW5lZCkgewogICAgICAgICAgICAgICAgICAgIEFkZHRvRXhlY3V0aW9uU3RhY2soRXhlY3V0aW9uU3RhY2ssIEFjdGl2ZUxhbmd1Z2FlS2V5d29yZHMuV2hpbGUsIGRlc2NyaXB0aW9uLCBlbGVtZW50LCBXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zLCBtZXNzYWdlLCBwb3NpdGlvbik7CiAgICAgICAgICAgICAgICAgIH0gLy9jb25zdGFudGx5IGFjY2Vzc2luZyB0aGUgY29uZGl0aW9udmFsdWUKCgogICAgICAgICAgICAgICAgICB3aGlsZSAoR2V0Q29uZGl0aW9uVmFsdWUoZWxlbWVudCwgbWVtb3J5LCBqICsgMSkpIHsKICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zLmxlbmd0aDsgX2kyKyspIHsKICAgICAgICAgICAgICAgICAgICAgIC8vU0VDVElPTiB3aGlsZSBsb29wIGNvbnRleHQKICAgICAgICAgICAgICAgICAgICAgIGlmIChXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zW19pMl0udmFsdWUgPT09ICc9JykgewogICAgICAgICAgICAgICAgICAgICAgICBBc3NpZ25vclVwZGF0ZVZhbHVlcyhXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zLCBfaTIsIG1lbW9yeSwgJycsICcnLCAnJywgRXhlY3V0aW9uU3RhY2ssIExpbmVieWxpbmVTb3VyY2VkYXRhKTsKICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoV2hpbGVMb29wU291cmNlZGF0YVRva2Vuc1tfaTJdLnR5cGUgPT09ICdBY2NlcHRJbnB1dCcpIHsKICAgICAgICAgICAgICAgICAgICAgICAgQWNjZXB0SW5wdXRhbmRTZXRWYWx1ZShXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zLCBfaTIsIG1lbW9yeSwgRXhlY3V0aW9uU3RhY2spOwogICAgICAgICAgICAgICAgICAgICAgfSAvLyBIYW5kbGluZyBDT05ESVRJT05BTCBzdGF0ZW1lbnRzIGluIFdoaWxlIGxvb3AKICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnNbX2kyXS50eXBlID09PSAnY29uZGl0aW9uJykgewogICAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgaW5kZXggcmV0dXJucyBhIHZhbHVlLCBpdCBtZWFucyBjb25kaXRpb24gaXMgZmFsc2UgYW5kIHNraXAgdGhlIGV4ZWN1dGlvbgogICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IEhhbmRsZUNvbmRpdGlvbnMoV2hpbGVMb29wU291cmNlZGF0YVRva2VucywgX2kyLCBtZW1vcnkpOwoKICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaTIgPSBpbmRleDsKICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgX2kyID0gX2kyOwogICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgfSAvL0hhbmRsaW5nIOCkpuCkv+CkluCkvuCkjyBzdGF0ZW1lbnRzIGluIHdoaWxlIGxvb3AKICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoV2hpbGVMb29wU291cmNlZGF0YVRva2Vuc1tfaTJdLnZhbHVlID09PSBBY3RpdmVMYW5ndWdhZUtleXdvcmRzLlByaW50KSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQcmludEVuZ2luZShXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zLCBtZW1vcnksIF9pMiwgRXhlY3V0aW9uU3RhY2spOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lCiAgICAgICAgICAgICAgICAgICAgICAgICAgfSAvL29wZXJhdGlvbnMgbGlrZSBOdW1iZXJzW2FdPSd4eXonCiAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoV2hpbGVMb29wU291cmNlZGF0YVRva2Vuc1tfaTJdLnR5cGUgPT09ICdTZXRBcnJheUluZGV4VmFsdWUnKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNldEFycmF5SW5kZXhWYWx1ZShXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zLCBfaTIsIGosIG1lbW9yeSwgdG9rZW5zLCBPcmlnaW5hbEl0ZXJhdG9yLCBpdGVyYXRvciwgRXhlY3V0aW9uU3RhY2ssIExpbmVieWxpbmVTb3VyY2VkYXRhKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgIHNraXBJbnRlcnByZXRhdGlvbiA9IFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnMubGVuZ3RoOyAvL0VuZCBvZiBXaGlsZSBsb29wIGV4ZWN1dGlvbgogICAgICAgICAgICAgICAgICAvL0hhbmRsaW5nIEZvciBsb29wcwogICAgICAgICAgICAgICAgfSkoKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICBjYXNlICdGb3JMb29wU3RhcnQnOgogICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIHZhciBnZXRTb3VyY2VkYXRhID0gZnVuY3Rpb24gZ2V0U291cmNlZGF0YShzdGFydEluZGV4LCBtdXRhYmxlX3Rva2VucywgU3RvcmVSZXN1bHQpIHsKICAgICAgICAgICAgICAgICAgdmFyIFJldHVybnZhbHVlID0gSGFuZGxlQmxvY2tzKG11dGFibGVfdG9rZW5zLCBzdGFydEluZGV4LCBTdG9yZVJlc3VsdCk7CiAgICAgICAgICAgICAgICAgIFN0b3JlUmVzdWx0ID0gUmV0dXJudmFsdWUuU3RvcmVSZXN1bHQ7CiAgICAgICAgICAgICAgICAgIHJldHVybiBTdG9yZVJlc3VsdDsKICAgICAgICAgICAgICAgIH07CgogICAgICAgICAgICAgICAgdmFyIEZsYWdQcmltYWxMb29wID0gMDsgLy8gZXNsaW50LWRpc2FibGUtbGluZQoKICAgICAgICAgICAgICAgIHZhciBTb3VyY2VkYXRhVG9rZW5zID0gW107CgogICAgICAgICAgICAgICAgdmFyIF9Gb3JMb29wU2V0TWV0YWRhdGEgPSBGb3JMb29wU2V0TWV0YWRhdGEobXV0YWJsZV90b2tlbnMsIGosIG1lbW9yeSksCiAgICAgICAgICAgICAgICAgICAgT3JpZ2luYWxJdGVyYXRvciA9IF9Gb3JMb29wU2V0TWV0YWRhdGEuT3JpZ2luYWxJdGVyYXRvciwKICAgICAgICAgICAgICAgICAgICBJdGVyYXRpb25TdGFydCA9IF9Gb3JMb29wU2V0TWV0YWRhdGEuSXRlcmF0aW9uU3RhcnQsCiAgICAgICAgICAgICAgICAgICAgSXRlcmF0aW9uRW5kID0gX0Zvckxvb3BTZXRNZXRhZGF0YS5JdGVyYXRpb25FbmQsCiAgICAgICAgICAgICAgICAgICAgaXRlcmF0b3IgPSBfRm9yTG9vcFNldE1ldGFkYXRhLml0ZXJhdG9yLAogICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBfRm9yTG9vcFNldE1ldGFkYXRhLmVsZW1lbnQsCiAgICAgICAgICAgICAgICAgICAgRm9yTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0ID0gX0Zvckxvb3BTZXRNZXRhZGF0YS5Gb3JMb29wU291cmNlZGF0YUluZGV4U3RhcnQsCiAgICAgICAgICAgICAgICAgICAgQ3ljbGUgPSBfRm9yTG9vcFNldE1ldGFkYXRhLkN5Y2xlOwoKICAgICAgICAgICAgICAgIEZvckxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydCA9IGdldExvb3BJbmRleFN0YXJ0KG11dGFibGVfdG9rZW5zLCBqLCAneycsIEZvckxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydCk7CiAgICAgICAgICAgICAgICBTb3VyY2VkYXRhVG9rZW5zID0gZ2V0U291cmNlZGF0YShGb3JMb29wU291cmNlZGF0YUluZGV4U3RhcnQsIG11dGFibGVfdG9rZW5zLCBTb3VyY2VkYXRhVG9rZW5zKTsKICAgICAgICAgICAgICAgIFNvdXJjZWRhdGFUb2tlbnMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHsKICAgICAgICAgICAgICAgICAgZWwuaXNOZXN0ZWRMb29wID0gZmFsc2U7CiAgICAgICAgICAgICAgICB9KTsgLy9DaGVja2luZyBpZiB0aGUgZm9yIGxvb3AgaGFzIG9uZSBtb3JlIGZvciBsb29wIGluc2lkZSBpdAoKICAgICAgICAgICAgICAgIHZhciBGaW5kTmVzdGVkTG9vcCA9IFNvdXJjZWRhdGFUb2tlbnMuZmluZChmdW5jdGlvbiAoZWwpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsLnR5cGUgPT09ICdGb3JMb29wU3RhcnQnOwogICAgICAgICAgICAgICAgfSk7CgogICAgICAgICAgICAgICAgaWYgKEZpbmROZXN0ZWRMb29wICE9IHVuZGVmaW5lZCkgewogICAgICAgICAgICAgICAgICB2YXIgTmVzdGVkTG9vcGluZGV4ID0gU291cmNlZGF0YVRva2Vucy5pbmRleE9mKEZpbmROZXN0ZWRMb29wKSArIDM7CiAgICAgICAgICAgICAgICAgIHZhciBOZXN0ZWRMb29wbGVuZ3RoID0gU291cmNlZGF0YVRva2Vuc1tOZXN0ZWRMb29waW5kZXhdLkVuZEluZGV4IC0gU291cmNlZGF0YVRva2Vuc1tOZXN0ZWRMb29waW5kZXhdLnN0YXJ0SW5kZXggKyAyOyAvL2lmIHdlIGhhdmUgYSBuZXN0ZWQgbG9vcCwgc2V0IGlzTmVzdGVMb29wIHRvIFRSVUUKCiAgICAgICAgICAgICAgICAgIGZvciAodmFyIHggPSBOZXN0ZWRMb29waW5kZXg7IHggPCBOZXN0ZWRMb29waW5kZXggKyBOZXN0ZWRMb29wbGVuZ3RoOyB4KyspIHsKICAgICAgICAgICAgICAgICAgICBTb3VyY2VkYXRhVG9rZW5zW3hdLmlzTmVzdGVkTG9vcCA9IHRydWU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5pbmNsdWRlcygnKCcpICYmIGVsZW1lbnQuaW5jbHVkZXMoJywnKSkgewogICAgICAgICAgICAgICAgICBGbGFnUHJpbWFsTG9vcCA9IDE7CiAgICAgICAgICAgICAgICB9IC8vSXRlcmF0aW5nIG92ZXIgZm9ybG9vcCBzb3VyY2VkYXRhCiAgICAgICAgICAgICAgICAvL3NlbGYgbGluZSAnaXRlcmF0b3IgPD0gQ3ljbGUnIGRldGVybWluZXMgc3RhcnQgb2YgdGhlIGxvb3AgYW5kIHRoZSBkdXJhdGlvbiBvZiB0aGUgbG9vcAoKCiAgICAgICAgICAgICAgICB2YXIgX21lc3NhZ2UyID0gJ+CkpuClgeCkueCksOCkvuCkkyDgpJXgpYcg4KSF4KSC4KSm4KSwIOCksuCkv+CkluClhyDgpJfgpI8g4KSV4KWL4KShIOCkleCliyAnICsgSXRlcmF0aW9uU3RhcnQgKyAnIOCkuOClhyAnICsgSXRlcmF0aW9uRW5kICsgJyDgpKTgpJUsIOCkruCkpOCksuCkrCAnICsgZXZhbChJdGVyYXRpb25FbmQgLSBJdGVyYXRpb25TdGFydCArIDEpICsgJyDgpKzgpL7gpLAgUlVOKOCksOCkqCkg4KSV4KS/4KSv4KS+IOCknOCkvuCkr+Clh+Ckl+CkviB8JyArICdcbicgKyAnIOCkh+CkuOCkruClh+CkgiBDb21wdXRlciwgJyArICciJyArIGl0ZXJhdG9yICsgJyInICsgJyDgpJXgpYsgTWVtb3J5IOCkruClh+CkgiwgJyArIEl0ZXJhdGlvblN0YXJ0ICsgJyDgpLjgpYcgJyArIEl0ZXJhdGlvbkVuZCArICcg4KSk4KSVIOCkleCkvOClgOCkruCkpChWYWx1ZXMpIOCkuOClh+CknyDgpJXgpLDgpKTgpL4g4KSc4KS+4KSP4KSX4KS+fCc7IC8vVGhpcyBpcyB0aGUgZXhwZXJlc3Npb24gd2hjaWggaXMgZ2V0dGluZyBldmFsdWF0ZWQuCgoKICAgICAgICAgICAgICAgIHZhciBfZXhwcmVzc2lvbjIgPSAn4KSm4KWB4KS54KSw4KS+4KSTICcgKyBpdGVyYXRvciArICcg4KSV4KWLICcgKyBtdXRhYmxlX3Rva2Vuc1tqICsgMV0udmFsdWUgKyAnIOCkruClhyc7CgogICAgICAgICAgICAgICAgdmFyIF9kZXNjcmlwdGlvbjIgPSAn4KSP4KSVIOCkueClgCDgpJXgpYvgpKEg4KSV4KWLIOCkrOCkvuCksC3gpKzgpL7gpLAg4KSm4KWL4KS54KSw4KS+4KSo4KS+4KWkICc7CiAgICAgICAgICAgICAgICB2YXIgTGluZW51bWJlciA9IExpbmVieWxpbmVTb3VyY2VkYXRhLmluZGV4T2YoX2V4cHJlc3Npb24yKTsKICAgICAgICAgICAgICAgIExpbmVudW1iZXIgKz0gMTsKICAgICAgICAgICAgICAgIEFkZHRvRXhlY3V0aW9uU3RhY2soRXhlY3V0aW9uU3RhY2ssIEFjdGl2ZUxhbmd1Z2FlS2V5d29yZHMuRm9yLCBfZGVzY3JpcHRpb24yLCBTb3VyY2VkYXRhVG9rZW5zLCAnJywgX21lc3NhZ2UyLCBMaW5lbnVtYmVyKTsKCiAgICAgICAgICAgICAgICBmb3IgKGl0ZXJhdG9yID0gSXRlcmF0aW9uU3RhcnQ7IGl0ZXJhdG9yIDw9IEN5Y2xlOyBpdGVyYXRvcisrKSB7CiAgICAgICAgICAgICAgICAgIHZhciBmb3Jsb29waW5kZXggPSBtZW1vcnkuZmluZChmdW5jdGlvbiAoZWwpIHsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWwubmFtZSA9PT0gT3JpZ2luYWxJdGVyYXRvcjsKICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICAgIGZvcmxvb3BpbmRleC52YWx1ZSA9IGl0ZXJhdG9yOyAvL2ZsYWcgdG8gYXZvaWQgcnVubmluZyB0aGlzIGNvZGUgaWYgbG9vcCBpcyBwcmltYWwgYmVjYXVzZSB0aGUgcGF5bG9hZCBuZWVkcyB0byBiZSBjb21wZWx0ZWx5IGRpZmZlcmVudAoKICAgICAgICAgICAgICAgICAgaWYgKEZsYWdQcmltYWxMb29wID09PSAwKSB7Ly8gRm9yTG9vcEFycmF5b3JTdHJpbmdPdXRwdXQoZWxlbWVudFZhbHVlLCBpdGVyYXRvciwgbWVtb3J5LCBzZWxmKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZQogICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBTb3VyY2VkYXRhVG9rZW5zLmxlbmd0aDsgX2kzKyspIHsKICAgICAgICAgICAgICAgICAgICAvLyBsZXQgaXNOZXN0ZWQgPSBTb3VyY2VkYXRhVG9rZW5zW2ldLmlzTmVzdGVkTG9vcDsKICAgICAgICAgICAgICAgICAgICAvL1RoaXMgY29kZSBydW5zIG9ubHkgaWYgd2UgaGF2ZSBhIG5lc3RlZCBsb29wIHNpdHVhdGlvbgogICAgICAgICAgICAgICAgICAgIHNraXBJbnRlcnByZXRhdGlvbiA9IDA7CgogICAgICAgICAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgICAgICAgICBpbnRlcnByZXRUb2tlbihTb3VyY2VkYXRhVG9rZW5zLCBfaTMsIG1lbW9yeSk7CiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZSwgImVycm9yIGluIGludGVycHJldGluZyBmb3IgbG9vcCAiLmNvbmNhdChTb3VyY2VkYXRhVG9rZW5zW19pM10pKTsKICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgIGlmIChza2lwSW50ZXJwcmV0YXRpb24gIT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgX2kzID0gX2kzICsgc2tpcEludGVycHJldGF0aW9uOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIHNraXBJbnRlcnByZXRhdGlvbiA9IHNraXBJbnRlcnByZXRhdGlvbiArIFNvdXJjZWRhdGFUb2tlbnMubGVuZ3RoOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgLy9FTkQgRk9SIExPT1AgRVhFQ1VUSU9OCgogICAgICAgICAgICBjYXNlICdmdW5jdGlvbkV4ZWN1dGlvbic6CiAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgLy9jaGVja2luZyBpZiBmdW5jdGlvbiBpcyBpbnZva2VkIHNvbWV3aGVyZSBsYXRlciBpbiB0aGUgcHJvZ3JhbQogICAgICAgICAgICAgICAgLy9JZiB3ZSBzZWUgYSBmdW5jdGlvbiBleGVjdXRpb24gY2FsbCwgZm9yIGUuZyBBZGQoeCx5KSwgd2UgcHJlcGFyZSBmb3IgZXhlY3V0aW9uCiAgICAgICAgICAgICAgICB2YXIgX2Z1bmN0aW9uU291cmNlRGF0YSA9IFtdOwogICAgICAgICAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IHRva2VuOwogICAgICAgICAgICAgICAgdmFyIHBhc3NlZFZhbHVlcyA9IG11dGFibGVfdG9rZW5zW2pdLnBhc3NlZFZhbHVlczsKICAgICAgICAgICAgICAgIHZhciBmdW5jdGlvblRva2VuID0gbXV0YWJsZV90b2tlbnMuZmluZChmdW5jdGlvbiAoZWwpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsLnZhbHVlID09PSBmdW5jdGlvbk5hbWU7CiAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgIHZhciBmdW5jdGlvbkFyZ3VtZW50cyA9IGZ1bmN0aW9uVG9rZW4uYXJndW1lbnRzOwogICAgICAgICAgICAgICAgX2Z1bmN0aW9uU291cmNlRGF0YSA9IGZ1bmN0aW9uVG9rZW4uU291cmNlRGF0YTsgLy9DcmVhdGluZyBhIHNlcGVyYXRlIGV4ZWN1dGlvbiBjb250ZXh0IGFuZCBzZXR0aW5nIGZ1Y250aW9uIGNvbnRleHQgbmFtZTp2YWx1ZSBwYWlyIGluIGZ1bmN0aW9uQ29udGV4dG1lbW9yeQogICAgICAgICAgICAgICAgLy9mb3IgZS5nIHg9MywgeT00IGlzIGFscmVhZHkgZGVmaW5lZCBhbmQgdGhlbiB3ZSBleGVjdXRlIGFkZCh4LHkpCiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGFuIG1lbW9yeSBmb3JtIGxpbWl0ZWQgdG8gZnVuY3Rpb24gY29udGV4dAogICAgICAgICAgICAgICAgLy9PcGVyYXRpbmcgb24gZnVuY3Rpb24gYXJndW1lbnRzIGFuZCBzZXR0aW5nIHRoZWlyIHZhbHVlcy4gRm9yIGUuZyB0aGUgZnVuY3Rpb24gYWRkKHgseSkgbWlnaHQgYmUgY2FsbGVkIGFzIGFkZCgzLDQpCiAgICAgICAgICAgICAgICAvL3NvIHdlIHNldCB4PTMsIHk9NCBhbmQgc2V0IHNlbGYgdmFyaWFibGUtdmFsdWUgcGFpciBpbiBmdW5jdGlvbkNvbnRleHRtZW1vcnkKCiAgICAgICAgICAgICAgICBmdW5jdGlvbkFyZ3VtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbCwgaW5kZXgpIHsKICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IHBhc3NlZFZhbHVlc1tpbmRleF07CiAgICAgICAgICAgICAgICAgIHZhbCA9IHZhbC5yZXBsYWNlKC8iL2csICcnKTsKICAgICAgICAgICAgICAgICAgdmFsID0gdmFsLnJlcGxhY2UoLycvZywgJycpOwogICAgICAgICAgICAgICAgICBwYXNzZWRWYWx1ZXNbaW5kZXhdID0gdmFsOyAvL2luIHNlbGYgY29kZSB3ZSBhcmUgZmlsdGVyaW5nIG91dCBhcmd1bWVudHMgcGFzc2VkIGJhc2VkIG9uIHdoZXRoZXIgdGhleSBhbHJlYWR5IGV4aXN0IGluIHVwZGF0ZWQgdG9rZW5zIG9yIG5vdAoKICAgICAgICAgICAgICAgICAgdmFyIEZpbmRJblVwZGF0ZWRUb2tlbnMgPSBtZW1vcnkuZmluZChmdW5jdGlvbiAoZWwpIHsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWwubmFtZSA9PT0gdmFsOwogICAgICAgICAgICAgICAgICB9KTsgLy9Gb3IgcGFzc2luZyBzYW1lIGFyZ3VtZW50IGFuZCBzYW1lIHZhbHVlIHRvIGZ1bmN0aW9uICBlLmcgZnVuY3Rpb24gZm9vIChmaWJvbmFjY2kpIGFuZCBmaWJvbmFjY2kgaXMgYWxyZWFkeSBkZWNsYXJlZCB3aXRoIHNvbWUgdmFsdWUKCiAgICAgICAgICAgICAgICAgIGlmIChGaW5kSW5VcGRhdGVkVG9rZW5zID09PSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbkNvbnRleHRtZW1vcnkucHVzaCh7CiAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBlbCwKICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWwsCiAgICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVyOiBqICsgaW5kZXgsCiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndmFsdWUnLAogICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogJ0Z1bmN0aW9uRXhlY3V0aW9uQ29udGV4dCcKICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgICAgfSAvL0ZvciBwYXNzaW5nIGRpZmZlcmVudCBhcmd1bWVudCBhbmQgdmFsdWUgdG8gZnVuY3Rpb24gIGUuZyBmdW5jdGlvbiBmb28gKGFycikgYW5kIGFyciBkb2Vzbid0IGV4aXN0IGFueXdoZXJlIGluIHRva2Vucy4KICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZWwgIT0gRmluZEluVXBkYXRlZFRva2Vucy5uYW1lICYmIEZpbmRJblVwZGF0ZWRUb2tlbnMgIT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbkNvbnRleHRtZW1vcnkucHVzaCh7CiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGVsLAogICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogRmluZEluVXBkYXRlZFRva2Vucy52YWx1ZSwKICAgICAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllcjogaiArIGluZGV4LAogICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBGaW5kSW5VcGRhdGVkVG9rZW5zLnR5cGUsCiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6ICdGdW5jdGlvbkV4ZWN1dGlvbkNvbnRleHQnLAogICAgICAgICAgICAgICAgICAgICAgICBJbnRoZUVuZFNldFZhbHVldG86IHZhbAogICAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uQ29udGV4dG1lbW9yeS5wdXNoKHsKICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZWwsCiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWwsCiAgICAgICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXI6IGogKyBpbmRleCwKICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogRmluZEluVXBkYXRlZFRva2Vucy50eXBlLAogICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiAnRnVuY3Rpb25FeGVjdXRpb25Db250ZXh0JywKICAgICAgICAgICAgICAgICAgICAgICAgSW50aGVFbmRTZXRWYWx1ZXRvOiB2YWwKICAgICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0pOyAvL0J1aWxkaW5nIGEgY29tcGxldGUgdmFyaWFibGUtdmFsdWUgcGFpciBkYXRhc2V0CgogICAgICAgICAgICAgICAgdmFyIENvbXBsZXRlVG9rZW5WYWx1ZUxpc3QgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KG1lbW9yeSksIGZ1bmN0aW9uQ29udGV4dG1lbW9yeSk7CgogICAgICAgICAgICAgICAgdmFyIF9tZXNzYWdlMyA9ICdDb21wdXRlciAnICsgJyInICsgZnVuY3Rpb25OYW1lICsgJyInICsgJyDgpKjgpL7gpK4g4KSV4KWAIOCksOCkmuCkqOCkviDgpJXgpYsg4KSV4KWJ4KSyIChDYWxsKSDgpJXgpLDgpKTgpL4g4KS54KWIIHwg4KSG4KSq4KSo4KWHICcgKyAnIigpIicgKyAnIOCkleClhyDgpIXgpILgpKbgpLAg4KSm4KS/4KSPIOCkl+CkjyBOZXcgVmFsdWVzIOCkleCkviDgpLDgpJrgpKjgpL4gJyArIGZ1bmN0aW9uTmFtZSArICcg4KSu4KWH4KSCIOCkieCkquCkr+Cli+CklyDgpJXgpLDgpJXgpYcsIOCksOCkmuCkqOCkviAnICsgZnVuY3Rpb25OYW1lICsgJyDgpK7gpYfgpIIg4KSy4KS/4KSW4KWHIOCkl+CkjyDgpJXgpYvgpKEg4KSV4KWLIOCksOCkqCDgpJXgpLDgpKTgpL4g4KS54KWIIHwnOwoKICAgICAgICAgICAgICAgIHZhciBfZXhwcmVzc2lvbjMgPSBmdW5jdGlvbk5hbWUgKyAnKCc7CgogICAgICAgICAgICAgICAgdmFyIF9kZXNjcmlwdGlvbjMgPSAnIOCkj+CklSDgpLXgpL/gpLbgpL/gpLfgpY3gpJ8g4KSw4KWC4KSqIOCkuOClhyDgpLLgpL/gpJbgpL4g4KSX4KSv4KS+IOCkleCli+CkoSDgpJzgpL/gpLjgpJXgpL4g4KS54KSuIOCkrOCkvuCksCDgpKzgpL7gpLAg4KSJ4KSq4KSv4KWL4KSXIOCkleCksCDgpLjgpJXgpKTgpYcg4KS54KWIIHwgJzsKCiAgICAgICAgICAgICAgICB2YXIgX3Bvc2l0aW9uMiA9IGZpbmR0b2tlblBvc2l0aW9uaW5Db2RlKExpbmVieWxpbmVTb3VyY2VkYXRhLCBfZXhwcmVzc2lvbjMsIGZhbHNlKTsKCiAgICAgICAgICAgICAgICBpZiAoX3Bvc2l0aW9uMiAhPSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgICAgICAgQWRkdG9FeGVjdXRpb25TdGFjayhFeGVjdXRpb25TdGFjaywgQWN0aXZlTGFuZ3VnYWVLZXl3b3Jkcy5GdW5jdGlvbiwgX2Rlc2NyaXB0aW9uMywgZnVuY3Rpb25OYW1lLCBfZnVuY3Rpb25Tb3VyY2VEYXRhLCBfbWVzc2FnZTMsIF9wb3NpdGlvbjIpOwogICAgICAgICAgICAgICAgfSAvL05vdyB3ZSBzdGFydCBkaWdnaW5nIGludG8gdGhlIGZ1bmN0aW9uIGV4ZWN1dGlvbgogICAgICAgICAgICAgICAgLy9taWdodCBoYXZlIHRvIGNoYW5nZSBpIHRvIDEKICAgICAgICAgICAgICAgIC8vc2tpcCBpbiBmdW5jdGlvbnNvdXJjZWRhdGEKCgogICAgICAgICAgICAgICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgX2Z1bmN0aW9uU291cmNlRGF0YS5sZW5ndGg7IF9pNCsrKSB7CiAgICAgICAgICAgICAgICAgIHNraXBJbnRlcnByZXRhdGlvbiA9IDA7CgogICAgICAgICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgICAgIGludGVycHJldFRva2VuKF9mdW5jdGlvblNvdXJjZURhdGEsIF9pNCwgQ29tcGxldGVUb2tlblZhbHVlTGlzdCk7CiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlLCAiZXJyb3IgaW4gaW50ZXJwcmV0aW5nIGZ1bmN0aW9uIGV4ZWN1dGlvbiAiLmNvbmNhdChmdW5jdGlvbk5hbWUpKTsKICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgaWYgKHNraXBJbnRlcnByZXRhdGlvbiAhPSAwKSB7CiAgICAgICAgICAgICAgICAgICAgX2k0ID0gX2k0ICsgc2tpcEludGVycHJldGF0aW9uOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgIGNvbnNvbGUubG9nKGUsICJFcnJvciBpbiBJbnRlcnByZXRpbmcgdG9rZW4gIi5jb25jYXQobXV0YWJsZV90b2tlbnNbal0pKTsKICAgICAgfQogICAgICAvKiBlbHNlIGlmICh0b2tlbiA9PT0gIuCkheCkqOCljeCkr+CkpeCkviIpIHsKICAgICAgICBsZXQgcmVzdWx0ID0gSGFuZGxlQmxvY2tzKG11dGFibGVfdG9rZW5zLCBqLCByZXN1bHQpOwogICAgICAgIC8vIGxldCBTdGFydG9mQmxvY2sgPSBtdXRhYmxlX3Rva2Vuc1tqICsgMV0uc3RhcnRJbmRleDsKICAgICAgICBsZXQgRW5kb2ZCbG9jayA9IG11dGFibGVfdG9rZW5zW2ogKyAxXS5FbmRJbmRleDsKICAgICAgICAgICBsZXQgbGFzdFZhbHVlID0ga2FsYWFtLkxhc3RDb25kaXRpb25WYWx1ZS5wb3AoKTsKICAgICAgICAgICBpZiAobGFzdFZhbHVlKSB7CiAgICAgICAgICBqID0gRW5kb2ZCbG9jazsKICAgICAgICB9Ki8KCiAgICB9OyAvLyNTVEVQIDEtIENsZWFuaW5nIHRoZSBzb3VyY2VkYXRhIGFuZCBzZXR0aW5nIHRoZSAncmVzdWx0JyB0byAnY2xlYW5lZF9zb3VyY2VkYXRhJwogICAgLy9JZiBhIGNvZGUgaXMgbm90IHdvcmtpbmcsIGl0IGlzIHByb2JhYmx5IGJlY2F1c2UgaXQncyBub3QgY2xlYW5lZCBwcm9wZXJseS4KICAgIC8vIGNvbnNvbGUubG9nKCdjbGVhbmVkX3NvdXJjZWRhdGE6JywgY2xlYW5lZF9zb3VyY2VkYXRhKTsKCgogICAgLy9UaGlzIGlzIHdoZXJlIGVycm9yIGhhbmRsaW5nIGtpY2tzIGluCiAgICAvL1RvIGZpbmQgdW5kZWZpbmVkIHZhcmlhYmxlcwogICAgdmFyIG9ubHlVbmlxdWUgPSBmdW5jdGlvbiBvbmx5VW5pcXVlKHZhbHVlLCBpbmRleCwgYXJyKSB7CiAgICAgIHJldHVybiBhcnIuaW5kZXhPZih2YWx1ZSkgPT09IGluZGV4OwogICAgfTsKCiAgICAvL3QwIGFsb25nIHdpdGggdDEgdGFrZXMgcmVjb3JkIG9mIFRpbWUgdGFrZW4gdG8gcnVuIHRoZSBjb2RlLiB0MS10MCBnaXZlcyB1cyB0aGUgZXhhY3QgdGltZSB0YWtlbi4KICAgIHZhciB0MCA9IHBlcmZvcm1hbmNlLm5vdygpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lCiAgICAvL1NvdXJjZWRhdGEgaXMgdGhlIHJhdyBjb2RlIHByb3ZpZGVkIGJ5IHVzZXIKCiAgICB2YXIgc291cmNlZGF0YSA9IHNvdXJjZWNvZGU7CiAgICB2YXIgTGluZWJ5bGluZVNvdXJjZWRhdGEgPSBzb3VyY2VkYXRhLnJlcGxhY2UoLyg/OlxyXG58XHJ8XG4pL2csICdicmVha3BvaW50Jykuc3BsaXQoJ2JyZWFrcG9pbnQnKTsgLy9UaGlzIGlzIHdoZXJlIGZvcm1hdHRlZCBhbmQgY2xlYW5lZCBzb3VyY2VkYXRhIHdpbGwgZ28uCgogICAgdmFyIGNsZWFuZWRfc291cmNlZGF0YSA9IFtdOwogICAgdmFyIEV4ZWN1dGlvblN0YWNrID0gW107CiAgICB2YXIgaSA9IDA7IC8vVGhpcyBpcyB3aGVyZSB0b2tlbnMgd2lsbCBiZSBwdXNoZWQgZGVwZW5kaW5nIHVwb24gdGhlaXIgdHlwZXMgbGlrZSBWYXJpYWJsZSwgZnVuY3Rpb24sIGxvb3BzIGV0Yy4KCiAgICB2YXIgdG9rZW5zID0gW107IC8vRXhwZXJpbWVudGFsCgogICAgdmFyIG1peGVkaW1wdXJpdHkgPSBbXTsgLy9UaGUgdmFyaWFibGVzIHdpdGggdGhlaXIgY2FsY3VsYXRlZCB2YWx1ZXMgYXJlIHB1c2hlZCBoZXJlLiBJZiBjPWErYiwgbWVtb3J5IGlzIHdoZXJlIHlvdSB3aWxsIGZpbmQgdGhlIGNhbGN1bGF0ZWQgdmFsdWUKCiAgICB2YXIgbWVtb3J5ID0gW107IC8vVmFyaWFibGUtdmFsdWUgcGFpcnMgc2ltaWxhciB0byBtZW1vcnkgYnV0IGxpbWl0cyBpdHNlbGYgdG8gYSB1c2VyIGNyZWF0ZWQgZnVuY3Rpb24uCgogICAgdmFyIGZ1bmN0aW9uQ29udGV4dG1lbW9yeSA9IFtdOwogICAgdmFyIHZhcmlhYmxlc19hcnJheSA9IFtdOyAvL1B1c2hpbmcgdGhlIHZhcmlhYmxlcyB0aGF0IGFyZSBhc3NpZ25lZCB0byBmaWx0ZXIgb3V0IGRlZmluZWQgYW5kIHVuZGVmaW5lZCB2YXJpYWJsZXMuIFVzZWZ1bCBpbiBlcnJvciBoYW5kbGluZwoKICAgIHZhciBhc3NpZ25lZF92YXJpYWJsZXMgPSBbXTsgLy9UTyBSRU1PVkUgRFVQTElDQVRFIFZBUklBQkxFUywKICAgIC8vIHZhciB2YXJpYWJsZUFycmF5ID0gW107CiAgICAvL0EgdGVtcG9yYXJ5IGluc3RhbmNlIG9mIGEgZ2xvYmFsIHZhcmlhYmxlLiBVc2VkIGJlY2F1c2Ugb2Ygc2NvcGluZyBpc3N1ZSwgdGhlcmUgYXJlIGJldHRlciBzb3VsdGlvbnMgYW5kIHdlIHdpbGwgZG8gdGhhdC4KICAgIC8vZW1wdHlpbmcgYWNjdW11bGF0ZWQgdmFsdWUKICAgIC8vU2VlIEFzc2lnbm9yVXBkYXRlVmFsdWVzIGZ1bmN0aW9uIGZvciBtb3JlCgogICAgdmFyIHNraXBQYXJzaW5nID0gMDsKICAgIHZhciBza2lwSW50ZXJwcmV0YXRpb24gPSAwOwogICAgUmVzZXRWYWx1ZSgpOwogICAgdmFyIGthbGFhbSA9IHt9OyAvL0lmIGFuIGVycm9yIGlzIGVuY291bnRlcmVkIHdlIHNldCB0aGUgdmFsdWUgdG8gdHJ1ZSBhbmQgcHVzaCB0aGUgZXJyb3IgdG8gZXJyb3JzIGFycmF5LgoKICAgIGthbGFhbS5pc0Vycm9yID0gZmFsc2U7CiAgICBzb3VyY2Vjb2RlID0gZWFybHlDbGVhbmluZyhzb3VyY2Vjb2RlKTsKICAgIGthbGFhbS5vdXRwdXQgPSAnJzsKICAgIGthbGFhbS5MYXN0Q29uZGl0aW9uVmFsdWUgPSBbXTsKICAgIGthbGFhbS5FeGVjdXRpb25TdGFjayA9IFtdOwogICAga2FsYWFtLmxpbmVieWxpbmVPdXRwdXQgPSBrYWxhYW0ub3V0cHV0LnNwbGl0KCdcbicpOwogICAga2FsYWFtLmVycm9yID0gW107CiAgICBrYWxhYW0uT3BlcmF0aW9uT2JqZWN0cyA9IFtdOyAvL1NFQ1RJT04gLSBDaGVja2luZyBmb3IgdHlwZSBvZiBjaGFyYWN0ZXJzLiBUeXBlQ2hlY2sgaXMgYW4gb2JqZWN0IHdoaWNoIGNvbnNpc3RzIGFsbCBzZWxmIGZ1bmN0aW9ucy4gQ2hlY2sgTGluZSAxMDIKCiAgICB2YXIgaXNWYXJpYWJsZSA9IFR5cGVDaGVjay5pc1ZhcmlhYmxlKCk7CiAgICB2YXIgaXNOdW1iZXIgPSBUeXBlQ2hlY2suaXNOdW1iZXIoKTsKICAgIHZhciBpc1doaWxlTG9vcCA9IFR5cGVDaGVjay5pc1doaWxlTG9vcCgpOwogICAgdmFyIGlzUHVyZUV2YWwgPSBBZHZhbmNlZFR5cGVDaGVjay5pc1B1cmVFdmFsKCk7IC8vaWYgX3Rva2Vuc3IgZW5jb3VudGVycyBhbnl0aGluZyBsaWtlICgiIG9yICgsIHRoZW4gdGhhdCdzIGEgcmVhbHRpbWUgcHJpbnQuCiAgICAvL2J1aWxkc3RyaW5nIHdpbGwgYmUgYXBwbGllZCBub3cgdG8gY3JlYXRlIGEgc3RyaW5nIGFuZCBwdXNoIGl0IGludG8gdG9rZW5zLiBCdWlsZHN0cmluZyBpcyB1c2VkIHRvIGNvbWJpbmUgc3RyaW5nIHRva2VucyBsaWtlCiAgICAvL1snaGVsbG8nLCAnS2FsYWFtJywgJ2RldmVsb3BlcnMnLCAiISJdIGludG8gJ2hlbGxvIGthbGFhbSBkZXZlbG9wZXJzIScuCiAgICAvL0l0J3MgYmVjYXVzZSBjbGVhbmVkX3NvdXJjZWRhdGEgaXMgYW4gYXJyYXkgb2YgdG9rZW5zIGFuZCBlYWNoIHRva2VuIGlzIGFuIGluZGl2aWR1YWwgd29yZCBpbiBhIHByb2dyYW0uCiAgICAvL0l0J3MgcmVjb21tZW5kZWQgdG8gbG9vayBhdCBjbGVhbmVkX3NvdXJjZWRhdGEgb2YgZXZlcnkgcHJvZ3JhbSB0byB1bmRlcnN0YW5kIGhvdyBpdCBjb252ZXJ0cyBwbGFpbiB0ZXh0IGludG8gYXJyYXkgb2YgaW5kaXZpZHVhbCB3b3Jkcy4KCiAgICB2YXIgaXNSZWFsVGltZVByaW50TXVsdGlwbGVTdHJpbmcgPSBBZHZhbmNlZFR5cGVDaGVjay5pc1JlYWxUaW1lUHJpbnRNdWx0aXBsZVN0cmluZygpOyAvL2NvbnN0IGlzU3RyaW5nYW5kVmFsdWUgPSBBZHZhbmNlZFR5cGVDaGVjay5pc1N0cmluZ2FuZFZhbHVlKCkKCiAgICB2YXIgaXNDYWxjdWxhdGlvbiA9IEFkdmFuY2VkVHlwZUNoZWNrLmlzQ2FsY3VsYXRpb24oKTsgLy8gY29uc3QgaXNEaXJlY3RQcmludEFyaXRobWV0aWMgPSBBZHZhbmNlZFR5cGVDaGVjay5pc0RpcmVjdFByaW50QXJpdGhtZXRpYygpCiAgICAvL1NFQ1RJT04gLSBCdWlsZCBPcGVyYXRpb25zCiAgICAvL1RvIGNvbnZlcnQgWydoZWxsbycsICdLYWxhYW0nLCAnZGV2ZWxvcGVycycsICIhIl0gaW50byAnaGVsbG8ga2FsYWFtIGRldmVsb3BlcnMhJy4KCiAgICB2YXIgQnVpbGRTdHJpbmcgPSBCdWlsZE9wZXJhdGlvbi5CdWlsZFN0cmluZygpOyAvL1RvIGNvbnZlcnQgWydbJywgJ3gnLCd5JywneicsJ10nXSBpbnRvIFsneCcsJ3knLCd6J10KCiAgICB2YXIgQnVpbGRBcnJheSA9IEJ1aWxkT3BlcmF0aW9uLkJ1aWxkQXJyYXkoKTsgLy9zZWxmIGZ1bmN0aW9uIGlzIHRoZSBmaXJzdCBzdGVwIHRvIGhhbmRsbGUgb3BlcmF0aW9ucyBsaWtlIOCkheCkl+CksCAoYWdlb25lPT09MTAgJiYgQXZlcmFnZUFnZTwxMDAwICYmIGFnZXR3bz4xMDAgfHwgYWdlb25lPT09MTApIE9SIChhZ2VvbmU9PT0xMCApCgogICAgdmFyIEJ1aWxkQ29uZGl0aW9uID0gQnVpbGRPcGVyYXRpb24uQnVpbGRDb25kaXRpb24oKTsKICAgIGNvbnNvbGUubG9nKCdjbGVhbmVkX3NvdXJjZWRhdGE6JywgY2xlYW5lZF9zb3VyY2VkYXRhKTsKICAgIGNvbnNvbGUubG9nKCd0b2tlbnM6JywgdG9rZW5zKTsKICAgIGNsZWFuZWRfc291cmNlZGF0YSA9IEdldENsZWFuU291cmNlZGF0YShzb3VyY2VkYXRhLCBjbGVhbmVkX3NvdXJjZWRhdGEsIG1peGVkaW1wdXJpdHkpOyAvLyNTVEVQIDItIC0gUGFyc2luZyBjbGVhbmVkX3NvdXJjZWRhdGEsIGFkZGluZyBlYWNoIGl0ZW0gZGVwZW5kaW5nIG9uIGl0J3MgdHlwZSB0byB0b2tlbnMgYXJyYXkKICAgIC8vIFBBUlNJTkcgSU5JVElBVElPTgoKICAgIChmdW5jdGlvbiBfcGFyc2VyKCkgewogICAgICBmb3IgKGk7IGkgPCBjbGVhbmVkX3NvdXJjZWRhdGEubGVuZ3RoOyBpKyspIHsKICAgICAgICBfYW5hbHl6ZVRva2VuKGNsZWFuZWRfc291cmNlZGF0YSwgaSwgdG9rZW5zKTsgLy9Db2RlIHRvIHNraXAgaW1wcm92ZSBhIHBhcnRpY3VsYXIgcGFydCBvZiBjbGVhbmVkX3NvdXJjZWRhdGEgaWYgaXQncyBiZWluZyBvcGVyYXRlZCBieSB0d28gZGlmZmVyZW50IGZ1bmN0aW9ucy4KCgogICAgICAgIGlmIChza2lwUGFyc2luZyAhPSAwKSB7CiAgICAgICAgICBpID0gaSArIHNraXBQYXJzaW5nOwogICAgICAgIH0KICAgICAgfQogICAgfSkoKTsgLy9DTEVBTklORyBVUCBUSEUgVE9LRU5TIEFSUkFZCiAgICAvL1JlbW92aW5nIHRva2VucyB3aXRoIHZhbHVlID0gJycsIEl0IHdhcyBnZW5lcmF0ZWQgZHVlIHRvICIgY2xlYW5lZF9zb3VyY2VkYXRhID0gY2xlYW5lZF9zb3VyY2VkYXRhLnJlcGxhY2UoLyg7fFxufFxyKS9nbSwgIiAiKS5zcGxpdCgnICcpIgogICAgLy9GaWx0ZXJpbmcgc2VlbWVkIHVubmVjZXNzYXJ5LCByZW1vdmVkIGZvciBub3cuCiAgICAvL3Rva2VucyA9IHRva2Vucy5maWx0ZXIoZWwgPT4gZWwudmFsdWUgIT0gJycpCiAgICAvL3ZhcmlhYmxlQXJyYXkgPSB0b2tlbnMuZmlsdGVyKChlbCkgPT4gZWwudHlwZSA9PT0gJ3ZhcmlhYmxlJyk7CiAgICAvL0FzIG9mIG5vdywgdGhpcyBpcyBob3cgdGhlIHRpbWVsaW5lIGxvb2tzCiAgICAvL3JhdyBzb3VyY2Vjb2RlIC0+IGNsZWFuZWRfc291cmNlZGF0YSAtPiB0b2tlbnMKICAgIC8vI1NURVAgMyAtIGV2YWx1YXRpbmcgY29uZGl0aW9ucywgcnVubmluZyBsb29wcywgZXhlY3V0aW5nIGZ1bmN0aW9ucyBmaW5kaW5nIHZhbHVlcyBpbiBtZW1vcnkgYW5kIHByaW50aW5nIG91dHB1dHMKICAgIC8vVGhpcyBpcyB0aGUgZmluYWwgc2VjdGlvbgogICAgLy9pbnRlcnByZXRpbmcgdGhlIGNvZGUgZnJvbSBzeW50YXggdHJlZQoKCiAgICAoZnVuY3Rpb24gX2ludGVycHJldG9yKCkgewogICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHRva2Vucy5sZW5ndGg7IHgrKykgewogICAgICAgIC8vV2Ugd2lsbCBiZSBoYXZpbmcgYSBjb3B5IG9mIHRva2VucyBhcyBtdXRhYmxlX3Rva2VucwogICAgICAgIGludGVycHJldFRva2VuKHRva2VucywgeCwgbWVtb3J5KTsKCiAgICAgICAgaWYgKHNraXBJbnRlcnByZXRhdGlvbiAhPSAwKSB7CiAgICAgICAgICB4ID0geCArIHNraXBJbnRlcnByZXRhdGlvbjsKICAgICAgICB9CiAgICAgIH0KICAgIH0pKCk7CgogICAgdmFyIGFzc2lnbmVkX3ZhcmlhYmxlcyA9IGFzc2lnbmVkX3ZhcmlhYmxlcy5maWx0ZXIob25seVVuaXF1ZSk7CiAgICB2YXIgZGlmZmVyZW5jZSA9IHZhcmlhYmxlc19hcnJheS5maWx0ZXIoZnVuY3Rpb24gKHgpIHsKICAgICAgcmV0dXJuICFhc3NpZ25lZF92YXJpYWJsZXMuaW5jbHVkZXMoeCk7CiAgICB9KTsKCiAgICBpZiAoZGlmZmVyZW5jZS5sZW5ndGggPiAwKSB7CiAgICAgIGRpZmZlcmVuY2UuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHsKICAgICAgICBrYWxhYW0uZXJyb3IucHVzaCgiVmFyaWFibGUgIi5jb25jYXQoZWwsICIgaXMgdW5kZWZpbmVkIikpOwogICAgICB9KTsKICAgIH0KCiAgICBrYWxhYW0ubGluZWJ5bGluZU91dHB1dCA9IGthbGFhbS5lcnJvci5sZW5ndGggPiAwID8ga2FsYWFtLmVycm9yIDoga2FsYWFtLm91dHB1dC5zcGxpdCgnXG4nKTsgLy90aW1lIHRha2VuIHRvIHRyYW5zcGlsZSB0aGUgY29kZSBpcyB0MS10MAoKICAgIHZhciB0MSA9IHBlcmZvcm1hbmNlLm5vdygpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lCgogICAgaWYgKGthbGFhbS5lcnJvci5sZW5ndGggPT09IDApIHsKICAgICAgdmFyIHMgPSAodDEgLSB0MCkudG9QcmVjaXNpb24oNCk7CiAgICAgIGthbGFhbS5UaW1lVGFrZW4gPSAiXHUwOTM4XHUwOTJCXHUwOTMyIHwgc3BlZWQgLSAiLmNvbmNhdChzLCAiIG1zIik7CiAgICB9IGVsc2UgewogICAgICBrYWxhYW0uaXNFcnJvciA9IHRydWU7CiAgICAgIGthbGFhbS5UaW1lVGFrZW4gPSAnQ29tcGlsYXRpb24gRXJyb3I6IENoZWNrIGZvciBhc3NpZ25lbWVudCBhbmQgZGVjbGFyYXRpb24gbWlzdHlwaW5nJzsKICAgIH0gLy9rYWxhYW0ubGluZWJ5bGluZW91dHB1dCBpcyB3aGF0IHlvdSB3aWxsIGZpbmFsbHkgc2VlIG9uIG91dHB1dCBzY3JlZW4KCgogICAga2FsYWFtLmxpbmVieWxpbmVPdXRwdXQgPSBrYWxhYW0ubGluZWJ5bGluZU91dHB1dC5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHsKICAgICAgcmV0dXJuIGl0ZW0gIT09ICcnOwogICAgfSk7CiAgICBrYWxhYW0uRXhlY3V0aW9uU3RhY2sgPSBFeGVjdXRpb25TdGFjazsKICAgIHJldHVybiBrYWxhYW07CiAgfSBjYXRjaCAoZSkgewogICAgY29uc29sZS5sb2coZSk7CiAgfQp9CgpleHBvcnQgeyBDb21waWxlLCBLYWxhYW1LZXl3b3JkcyB9Ow=="},{"version":3,"sources":["/Users/jonny/Desktop/myProjects/Kalaam-BE/Compiler/main.js"],"names":["TypeCheck","ActiveLangugaeKeywords","KalaamKeywords","AdvancedTypeCheck","BuildOperation","RemoveQuotes","RemoveBrackets","earlyCleaning","PushArray","PushCalculation","PushConditionalKeyword","PushCondition","PushForLoop","PushWhileLoop","PushForLoopAruguments","PushExpression","PushNativeOperation","PushKeyword","PushNumber","PushOperator","PushRealTimePrintOperation","PushString","PushVariable","PushVariableValue","PushFunctionData","PushFunctionExecution","PushToArray","PushInput","GetCleanSourcedata","GetcleanedExpression","AddElementToArray","ResetValue","CreateArrayElement","CalculateValues","GetArrayorStringElement","HandleBlocks","SplitElementsArray","SetValues","PushSetArrayIndexValue","PushGetArrayIndexValue","GetConditionValue","AcceptInputandSetValue","AssignorUpdateValues","HandleConditions","getLoopIndexStart","ForLoopSetMetadata","SetArrayIndexValue","AddtoExecutionStack","scanner","handleRealtimePrint","handleVariable","handleOutput","prepareFunction","findtokenPositioninCode","isInterpretableType","Compile","sourcecode","PrintEngine","Tokens","memory","j","iterator","OriginalIterator","StringVar","token","value","NextTokenValue","nextElement","VariableToPrint","forEach","el","name","assigned_variables","includes","kalaam","isNumber","push","isPureEval","outputpure","eval","type","toString","undefined","IndexInput","Value","ArrayElement","output","IndexToChange","element","replace","Split","split","join","find","Print","a","mode","x","isCalculation","message","expression","description","position","LinebylineSourcedata","ExecutionStack","_analyzeToken","cleaned_sourcedata","i","tokens","skipParsing","nextEl","prevEl","prevElement","token_type","handled_variable","h","console","log","e","length","charAt","ExpressiontoPrint","isRealTimePrintMultipleString","BuiltArray","BuildArray","splice","isWhileLoop","foundcondition","BuildCondition","isMultiCalculation","c","op","s","d","cal","count","multiCal","foundString","skip","BuildString","CheckFunctionExpression","passedValues","interpretToken","t","skipInterpretation","mutable_tokens","token_subtype","subtype","functionSourceData","SourceData","Function","ConditionValue","LastConditionValue","Returnvalue","If","getWhileLoopSourcedata","startIndex","StoreResult","ExtratcedVariable","variable","WhileLoopSourcedataIndexStart","WhileLoopSourcedataTokens","isVariable","While","index","getSourcedata","FlagPrimalLoop","SourcedataTokens","IterationStart","IterationEnd","ForLoopSourcedataIndexStart","Cycle","isNestedLoop","FindNestedLoop","NestedLoopindex","indexOf","NestedLooplength","EndIndex","Linenumber","For","forloopindex","functionName","functionToken","functionArguments","arguments","val","FindInUpdatedTokens","functionContextmemory","identifier","context","IntheEndSetValueto","CompleteTokenValueList","onlyUnique","arr","t0","performance","now","sourcedata","mixedimpurity","variables_array","isError","linebylineOutput","error","OperationObjects","_parser","_interpretor","filter","difference","t1","toPrecision","TimeTaken","item"],"mappings":"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","sourcesContent":["/*!\n * Kalaam v1.0.0\n * (C) 2020-21 Swanand Kadam\n * Released under the MIT License.\n */\n\n//SECTION - Importing function modules\n\n//To check variable types: Number, String, Array etc.\nimport * as TypeCheck from '../TypeCheck/TypeChecking';\n\nimport { ActiveLangugaeKeywords, KalaamKeywords } from '../Compiler/constants';\n\n//To check other operations like MultiString, Arithmetic Operation etc.\nimport * as AdvancedTypeCheck from '../TypeCheck/AdvancedTypeChecking';\n\n//To format user input into a proper String, Array or Condition.\nimport * as BuildOperation from '../Scripts/BuildOperations';\n\nimport { RemoveQuotes, RemoveBrackets, earlyCleaning } from '../Scripts/Helpers';\n\n//Functions imported to push a particular data to our Tokens array.\n//Tokens array is basically a clean, formatted and a word by word version of raw code provided by user\nimport { PushArray, PushCalculation, PushConditionalKeyword, PushCondition, PushForLoop, PushWhileLoop, PushForLoopAruguments, PushExpression, PushNativeOperation, PushKeyword, PushNumber, PushOperator, PushRealTimePrintOperation, PushString, PushVariable, PushVariableValue, PushFunctionData, PushFunctionExecution, PushToArray, PushInput } from '../PushTokens/main';\n\n//This are other helper functions that we need for a particular task. All of this functions will be explained indepth as we see them in codebase.\nimport {\n  GetCleanSourcedata,\n  GetcleanedExpression,\n  AddElementToArray,\n  ResetValue,\n  CreateArrayElement,\n  CalculateValues,\n  GetArrayorStringElement,\n  HandleBlocks,\n  SplitElementsArray,\n  SetValues,\n  PushSetArrayIndexValue,\n  PushGetArrayIndexValue,\n  GetConditionValue,\n  AcceptInputandSetValue,\n  AssignorUpdateValues,\n  HandleConditions,\n  getLoopIndexStart,\n  ForLoopSetMetadata,\n  SetArrayIndexValue,\n  AddtoExecutionStack,\n} from '../Scripts/main.js';\n\nimport scanner from '../scanner/main';\n\nimport '../HelperLibrary/main';\nimport { handleRealtimePrint, handleVariable, handleOutput, prepareFunction } from '../Scripts/Handlers';\nimport { findtokenPositioninCode } from '../Scripts/finders';\nimport { isInterpretableType } from '../Scripts/testers';\n//We will be importing this whole function to practise.vue and it will be executed when user clicks on 'RUN'\n\nfunction Compile(sourcecode) {\n  try {\n    //t0 along with t1 takes record of Time taken to run the code. t1-t0 gives us the exact time taken.\n    var t0 = performance.now(); // eslint-disable-line\n\n    //Sourcedata is the raw code provided by user\n    const sourcedata = sourcecode;\n\n    var LinebylineSourcedata = sourcedata.replace(/(?:\\r\\n|\\r|\\n)/g, 'breakpoint').split('breakpoint');\n\n    //This is where formatted and cleaned sourcedata will go.\n    var cleaned_sourcedata = [];\n    var ExecutionStack = [];\n    var i = 0;\n    //This is where tokens will be pushed depending upon their types like Variable, function, loops etc.\n    var tokens = [];\n\n    //Experimental\n    var mixedimpurity = [];\n\n    //The variables with their calculated values are pushed here. If c=a+b, memory is where you will find the calculated value\n    var memory = [];\n\n    //Variable-value pairs similar to memory but limits itself to a user created function.\n    var functionContextmemory = [];\n\n    var variables_array = [];\n\n    //Pushing the variables that are assigned to filter out defined and undefined variables. Useful in error handling\n    var assigned_variables = [];\n\n    //TO REMOVE DUPLICATE VARIABLES,\n\n    // var variableArray = [];\n    //A temporary instance of a global variable. Used because of scoping issue, there are better soultions and we will do that.\n\n    //emptying accumulated value\n    //See AssignorUpdateValues function for more\n\n    var skipParsing = 0;\n    var skipInterpretation = 0;\n\n    ResetValue();\n    var kalaam = {};\n    //If an error is encountered we set the value to true and push the error to errors array.\n    kalaam.isError = false;\n\n    sourcecode = earlyCleaning(sourcecode);\n\n    kalaam.output = '';\n    kalaam.LastConditionValue = [];\n    kalaam.ExecutionStack = [];\n\n    kalaam.linebylineOutput = kalaam.output.split('\\n');\n    kalaam.error = [];\n    kalaam.OperationObjects = [];\n\n    //SECTION - Checking for type of characters. TypeCheck is an object which consists all self functions. Check Line 102\n\n    const isVariable = TypeCheck.isVariable();\n\n    const isNumber = TypeCheck.isNumber();\n\n    const isWhileLoop = TypeCheck.isWhileLoop();\n\n    const isPureEval = AdvancedTypeCheck.isPureEval();\n\n    //if _tokensr encounters anything like (\" or (, then that's a realtime print.\n\n    //buildstring will be applied now to create a string and push it into tokens. Buildstring is used to combine string tokens like\n    //['hello', 'Kalaam', 'developers', \"!\"] into 'hello kalaam developers!'.\n\n    //It's because cleaned_sourcedata is an array of tokens and each token is an individual word in a program.\n\n    //It's recommended to look at cleaned_sourcedata of every program to understand how it converts plain text into array of individual words.\n\n    const isRealTimePrintMultipleString = AdvancedTypeCheck.isRealTimePrintMultipleString();\n\n    //const isStringandValue = AdvancedTypeCheck.isStringandValue()\n\n    const isCalculation = AdvancedTypeCheck.isCalculation();\n\n    // const isDirectPrintArithmetic = AdvancedTypeCheck.isDirectPrintArithmetic()\n\n    //SECTION - Build Operations\n\n    //To convert ['hello', 'Kalaam', 'developers', \"!\"] into 'hello kalaam developers!'.\n\n    const BuildString = BuildOperation.BuildString();\n\n    //To convert ['[', 'x','y','z',']'] into ['x','y','z']\n\n    const BuildArray = BuildOperation.BuildArray();\n\n    //self function is the first step to handlle operations like अगर (ageone===10 && AverageAge<1000 && agetwo>100 || ageone===10) OR (ageone===10 )\n\n    const BuildCondition = BuildOperation.BuildCondition();\n\n    //This will run for every दिखाए() statement encountered in the program, not just for loops\n\n    //ARGUMENTS TO PrintEngine are:\n    //Tokens- Tokens array\n    //memory- Variable-value pairs of variables\n    //j- Index of a token in Tokens array\n    //global- self or self\n    //iterator and OriginalIterator are used to print values in for and while loops.\n\n    function PrintEngine(Tokens, memory, j, iterator, OriginalIterator) {\n      //To understand what kind of data is necessary to print a value\n\n      //Getting the current token as token and value to be printed as NextTokenValue\n      //e.g. For दिखाए(Name), Name is the NextTokenValue and it is the one which we will have to print\n\n      var StringVar = [];\n\n      var token = Tokens[j].value;\n\n      var NextTokenValue = Tokens.nextElement(j).value;\n      //Removing the brackets, if any.\n      var VariableToPrint = RemoveBrackets(NextTokenValue);\n\n      //SECTION - Outputting the code\n      // finding the variable value in memory. memory is where our Variable-value pairs exists.\n\n      //This loop is only for printing direct values like print(name), print(array)\n\n      memory.forEach((el) => {\n        //If we have a variable-value pair sitting in memory\n\n        if (el.name === VariableToPrint) {\n          //for calculations like x=ageone+agetwo\n\n          //If we have already calculated value in assigned_variables, use that or else move forward\n\n          if (assigned_variables.includes(el) || assigned_variables.includes(el.name)) {\n            handleOutput(el.value, kalaam);\n          } else {\n            //if the value found is a Number\n\n            if (isNumber(el.value)) {\n              handleOutput(el.value, kalaam);\n\n              assigned_variables.push(el.name);\n            }\n\n            //if the value found is operations like age=2020-1996\n            else if (isPureEval(el.value)) {\n              //we are using Javascript's eval function to calculate direct arithmetic operations\n              let outputpure = eval(el.value);\n\n              el.value = outputpure;\n\n              handleOutput(el.value, kalaam);\n\n              assigned_variables.push(el.name);\n            }\n\n            //We will simplify this conditions as we move forward\n            else if (!isPureEval(el.value) && !isNumber(el.value)) {\n              if (!(el.name.includes(']') && el.name.includes('['))) {\n                if (el.type === 'Array') {\n                  if (!el.value.includes('[')) {\n                    el.value = '[' + el.value.toString() + ']';\n                  }\n                }\n\n                handleOutput(el.value, kalaam);\n\n                assigned_variables.push(el.name);\n              }\n            }\n          }\n        }\n      });\n\n      //This is how we print Array in Kalaam\n      if (Tokens[j + 1].type === 'Array') {\n        //To run only if iterator is present\n\n        //This runs on for loop - दिखाए(Array[a]) etc\n\n        //self runs only if for(i) and in the loop, array[i], not on array[x]. For loop Iterator and index should be same, in self case 'i'\n\n        if (iterator != undefined && Tokens[j + 1].IndexInput === OriginalIterator) {\n          let Value = NextTokenValue;\n\n          let ArrayElement = CreateArrayElement(Value, iterator);\n\n          let output = GetArrayorStringElement(ArrayElement, memory);\n\n          output = RemoveQuotes(output);\n\n          handleOutput(output, kalaam);\n\n          assigned_variables.push(Tokens[j + 1]);\n        }\n\n        //This runs to Print(Array[2]) like specific array values\n        else if (Tokens[j + 1].IndexInput != OriginalIterator) {\n          let Value = NextTokenValue;\n\n          let IndexToChange = Tokens[j + 1].IndexInput;\n\n          let ArrayElement = CreateArrayElement(Value, IndexToChange);\n\n          let element = ArrayElement.replace(']', '');\n\n          let Split = element.split('[');\n\n          if (Split[1].includes('-') || Split[1].includes('+')) {\n            let output = CalculateValues(Split[1], j, memory);\n\n            Split[1] = output;\n\n            Split = Split.join('[') + ']';\n            ArrayElement = Split;\n          }\n\n          let token = memory.find((el) => el.name === Split[1]);\n\n          if (token != undefined && OriginalIterator != Split[1]) {\n            Split[1] = token.value;\n\n            Split = Split.join('[') + ']';\n            ArrayElement = Split;\n          } else {\n            ArrayElement = ArrayElement;\n            ////\n          }\n\n          let output = GetArrayorStringElement(ArrayElement, memory);\n\n          handleOutput(output, kalaam);\n        }\n      }\n\n      //printing direct numbers and direct calcultions like print(10), print(10*10)\n      else if (token === ActiveLangugaeKeywords.Print && (isPureEval(RemoveBrackets(NextTokenValue)) || isNumber(RemoveBrackets(NextTokenValue)))) {\n        NextTokenValue = RemoveBrackets(NextTokenValue);\n\n        if (isNumber(NextTokenValue) && Tokens[j + 1].type != 'Calculation') {\n          handleOutput(NextTokenValue, kalaam);\n        } else {\n          let a = eval(NextTokenValue);\n\n          handleOutput(a, kalaam);\n        }\n      }\n\n      //foroperations like print('you live, you learn')\n      else if (Tokens[j + 1].mode === 'RealTimePrint' && !NextTokenValue.includes('+') /*&& !NextTokenValue.includes('=')*/) {\n        let output = RemoveBrackets(NextTokenValue);\n\n        output = RemoveQuotes(output);\n\n        handleOutput(output + '\\n', kalaam);\n      }\n\n      //operations like print(Age + 'is young age') i.e string concatenations\n      else if (Tokens[j + 1].mode === 'RealTimePrint' && NextTokenValue.includes('+')) {\n        let x = SplitElementsArray(NextTokenValue);\n\n        x = x.join('').split('+');\n\n        StringVar = SetValues(x, memory);\n\n        let output = StringVar.join(' ');\n\n        output = RemoveBrackets(output);\n        output = RemoveQuotes(output);\n\n        handleOutput(output + '\\n', kalaam);\n      } else if (isCalculation(RemoveBrackets(NextTokenValue)) && Tokens[j + 1].mode != 'RealTimePrint') {\n        NextTokenValue = RemoveBrackets(NextTokenValue);\n\n        let output = CalculateValues(NextTokenValue, j, memory);\n\n        handleOutput(output + '\\n', kalaam);\n      }\n\n      let message = ' Computer ने आपकी दी गयी वैल्यू, ' + '\"' + RemoveBrackets(NextTokenValue) + '\"' + ' को दिखाया है |';\n\n      //This is the experession whcih is getting evaluated.\n\n      let expression = token + NextTokenValue;\n      let description = 'किसी VALUE को OUTPUT SCREEN पे दिखाने के लिए दिखाए() का उपयोग होता है।';\n\n      expression = GetcleanedExpression(expression);\n\n      let position = findtokenPositioninCode(LinebylineSourcedata, expression, true);\n      if (position != undefined) {\n        AddtoExecutionStack(ExecutionStack, ActiveLangugaeKeywords.Print, description, VariableToPrint, null, message, position);\n      }\n    }\n\n    //END OF Functions and Imported Functions\n\n    //Out of all self function, PrintEngine is very important function. It prints variable values by searching their value in memory.\n\n    //SECTION - Checking each token and adding to tokens array\n\n    //_tokens takes two arguments. The cleaned_sourcedata array and current index of cleaned_sourcedata array\n\n    //_tokens is used to create a tokens array with each token having it's name, value, type and other metadata\n\n    //It performs operations depending upon whether the element is variable, array, function, loop etc.\n\n    //scanning every single element from cleaned_sourcedata array and pushing it to Tokens depending upon the type pf element\n\n    function _analyzeToken(cleaned_sourcedata, i, tokens) {\n      let element = cleaned_sourcedata[i];\n\n      skipParsing = 0;\n\n      let nextEl = cleaned_sourcedata.nextElement(i);\n      let prevEl = cleaned_sourcedata.prevElement(i);\n\n      let token_type = scanner(cleaned_sourcedata, i, tokens);\n      //Push variables to tokens\n      //Format: {type: \"variable\", value: \"ReverseString\"}\n\n      //whenever we need a certain handling, handlers.js is used\n      switch (token_type) {\n        case 'VARIABLE':\n          //Here we seperate Message = 'Hello' into following three tokens :\n\n          //1: {type: \"variable\", value: \"Message\"}\n\n          //2: {type: \"operator\", value: \"=\"}\n\n          //3: {type: \"value\", value: \"Hello\"}\n\n          let handled_variable = handleVariable(element, tokens, cleaned_sourcedata, i, nextEl, prevEl);\n          let h = handled_variable;\n          if (h != undefined) {\n            try {\n              h.type === 'variable' ? PushVariable(h, tokens) : console.log(`error in setting ${element}`);\n            } catch (e) {\n              console.log(e, `error in setting ${element}`);\n            }\n          }\n          break;\n        //Push variables to tokens\n        case 'NUMBER':\n          PushNumber(element, tokens);\n          break;\n\n        //Push EmptyStrings to tokens\n        case 'EMPTY_STRING':\n          //In some cases empty strings will be modified into something like \"'\" or '\"'\n          //We convert it back to \" \"\n          try {\n            let e = element;\n            e = e.length > 1 && (e.charAt(0) === \"'\" || e.charAt(0) === '\"') ? (e = e.replace(/['\"]+/g, '')) : (e = ' ');\n\n            PushVariableValue(e, tokens);\n          } catch (e) {\n            console.log(e, `Error in setting Empty string ${element}`);\n          }\n          break;\n\n        //Push Input to tokens\n        //Format: {type: \"AcceptInput\", value: \" \", AcceptAs: \"Message\"}\n        case 'INPUT':\n          try {\n            PushInput(element, tokens, cleaned_sourcedata, i);\n          } catch (e) {\n            console.log(e, `Error in setting Input ${element}`);\n          }\n          break;\n        //Push operators to tokens. The accepted operators are =,},{\n        //Format: {type: \"operator\", value: \"=\"}\n        case 'OPERATOR':\n          try {\n            PushOperator(element, tokens);\n          } catch (e) {\n            console.log(e, `Error in setting operator ${element}`);\n          }\n          break;\n\n        //Push keyowrds to tokens. The accepted keywords is दिखाए\n\n        //Format: {type: \"keyword\", value: ActiveLangugaeKeywords.Print}\n        case 'PRINT':\n          try {\n            PushKeyword(element, tokens);\n\n            let ExpressiontoPrint = nextEl;\n\n            if (!isRealTimePrintMultipleString(ExpressiontoPrint)) {\n              PushExpression(ExpressiontoPrint, tokens);\n            }\n          } catch (e) {\n            console.log(e, `Error in printing ${element}`);\n          }\n          break;\n        //Push functions to tokens\n        //Format: {type: \"function\", value: \"First\", arguments: Array(2), FunctionInvocationExists: false, FunctionStack: Array(0), …}\n        case 'FUNCTION':\n          try {\n            PushFunctionData(element, tokens, cleaned_sourcedata, i);\n          } catch (e) {\n            console.log(e, `Error in handling function ${element}`);\n          }\n          break;\n\n        // Push array to tokens\n\n        case 'ARRAY':\n          //Format: {type: \"Array\", value: \"[]\"}\n          //if empty array else build the array (To convert '[',1,2,3,4,']'  into [1,2,3,4]\n          try {\n            let e = element;\n            e.charAt(e.length - 1) === ']'\n              ? PushArray(e, tokens)\n              : function () {\n                  let BuiltArray = BuildArray(e, i, cleaned_sourcedata);\n\n                  PushArray(BuiltArray, tokens);\n                };\n          } catch (e) {\n            console.log(e, `Error in handling Array ${element}`);\n          }\n\n          break;\n\n        //For operations like Numbers[a]=a\n        //Format: {type: \"SetArrayIndexValue\", value: \"Fibonacci[a]\", ValueToSet: \"a\"}\n        case 'SET_ARRAY_INDEX':\n          try {\n            PushSetArrayIndexValue(element, tokens, cleaned_sourcedata, i);\n\n            cleaned_sourcedata.splice(i + 1, 1);\n          } catch (e) {\n            console.log(e, `Error in setting array index value ${element}`);\n          }\n\n          break;\n\n        //For operations like a=Numbers[a], reverse of above\n        //Format: {type: \"GetArrayIndexValue\", value: \"Fibonacci[a-2]\"}\n        case 'GET_ARRAY_INDEX':\n          try {\n            PushGetArrayIndexValue(element, tokens, cleaned_sourcedata, i);\n          } catch (e) {\n            console.log(e, `Error in getting array index value ${element}`);\n          }\n          break;\n\n        //Push conditions to tokens. The accepted keywords are अगर, जबतक, अन्यथा\n        // Format: {type: \"conditionalkeyword\", value: \"अगर\"}\n        //Push while loops to tokens\n        //Format: {type: \"WhileLoopStart\", value: \"जबतक\"}, {type: \"condition\", value: \"count<25\"}\n\n        case 'CONDITIONAL_KEYWORD':\n          try {\n            isWhileLoop(element) ? PushWhileLoop(element, tokens) : PushConditionalKeyword(element, tokens);\n\n            //This is how we push conditions encountered in the sourcecode\n            //Format:{type: \"condition\", value: \"a<3\"}\n            let foundcondition = BuildCondition(element, i, cleaned_sourcedata);\n\n            //Push conditions to tokens array\n\n            if (foundcondition != '') {\n              PushCondition(foundcondition, tokens);\n            }\n          } catch (e) {\n            console.log(e, `Error in operating on conditionals ${element}`);\n          }\n\n          break;\n\n        //Finding operations like Numbers.पुश(x)\n        //Format: {type: \"PushToArray\", value: \"Numbers.पुश(x)\"}\n        case 'PUSH_TO_ARRAY':\n          try {\n            PushToArray(element, tokens);\n          } catch (e) {\n            console.log(e, `Error in pushing the values to array ${element}`);\n          }\n          break;\n\n        //Push For loop to tokens\n        // Format:\n        // {type: \"ForLoopStart\", value: \"दुहराओ\"}\n        // {type: \"ForLoopArguments\", iterator: \"a\", value: \"(0,25)\", iterationStart: \"0\", iterationEnd: \"25\"}\n        case 'FOR_LOOP':\n          try {\n            PushForLoop(element, tokens);\n            PushForLoopAruguments(element, cleaned_sourcedata, i, tokens);\n\n            memory.push({\n              name: nextEl,\n              value: 0,\n              type: 'ForLoopIterator',\n            });\n          } catch (e) {\n            console.log(e, `Error in operating on for loop ${element}`);\n          }\n          break;\n\n        //Pushing basic Calculations like 'length-1' to tokens\n        //Format: {type: \"Calculation\", value: \"length-1\"}\n        case 'CALCULATION':\n          /* red zone\n  \n          if (nextEl != undefined) {\n            // this is to perform long calculations like AverageAge=(ageone+agetwo)/2 + (ageone+agetwo)*2\n  \n            while (isCalculation(cleaned_sourcedata[i])) {\n              el = el + cleaned_sourcedata[i];\n  \n              i++;\n            }\n          }\n  \n          console.log(\"el:\", el);\n  */\n          /*error prone*/\n\n          try {\n            let el = element;\n            let cal = '';\n            let count = 0;\n            //   function findCalculation(cleaned_sourcedata, i) {\n            let x = i;\n            let d = 0;\n\n            while (isCalculation(cleaned_sourcedata[x]) || cleaned_sourcedata[x] == '+') {\n              cal = cal + cleaned_sourcedata[x];\n              count += 1;\n              x++;\n            }\n\n            function isMultiCalculation(c, op = '*+/-') {\n              if (c.includes('(') && c.includes(')')) {\n                let s = c.split('');\n                s.forEach((el) => {\n                  if (op.includes(el)) {\n                    d = d + 1;\n                  }\n                });\n\n                if (d > 1) {\n                  return true;\n                } else {\n                  return false;\n                }\n              }\n            }\n\n            let multiCal = isMultiCalculation(cal);\n\n            //  console.log(\"x\", x, i);\n            skipParsing = count - 1;\n            // cal = RemoveBrackets(cal);\n\n            //let c_el = RemoveBrackets(cal);\n\n            //  let cal = findCalculation();\n\n            // to stop prevention of expressions like is\"+ getting added as a calculation\n            !cal.includes('\"') && !['/', '*', \"'\", '\"'].includes(el.charAt(0)) ? PushCalculation(cal, tokens, cleaned_sourcedata, i, multiCal) : console.log(`impure calculation terms ${el}`);\n          } catch (e) {\n            console.log(e, `Error in completing calculation ${element}`);\n          }\n          break;\n\n        case 'REALTIME_PRINT':\n          //finding operations like print(x + 'y'). The RealTimePrint operations\n\n          //Format: {type: \"value\", value: \"('Reversed String-'+ ReverseString)\", mode: \"RealTimePrint\"}\n          try {\n            let { foundString, skip } = handleRealtimePrint(cleaned_sourcedata, i);\n\n            PushRealTimePrintOperation(foundString, tokens);\n\n            skipParsing = skip;\n          } catch (e) {\n            console.log(e, `Error in real time print ${element}`);\n          }\n\n          break;\n\n        case 'STRING':\n          //storing only the string values to tokens ( not the strings in print statements)\n          try {\n            let s = BuildString(element, i, cleaned_sourcedata);\n\n            s = s.replace(/['\"]+/g, '');\n\n            !s.includes(ActiveLangugaeKeywords.Print) ? PushString(s, tokens) : console.log(`error in pushing string ${(s, element)}`);\n          } catch (e) {\n            console.log(e, `error in operating on string ${element}`);\n          }\n          break;\n\n        //An extension of isPrintOperation() function\n        // Needs improvement\n\n        /*     else if (/^(?=.*?दिखाए)(?=.*[a-z])/.test(element)) {\n                \n    \n                PushKeyword(element.slice(0, 6), tokens); //Pushing print keyword only\n    \n                PushExpression(element.slice(6), tokens); //Pushing remaining expression like (a), (Message) etc\n            }\n            */\n\n        //error prone change made here- Pushing expression in here\n        //Used to push functions and expressions\n        //Unnecessary data is being passed through kalaam.\n        //This was created for a temporary fix\n        case 'FUNCTION_CALL':\n          try {\n            let CheckFunctionExpression = element.split('(');\n\n            let passedValues = RemoveBrackets(CheckFunctionExpression[1]);\n            passedValues = passedValues.split(',');\n\n            PushFunctionExecution(element, tokens, cleaned_sourcedata, i, passedValues);\n          } catch (e) {\n            console.log(e, `error in pushing function execution ${element}`);\n          }\n          break;\n\n        case 'NATIVE_OPERATION':\n          try {\n            PushNativeOperation(element, tokens);\n          } catch (e) {\n            console.log(e, `error in pushing native operaion ${element}`);\n          }\n          break;\n\n        case 'ARRAY_PUSH':\n          try {\n            PushArray(element, tokens);\n          } catch (e) {\n            console.log(e, `error in array push ${element}`);\n          }\n          break;\n      }\n    }\n\n    //making sense of tokens array coming from _parser.\n    function interpretToken(t, j, memory) {\n      skipInterpretation = 0;\n      let mutable_tokens = t;\n\n      let token = mutable_tokens[j].value;\n\n      let token_type = mutable_tokens[j].type;\n      let token_subtype = mutable_tokens[j].subtype;\n\n      let type = token === ActiveLangugaeKeywords.Print || token_type === 'operator' ? token_subtype : token_type;\n      //need to skip over some unncessary types\n\n      //operators are not working correctly\n      // no need to interpret over non-types\n      try {\n        if (isInterpretableType(type)) {\n          switch (type) {\n            case 'SetArrayIndexValue':\n              {\n                SetArrayIndexValue(mutable_tokens, j, j, memory, tokens, OriginalIterator, iterator, ExecutionStack, LinebylineSourcedata);\n              }\n              break;\n\n            case 'assignment': {\n              AssignorUpdateValues(mutable_tokens, j, memory, iterator, OriginalIterator, kalaam, ExecutionStack, LinebylineSourcedata); // eslint-disable-line\n\n              break;\n            }\n            //type=assignment\n\n            case 'PushToArray':\n              {\n                AddElementToArray(mutable_tokens, j, memory, ExecutionStack, LinebylineSourcedata);\n              }\n              break;\n            case 'AcceptInput':\n              {\n                AcceptInputandSetValue(mutable_tokens, j, memory, ExecutionStack, LinebylineSourcedata);\n              }\n              break;\n\n            //Whenever we encounter a function, we create a seperate execution context\n            case 'function':\n              {\n                //We are preparing the required data to execute a function call later in the prgroam\n\n                //functionsourcedata includes all the tokens from tokens array which belongs to a particular function\n                skipInterpretation = 0;\n                //We find self range or a function block through HandleBlocks function\n                let { functionSourceData } = prepareFunction(mutable_tokens, j);\n\n                mutable_tokens[j].SourceData = functionSourceData;\n\n                let message = `इस ${ActiveLangugaeKeywords.Function} का नाम ${token} है जिसे हम कोड में बाद में NEW VALUES पास करके उपयोग कर सकते है|`;\n\n                let expression = `${ActiveLangugaeKeywords.Function} ${token}`;\n                let description = ' एक विशिष्ट रूप से लिखा गया कोड जिसका हम बार बार उपयोग कर सकते है | ';\n\n                let position = findtokenPositioninCode(LinebylineSourcedata, expression, true);\n                if (position != undefined) {\n                  AddtoExecutionStack(ExecutionStack, ActiveLangugaeKeywords.Function, description, mutable_tokens[j].value, functionSourceData, message, position);\n                }\n                skipInterpretation = functionSourceData.length;\n              }\n              break;\n            //We are out of the fucntion execution context and back to global execution context\n            case 'condition':\n              {\n                let element = token;\n\n                var message;\n\n                //this function is the first step to calculate value of operations like अगर (ageone===10 && AverageAge<1000 && agetwo>100 || ageone===10) OR (ageone===10 )\n\n                let ConditionValue = GetConditionValue(element, memory, j);\n\n                kalaam.LastConditionValue.push(ConditionValue);\n\n                //if value is false, just skip the if loop context, if not it will be ran in final print module\n\n                if (!ConditionValue) {\n                  //  let InitializeLoop = tokens.indexOf(mutable_tokens[j]);\n\n                  //Handle Blocks is a function which takes care of nested block by taking care of nested { and } brackets\n                  //it uses the stack to push and pop brackets to accurately identify start and the end of the block\n                  let Returnvalue = HandleBlocks(mutable_tokens, j);\n\n                  //amount to skip if condition is false\n                  skipInterpretation = Returnvalue.j - j;\n\n                  message = `कंडीशन  ${element}  , FALSE(गलत) होने के कारन COMPUTER आगे के कोड को रन नहीं करेगा `;\n                } else {\n                  message = `कंडीशन ${element}  , TRUE(सत्य) होने के कारन COMPUTER आगे के कोड को रन करेगा `;\n                }\n\n                let expression = element;\n                let description = 'एक Certain Condition के तहत कोड Execution को Allow करता है। ';\n\n                expression = GetcleanedExpression(expression);\n\n                let position = findtokenPositioninCode(LinebylineSourcedata, expression, true);\n                if (position != undefined) {\n                  AddtoExecutionStack(ExecutionStack, ActiveLangugaeKeywords.If, description, element, ConditionValue, message, position);\n                }\n              }\n\n              break;\n            //So that we don't print a same value twice. First in global execution context and the in function context\n\n            //This one prints the global context values\n            case 'print':\n              {\n                PrintEngine(mutable_tokens, memory, j); // eslint-disable-line\n              }\n              break;\n\n            //This runs our while loop .i.e जबतक\n            case 'WhileLoopStart':\n              {\n                skipInterpretation = 0;\n                let element = mutable_tokens[j + 1].value;\n\n                let ExtratcedVariable = [];\n\n                let variable = '';\n                let WhileLoopSourcedataIndexStart = 0;\n                let WhileLoopSourcedataTokens = [];\n\n                for (let i = 0; i < element.length; i++) {\n                  let x = element.charAt(i);\n\n                  if (isVariable(x)) {\n                    variable = variable + x;\n                  }\n                  if (!isVariable(element.charAt(i + 1)) && isVariable(x)) {\n                    let token = memory.find((el) => el.name === variable);\n\n                    ExtratcedVariable.push({\n                      variable: variable,\n                      value: token.value,\n                    });\n\n                    variable = '';\n                  }\n                }\n\n                function getWhileLoopSourcedata(startIndex, mutable_tokens, StoreResult) {\n                  StoreResult = HandleBlocks(mutable_tokens, startIndex, StoreResult);\n\n                  return StoreResult;\n                }\n\n                WhileLoopSourcedataIndexStart = getLoopIndexStart(mutable_tokens, j, '{', WhileLoopSourcedataIndexStart);\n\n                WhileLoopSourcedataTokens = getWhileLoopSourcedata(WhileLoopSourcedataIndexStart, mutable_tokens, WhileLoopSourcedataTokens).StoreResult;\n\n                let message = 'जबतक ' + element + ' सही होगा तब तक आगे का कोड रन किया जायेगा ';\n\n                let description = 'जबतक में दिए हुए शर्त(Condition) के पूरा होने तक आगे के कोड को रन करे |';\n\n                let expression = GetcleanedExpression(element);\n\n                let position = findtokenPositioninCode(LinebylineSourcedata, expression, true);\n                if (position != undefined) {\n                  AddtoExecutionStack(ExecutionStack, ActiveLangugaeKeywords.While, description, element, WhileLoopSourcedataTokens, message, position);\n                }\n\n                //constantly accessing the conditionvalue\n\n                while (GetConditionValue(element, memory, j + 1)) {\n                  for (let i = 0; i < WhileLoopSourcedataTokens.length; i++) {\n                    //SECTION while loop context\n\n                    if (WhileLoopSourcedataTokens[i].value === '=') {\n                      AssignorUpdateValues(WhileLoopSourcedataTokens, i, memory, '', '', '', ExecutionStack, LinebylineSourcedata);\n                    } else if (WhileLoopSourcedataTokens[i].type === 'AcceptInput') {\n                      AcceptInputandSetValue(WhileLoopSourcedataTokens, i, memory, ExecutionStack);\n                    }\n\n                    // Handling CONDITIONAL statements in While loop\n                    else if (WhileLoopSourcedataTokens[i].type === 'condition') {\n                      //if index returns a value, it means condition is false and skip the execution\n\n                      let index = HandleConditions(WhileLoopSourcedataTokens, i, memory);\n\n                      if (index != undefined) {\n                        i = index;\n                      } else {\n                        i = i;\n                      }\n                    }\n\n                    //Handling दिखाए statements in while loop\n                    else if (WhileLoopSourcedataTokens[i].value === ActiveLangugaeKeywords.Print) {\n                      PrintEngine(WhileLoopSourcedataTokens, memory, i, ExecutionStack); // eslint-disable-line\n                    }\n\n                    //operations like Numbers[a]='xyz'\n                    else if (WhileLoopSourcedataTokens[i].type === 'SetArrayIndexValue') {\n                      SetArrayIndexValue(WhileLoopSourcedataTokens, i, j, memory, tokens, OriginalIterator, iterator, ExecutionStack, LinebylineSourcedata);\n                    }\n                  }\n                }\n                skipInterpretation = WhileLoopSourcedataTokens.length;\n\n                //End of While loop execution\n\n                //Handling For loops\n              }\n              break;\n\n            case 'ForLoopStart':\n              {\n                var FlagPrimalLoop = 0; // eslint-disable-line\n\n                var SourcedataTokens = [];\n\n                var { OriginalIterator, IterationStart, IterationEnd, iterator, element, ForLoopSourcedataIndexStart, Cycle } = ForLoopSetMetadata(mutable_tokens, j, memory);\n\n                function getSourcedata(startIndex, mutable_tokens, StoreResult) {\n                  let Returnvalue = HandleBlocks(mutable_tokens, startIndex, StoreResult);\n                  StoreResult = Returnvalue.StoreResult;\n\n                  return StoreResult;\n                }\n\n                ForLoopSourcedataIndexStart = getLoopIndexStart(mutable_tokens, j, '{', ForLoopSourcedataIndexStart);\n\n                SourcedataTokens = getSourcedata(ForLoopSourcedataIndexStart, mutable_tokens, SourcedataTokens);\n\n                SourcedataTokens.forEach((el) => {\n                  el.isNestedLoop = false;\n                });\n\n                //Checking if the for loop has one more for loop inside it\n                let FindNestedLoop = SourcedataTokens.find((el) => el.type === 'ForLoopStart');\n\n                if (FindNestedLoop != undefined) {\n                  let NestedLoopindex = SourcedataTokens.indexOf(FindNestedLoop) + 3;\n                  let NestedLooplength = SourcedataTokens[NestedLoopindex].EndIndex - SourcedataTokens[NestedLoopindex].startIndex + 2;\n\n                  //if we have a nested loop, set isNesteLoop to TRUE\n\n                  for (let x = NestedLoopindex; x < NestedLoopindex + NestedLooplength; x++) {\n                    SourcedataTokens[x].isNestedLoop = true;\n                  }\n                }\n\n                if (element.includes('(') && element.includes(',')) {\n                  FlagPrimalLoop = 1;\n                }\n\n                //Iterating over forloop sourcedata\n                //self line 'iterator <= Cycle' determines start of the loop and the duration of the loop\n\n                let message = 'दुहराओ के अंदर लिखे गए कोड को ' + IterationStart + ' से ' + IterationEnd + ' तक, मतलब ' + eval(IterationEnd - IterationStart + 1) + ' बार RUN(रन) किया जायेगा |' + '\\n' + ' इसमें Computer, ' + '\"' + iterator + '\"' + ' को Memory में, ' + IterationStart + ' से ' + IterationEnd + ' तक क़ीमत(Values) सेट करता जाएगा|';\n\n                //This is the experession whcih is getting evaluated.\n                let expression = 'दुहराओ ' + iterator + ' को ' + mutable_tokens[j + 1].value + ' मे';\n                let description = 'एक ही कोड को बार-बार दोहराना। ';\n                let Linenumber = LinebylineSourcedata.indexOf(expression);\n                Linenumber += 1;\n\n                AddtoExecutionStack(ExecutionStack, ActiveLangugaeKeywords.For, description, SourcedataTokens, '', message, Linenumber);\n\n                for (iterator = IterationStart; iterator <= Cycle; iterator++) {\n                  let forloopindex = memory.find((el) => el.name === OriginalIterator);\n\n                  forloopindex.value = iterator;\n\n                  //flag to avoid running this code if loop is primal because the payload needs to be compeltely different\n                  if (FlagPrimalLoop === 0) {\n                    // ForLoopArrayorStringOutput(elementValue, iterator, memory, self); // eslint-disable-line\n                  }\n\n                  for (let i = 0; i < SourcedataTokens.length; i++) {\n                    // let isNested = SourcedataTokens[i].isNestedLoop;\n\n                    //This code runs only if we have a nested loop situation\n                    skipInterpretation = 0;\n                    try {\n                      interpretToken(SourcedataTokens, i, memory);\n                    } catch (e) {\n                      console.log(e, `error in interpreting for loop ${SourcedataTokens[i]}`);\n                    }\n                    if (skipInterpretation != 0) {\n                      i = i + skipInterpretation;\n                    }\n                  }\n                }\n\n                skipInterpretation = skipInterpretation + SourcedataTokens.length;\n              }\n\n              break;\n            //END FOR LOOP EXECUTION\n            case 'functionExecution': {\n              //checking if function is invoked somewhere later in the program\n\n              //If we see a function execution call, for e.g Add(x,y), we prepare for execution\n\n              let functionSourceData = [];\n              let functionName = token;\n\n              let passedValues = mutable_tokens[j].passedValues;\n\n              let functionToken = mutable_tokens.find((el) => el.value === functionName);\n\n              let functionArguments = functionToken.arguments;\n\n              functionSourceData = functionToken.SourceData;\n\n              //Creating a seperate execution context and setting fucntion context name:value pair in functionContextmemory\n\n              //for e.g x=3, y=4 is already defined and then we execute add(x,y)\n\n              // This is an memory form limited to function context\n\n              //Operating on function arguments and setting their values. For e.g the function add(x,y) might be called as add(3,4)\n\n              //so we set x=3, y=4 and set self variable-value pair in functionContextmemory\n\n              functionArguments.forEach((el, index) => {\n                let val = passedValues[index];\n\n                val = val.replace(/\"/g, '');\n                val = val.replace(/'/g, '');\n\n                passedValues[index] = val;\n\n                //in self code we are filtering out arguments passed based on whether they already exist in updated tokens or not\n\n                let FindInUpdatedTokens = memory.find((el) => el.name === val);\n\n                //For passing same argument and same value to function  e.g function foo (fibonacci) and fibonacci is already declared with some value\n                if (FindInUpdatedTokens === undefined) {\n                  functionContextmemory.push({\n                    name: el,\n\n                    value: val,\n\n                    identifier: j + index,\n                    type: 'value',\n                    context: 'FunctionExecutionContext',\n                  });\n                }\n\n                //For passing different argument and value to function  e.g function foo (arr) and arr doesn't exist anywhere in tokens.\n                else if (el != FindInUpdatedTokens.name && FindInUpdatedTokens != undefined) {\n                  functionContextmemory.push({\n                    name: el,\n\n                    value: FindInUpdatedTokens.value,\n\n                    identifier: j + index,\n                    type: FindInUpdatedTokens.type,\n                    context: 'FunctionExecutionContext',\n                    IntheEndSetValueto: val,\n                  });\n                } else {\n                  functionContextmemory.push({\n                    name: el,\n\n                    value: val,\n\n                    identifier: j + index,\n                    type: FindInUpdatedTokens.type,\n                    context: 'FunctionExecutionContext',\n                    IntheEndSetValueto: val,\n                  });\n                }\n              });\n\n              //Building a complete variable-value pair dataset\n\n              var CompleteTokenValueList = [...memory, ...functionContextmemory];\n\n              let message = 'Computer ' + '\"' + functionName + '\"' + ' नाम की रचना को कॉल (Call) करता है | आपने ' + '\"()\"' + ' के अंदर दिए गए New Values का रचना ' + functionName + ' में उपयोग करके, रचना ' + functionName + ' में लिखे गए कोड को रन करता है |';\n\n              let expression = functionName + '(';\n\n              let description = ' एक विशिष्ट रूप से लिखा गया कोड जिसका हम बार बार उपयोग कर सकते है | ';\n\n              let position = findtokenPositioninCode(LinebylineSourcedata, expression, false);\n\n              if (position != undefined) {\n                AddtoExecutionStack(ExecutionStack, ActiveLangugaeKeywords.Function, description, functionName, functionSourceData, message, position);\n              }\n\n              //Now we start digging into the function execution\n              //might have to change i to 1\n              //skip in functionsourcedata\n              for (let i = 0; i < functionSourceData.length; i++) {\n                skipInterpretation = 0;\n                try {\n                  interpretToken(functionSourceData, i, CompleteTokenValueList);\n                } catch (e) {\n                  console.log(e, `error in interpreting function execution ${functionName}`);\n                }\n                if (skipInterpretation != 0) {\n                  i = i + skipInterpretation;\n                }\n              }\n              break;\n            }\n          }\n        }\n      } catch (e) {\n        console.log(e, `Error in Interpreting token ${mutable_tokens[j]}`);\n      }\n      /* else if (token === \"अन्यथा\") {\n        let result = HandleBlocks(mutable_tokens, j, result);\n        // let StartofBlock = mutable_tokens[j + 1].startIndex;\n        let EndofBlock = mutable_tokens[j + 1].EndIndex;\n  \n        let lastValue = kalaam.LastConditionValue.pop();\n  \n        if (lastValue) {\n          j = EndofBlock;\n        }*/\n    }\n\n    //#STEP 1- Cleaning the sourcedata and setting the 'result' to 'cleaned_sourcedata'\n\n    //If a code is not working, it is probably because it's not cleaned properly.\n    // console.log('cleaned_sourcedata:', cleaned_sourcedata);\n    console.log('cleaned_sourcedata:', cleaned_sourcedata);\n\n    console.log('tokens:', tokens);\n\n    cleaned_sourcedata = GetCleanSourcedata(sourcedata, cleaned_sourcedata, mixedimpurity);\n\n    //#STEP 2- - Parsing cleaned_sourcedata, adding each item depending on it's type to tokens array\n\n    // PARSING INITIATION\n\n    (function _parser() {\n      for (i; i < cleaned_sourcedata.length; i++) {\n        _analyzeToken(cleaned_sourcedata, i, tokens);\n\n        //Code to skip improve a particular part of cleaned_sourcedata if it's being operated by two different functions.\n        if (skipParsing != 0) {\n          i = i + skipParsing;\n        }\n      }\n    })();\n\n    //CLEANING UP THE TOKENS ARRAY\n    //Removing tokens with value = '', It was generated due to \" cleaned_sourcedata = cleaned_sourcedata.replace(/(;|\\n|\\r)/gm, \" \").split(' ')\"\n\n    //Filtering seemed unnecessary, removed for now.\n    //tokens = tokens.filter(el => el.value != '')\n\n    //variableArray = tokens.filter((el) => el.type === 'variable');\n\n    //As of now, this is how the timeline looks\n\n    //raw sourcecode -> cleaned_sourcedata -> tokens\n\n    //#STEP 3 - evaluating conditions, running loops, executing functions finding values in memory and printing outputs\n\n    //This is the final section\n    //interpreting the code from syntax tree\n    (function _interpretor() {\n      for (let x = 0; x < tokens.length; x++) {\n        //We will be having a copy of tokens as mutable_tokens\n        interpretToken(tokens, x, memory);\n        if (skipInterpretation != 0) {\n          x = x + skipInterpretation;\n        }\n      }\n    })();\n\n    //This is where error handling kicks in\n\n    //To find undefined variables\n\n    function onlyUnique(value, index, arr) {\n      return arr.indexOf(value) === index;\n    }\n\n    var assigned_variables = assigned_variables.filter(onlyUnique);\n\n    var difference = variables_array.filter((x) => !assigned_variables.includes(x));\n\n    if (difference.length > 0) {\n      difference.forEach((el) => {\n        kalaam.error.push(`Variable ${el} is undefined`);\n      });\n    }\n\n    kalaam.linebylineOutput = kalaam.error.length > 0 ? kalaam.error : kalaam.output.split('\\n');\n\n    //time taken to transpile the code is t1-t0\n    var t1 = performance.now(); // eslint-disable-line\n\n    if (kalaam.error.length === 0) {\n      let s = (t1 - t0).toPrecision(4);\n      kalaam.TimeTaken = `सफल | speed - ${s} ms`;\n    } else {\n      kalaam.isError = true;\n\n      kalaam.TimeTaken = 'Compilation Error: Check for assignement and declaration mistyping';\n    }\n\n    //kalaam.linebylineoutput is what you will finally see on output screen\n\n    kalaam.linebylineOutput = kalaam.linebylineOutput.filter(function (item) {\n      return item !== '';\n    });\n\n    kalaam.ExecutionStack = ExecutionStack;\n    return kalaam;\n  } catch (e) {\n    console.log(e);\n  }\n}\n\nexport { Compile, KalaamKeywords };\n"]}]}