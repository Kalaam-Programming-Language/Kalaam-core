{"remainingRequest":"/Users/jonny/Desktop/myProjects/Kalaam-core/FE/node_modules/babel-loader/lib/index.js!/Users/jonny/Desktop/myProjects/Kalaam-core/Compiler/main.js","dependencies":[{"path":"/Users/jonny/Desktop/myProjects/Kalaam-core/Compiler/main.js","mtime":1623581543311},{"path":"/Users/jonny/Desktop/myProjects/Kalaam-core/FE/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/jonny/Desktop/myProjects/Kalaam-core/FE/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0IjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmlsdGVyIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmluZCI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZvci1lYWNoIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaW5jbHVkZXMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pbmRleC1vZiI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmpvaW4iOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zcGxpY2UiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5kYXRlLnRvLXN0cmluZyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmZ1bmN0aW9uLm5hbWUiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5udW1iZXIudG8tcHJlY2lzaW9uIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnRvLXN0cmluZyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pbmNsdWRlcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5yZXBsYWNlIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnNwbGl0IjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5mb3ItZWFjaCI7CmltcG9ydCBfdG9Db25zdW1hYmxlQXJyYXkgZnJvbSAiL1VzZXJzL2pvbm55L0Rlc2t0b3AvbXlQcm9qZWN0cy9LYWxhYW0tY29yZS9GRS9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdG9Db25zdW1hYmxlQXJyYXkiOwoKLyohCiAqIEthbGFhbSB2MS4wLjAKICogKEMpIDIwMjAtMjEgU3dhbmFuZCBLYWRhbQogKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuCiAqLwovL1NFQ1RJT04gLSBJbXBvcnRpbmcgZnVuY3Rpb24gbW9kdWxlcwovL1RvIGNoZWNrIHZhcmlhYmxlIHR5cGVzOiBOdW1iZXIsIFN0cmluZywgQXJyYXkgZXRjLgppbXBvcnQgKiBhcyBUeXBlQ2hlY2sgZnJvbSAnLi4vVHlwZUNoZWNrL1R5cGVDaGVja2luZyc7CmltcG9ydCB7IEFjdGl2ZUxhbmd1Z2FlS2V5d29yZHMgfSBmcm9tICcuLi9Db21waWxlci9jb25zdGFudHMnOyAvL1RvIGNoZWNrIG90aGVyIG9wZXJhdGlvbnMgbGlrZSBNdWx0aVN0cmluZywgQXJpdGhtZXRpYyBPcGVyYXRpb24gZXRjLgoKaW1wb3J0ICogYXMgQWR2YW5jZWRUeXBlQ2hlY2sgZnJvbSAnLi4vVHlwZUNoZWNrL0FkdmFuY2VkVHlwZUNoZWNraW5nJzsgLy9UbyBmb3JtYXQgdXNlciBpbnB1dCBpbnRvIGEgcHJvcGVyIFN0cmluZywgQXJyYXkgb3IgQ29uZGl0aW9uLgoKaW1wb3J0ICogYXMgQnVpbGRPcGVyYXRpb24gZnJvbSAnLi4vU2NyaXB0cy9CdWlsZE9wZXJhdGlvbnMnOwppbXBvcnQgeyBSZW1vdmVRdW90ZXMsIFJlbW92ZUJyYWNrZXRzLCBlYXJseUNsZWFuaW5nIH0gZnJvbSAnLi4vU2NyaXB0cy9IZWxwZXJzJzsgLy9GdW5jdGlvbnMgaW1wb3J0ZWQgdG8gcHVzaCBhIHBhcnRpY3VsYXIgZGF0YSB0byBvdXIgVG9rZW5zIGFycmF5LgovL1Rva2VucyBhcnJheSBpcyBiYXNpY2FsbHkgYSBjbGVhbiwgZm9ybWF0dGVkIGFuZCBhIHdvcmQgYnkgd29yZCB2ZXJzaW9uIG9mIHJhdyBjb2RlIHByb3ZpZGVkIGJ5IHVzZXIKCmltcG9ydCB7IFB1c2hBcnJheSwgUHVzaENhbGN1bGF0aW9uLCBQdXNoQ29uZGl0aW9uYWxLZXl3b3JkLCBQdXNoQ29uZGl0aW9uLCBQdXNoRm9yTG9vcCwgUHVzaFdoaWxlTG9vcCwgUHVzaEZvckxvb3BBcnVndW1lbnRzLCBQdXNoRXhwcmVzc2lvbiwgUHVzaE5hdGl2ZU9wZXJhdGlvbiwgUHVzaEtleXdvcmQsIFB1c2hOdW1iZXIsIFB1c2hPcGVyYXRvciwgUHVzaFJlYWxUaW1lUHJpbnRPcGVyYXRpb24sIFB1c2hTdHJpbmcsIFB1c2hWYXJpYWJsZSwgUHVzaFZhcmlhYmxlVmFsdWUsIFB1c2hGdW5jdGlvbkRhdGEsIFB1c2hGdW5jdGlvbkV4ZWN1dGlvbiwgUHVzaFRvQXJyYXksIFB1c2hJbnB1dCB9IGZyb20gJy4uL1B1c2hUb2tlbnMvbWFpbic7IC8vVGhpcyBhcmUgb3RoZXIgaGVscGVyIGZ1bmN0aW9ucyB0aGF0IHdlIG5lZWQgZm9yIGEgcGFydGljdWxhciB0YXNrLiBBbGwgb2YgdGhpcyBmdW5jdGlvbnMgd2lsbCBiZSBleHBsYWluZWQgaW5kZXB0aCBhcyB3ZSBzZWUgdGhlbSBpbiBjb2RlYmFzZS4KCmltcG9ydCB7IEdldENsZWFuU291cmNlZGF0YSwgR2V0Y2xlYW5lZEV4cHJlc3Npb24sIEFkZEVsZW1lbnRUb0FycmF5LCBSZXNldFZhbHVlLCBDcmVhdGVBcnJheUVsZW1lbnQsIENhbGN1bGF0ZVZhbHVlcywgR2V0QXJyYXlvclN0cmluZ0VsZW1lbnQsIEhhbmRsZUJsb2NrcywgU3BsaXRFbGVtZW50c0FycmF5LCBTZXRWYWx1ZXMsIFB1c2hTZXRBcnJheUluZGV4VmFsdWUsIFB1c2hHZXRBcnJheUluZGV4VmFsdWUsIEdldENvbmRpdGlvblZhbHVlLCBBY2NlcHRJbnB1dGFuZFNldFZhbHVlLCBBc3NpZ25vclVwZGF0ZVZhbHVlcywgSGFuZGxlQ29uZGl0aW9ucywgZ2V0TG9vcEluZGV4U3RhcnQsIEZvckxvb3BTZXRNZXRhZGF0YSwgU2V0QXJyYXlJbmRleFZhbHVlLCBBZGR0b0V4ZWN1dGlvblN0YWNrIH0gZnJvbSAnLi4vU2NyaXB0cy9tYWluLmpzJzsKaW1wb3J0IHNjYW5uZXIgZnJvbSAnLi4vc2Nhbm5lci9tYWluJzsKaW1wb3J0ICcuLi9IZWxwZXJMaWJyYXJ5L21haW4nOwppbXBvcnQgeyBoYW5kbGVSZWFsdGltZVByaW50LCBoYW5kbGVWYXJpYWJsZSwgaGFuZGxlT3V0cHV0LCBwcmVwYXJlRnVuY3Rpb24gfSBmcm9tICcuLi9TY3JpcHRzL0hhbmRsZXJzJzsKaW1wb3J0IHsgZmluZHRva2VuUG9zaXRpb25pbkNvZGUgfSBmcm9tICcuLi9TY3JpcHRzL2ZpbmRlcnMnOwppbXBvcnQgeyBpc0ludGVycHJldGFibGVUeXBlIH0gZnJvbSAnLi4vU2NyaXB0cy90ZXN0ZXJzJzsgLy9XZSB3aWxsIGJlIGltcG9ydGluZyB0aGlzIHdob2xlIGZ1bmN0aW9uIHRvIHByYWN0aXNlLnZ1ZSBhbmQgaXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIHVzZXIgY2xpY2tzIG9uICdSVU4nCgpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDb21waWxlKHNvdXJjZWNvZGUpIHsKICB0cnkgewogICAgLy9UaGlzIHdpbGwgcnVuIGZvciBldmVyeSDgpKbgpL/gpJbgpL7gpI8oKSBzdGF0ZW1lbnQgZW5jb3VudGVyZWQgaW4gdGhlIHByb2dyYW0sIG5vdCBqdXN0IGZvciBsb29wcwogICAgLy9BUkdVTUVOVFMgVE8gUHJpbnRFbmdpbmUgYXJlOgogICAgLy9Ub2tlbnMtIFRva2VucyBhcnJheQogICAgLy9tZW1vcnktIFZhcmlhYmxlLXZhbHVlIHBhaXJzIG9mIHZhcmlhYmxlcwogICAgLy9qLSBJbmRleCBvZiBhIHRva2VuIGluIFRva2VucyBhcnJheQogICAgLy9nbG9iYWwtIHNlbGYgb3Igc2VsZgogICAgLy9pdGVyYXRvciBhbmQgT3JpZ2luYWxJdGVyYXRvciBhcmUgdXNlZCB0byBwcmludCB2YWx1ZXMgaW4gZm9yIGFuZCB3aGlsZSBsb29wcy4KICAgIHZhciBQcmludEVuZ2luZSA9IGZ1bmN0aW9uIFByaW50RW5naW5lKFRva2VucywgbWVtb3J5LCBqLCBpdGVyYXRvciwgT3JpZ2luYWxJdGVyYXRvcikgewogICAgICAvL1RvIHVuZGVyc3RhbmQgd2hhdCBraW5kIG9mIGRhdGEgaXMgbmVjZXNzYXJ5IHRvIHByaW50IGEgdmFsdWUKICAgICAgLy9HZXR0aW5nIHRoZSBjdXJyZW50IHRva2VuIGFzIHRva2VuIGFuZCB2YWx1ZSB0byBiZSBwcmludGVkIGFzIE5leHRUb2tlblZhbHVlCiAgICAgIC8vZS5nLiBGb3Ig4KSm4KS/4KSW4KS+4KSPKE5hbWUpLCBOYW1lIGlzIHRoZSBOZXh0VG9rZW5WYWx1ZSBhbmQgaXQgaXMgdGhlIG9uZSB3aGljaCB3ZSB3aWxsIGhhdmUgdG8gcHJpbnQKICAgICAgdmFyIFN0cmluZ1ZhciA9IFtdOwogICAgICB2YXIgdG9rZW4gPSBUb2tlbnNbal0udmFsdWU7CiAgICAgIHZhciBOZXh0VG9rZW5WYWx1ZSA9IFRva2Vucy5uZXh0RWxlbWVudChqKS52YWx1ZTsgLy9SZW1vdmluZyB0aGUgYnJhY2tldHMsIGlmIGFueS4KCiAgICAgIHZhciBWYXJpYWJsZVRvUHJpbnQgPSBSZW1vdmVCcmFja2V0cyhOZXh0VG9rZW5WYWx1ZSk7IC8vU0VDVElPTiAtIE91dHB1dHRpbmcgdGhlIGNvZGUKICAgICAgLy8gZmluZGluZyB0aGUgdmFyaWFibGUgdmFsdWUgaW4gbWVtb3J5LiBtZW1vcnkgaXMgd2hlcmUgb3VyIFZhcmlhYmxlLXZhbHVlIHBhaXJzIGV4aXN0cy4KICAgICAgLy9UaGlzIGxvb3AgaXMgb25seSBmb3IgcHJpbnRpbmcgZGlyZWN0IHZhbHVlcyBsaWtlIHByaW50KG5hbWUpLCBwcmludChhcnJheSkKCiAgICAgIG1lbW9yeS5mb3JFYWNoKGZ1bmN0aW9uIChlbCkgewogICAgICAgIC8vSWYgd2UgaGF2ZSBhIHZhcmlhYmxlLXZhbHVlIHBhaXIgc2l0dGluZyBpbiBtZW1vcnkKICAgICAgICBpZiAoZWwubmFtZSA9PT0gVmFyaWFibGVUb1ByaW50KSB7CiAgICAgICAgICAvL2ZvciBjYWxjdWxhdGlvbnMgbGlrZSB4PWFnZW9uZSthZ2V0d28KICAgICAgICAgIC8vSWYgd2UgaGF2ZSBhbHJlYWR5IGNhbGN1bGF0ZWQgdmFsdWUgaW4gYXNzaWduZWRfdmFyaWFibGVzLCB1c2UgdGhhdCBvciBlbHNlIG1vdmUgZm9yd2FyZAogICAgICAgICAgaWYgKGFzc2lnbmVkX3ZhcmlhYmxlcy5pbmNsdWRlcyhlbCkgfHwgYXNzaWduZWRfdmFyaWFibGVzLmluY2x1ZGVzKGVsLm5hbWUpKSB7CiAgICAgICAgICAgIGhhbmRsZU91dHB1dChlbC52YWx1ZSwga2FsYWFtKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIC8vaWYgdGhlIHZhbHVlIGZvdW5kIGlzIGEgTnVtYmVyCiAgICAgICAgICAgIGlmIChpc051bWJlcihlbC52YWx1ZSkpIHsKICAgICAgICAgICAgICBoYW5kbGVPdXRwdXQoZWwudmFsdWUsIGthbGFhbSk7CiAgICAgICAgICAgICAgYXNzaWduZWRfdmFyaWFibGVzLnB1c2goZWwubmFtZSk7CiAgICAgICAgICAgIH0gLy9pZiB0aGUgdmFsdWUgZm91bmQgaXMgb3BlcmF0aW9ucyBsaWtlIGFnZT0yMDIwLTE5OTYKICAgICAgICAgICAgZWxzZSBpZiAoaXNQdXJlRXZhbChlbC52YWx1ZSkpIHsKICAgICAgICAgICAgICAgIC8vd2UgYXJlIHVzaW5nIEphdmFzY3JpcHQncyBldmFsIGZ1bmN0aW9uIHRvIGNhbGN1bGF0ZSBkaXJlY3QgYXJpdGhtZXRpYyBvcGVyYXRpb25zCiAgICAgICAgICAgICAgICB2YXIgb3V0cHV0cHVyZSA9IGV2YWwoZWwudmFsdWUpOwogICAgICAgICAgICAgICAgZWwudmFsdWUgPSBvdXRwdXRwdXJlOwogICAgICAgICAgICAgICAgaGFuZGxlT3V0cHV0KGVsLnZhbHVlLCBrYWxhYW0pOwogICAgICAgICAgICAgICAgYXNzaWduZWRfdmFyaWFibGVzLnB1c2goZWwubmFtZSk7CiAgICAgICAgICAgICAgfSAvL1dlIHdpbGwgc2ltcGxpZnkgdGhpcyBjb25kaXRpb25zIGFzIHdlIG1vdmUgZm9yd2FyZAogICAgICAgICAgICAgIGVsc2UgaWYgKCFpc1B1cmVFdmFsKGVsLnZhbHVlKSAmJiAhaXNOdW1iZXIoZWwudmFsdWUpKSB7CiAgICAgICAgICAgICAgICAgIGlmICghKGVsLm5hbWUuaW5jbHVkZXMoJ10nKSAmJiBlbC5uYW1lLmluY2x1ZGVzKCdbJykpKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKGVsLnR5cGUgPT09ICdBcnJheScpIHsKICAgICAgICAgICAgICAgICAgICAgIGlmICghZWwudmFsdWUuaW5jbHVkZXMoJ1snKSkgewogICAgICAgICAgICAgICAgICAgICAgICBlbC52YWx1ZSA9ICdbJyArIGVsLnZhbHVlLnRvU3RyaW5nKCkgKyAnXSc7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICBoYW5kbGVPdXRwdXQoZWwudmFsdWUsIGthbGFhbSk7CiAgICAgICAgICAgICAgICAgICAgYXNzaWduZWRfdmFyaWFibGVzLnB1c2goZWwubmFtZSk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0pOyAvL1RoaXMgaXMgaG93IHdlIHByaW50IEFycmF5IGluIEthbGFhbQoKICAgICAgaWYgKFRva2Vuc1tqICsgMV0udHlwZSA9PT0gJ0FycmF5JykgewogICAgICAgIC8vVG8gcnVuIG9ubHkgaWYgaXRlcmF0b3IgaXMgcHJlc2VudAogICAgICAgIC8vVGhpcyBydW5zIG9uIGZvciBsb29wIC0g4KSm4KS/4KSW4KS+4KSPKEFycmF5W2FdKSBldGMKICAgICAgICAvL3NlbGYgcnVucyBvbmx5IGlmIGZvcihpKSBhbmQgaW4gdGhlIGxvb3AsIGFycmF5W2ldLCBub3Qgb24gYXJyYXlbeF0uIEZvciBsb29wIEl0ZXJhdG9yIGFuZCBpbmRleCBzaG91bGQgYmUgc2FtZSwgaW4gc2VsZiBjYXNlICdpJwogICAgICAgIGlmIChpdGVyYXRvciAhPSB1bmRlZmluZWQgJiYgVG9rZW5zW2ogKyAxXS5JbmRleElucHV0ID09PSBPcmlnaW5hbEl0ZXJhdG9yKSB7CiAgICAgICAgICB2YXIgVmFsdWUgPSBOZXh0VG9rZW5WYWx1ZTsKICAgICAgICAgIHZhciBBcnJheUVsZW1lbnQgPSBDcmVhdGVBcnJheUVsZW1lbnQoVmFsdWUsIGl0ZXJhdG9yKTsKICAgICAgICAgIHZhciBvdXRwdXQgPSBHZXRBcnJheW9yU3RyaW5nRWxlbWVudChBcnJheUVsZW1lbnQsIG1lbW9yeSk7CiAgICAgICAgICBvdXRwdXQgPSBSZW1vdmVRdW90ZXMob3V0cHV0KTsKICAgICAgICAgIGhhbmRsZU91dHB1dChvdXRwdXQsIGthbGFhbSk7CiAgICAgICAgICBhc3NpZ25lZF92YXJpYWJsZXMucHVzaChUb2tlbnNbaiArIDFdKTsKICAgICAgICB9IC8vVGhpcyBydW5zIHRvIFByaW50KEFycmF5WzJdKSBsaWtlIHNwZWNpZmljIGFycmF5IHZhbHVlcwogICAgICAgIGVsc2UgaWYgKFRva2Vuc1tqICsgMV0uSW5kZXhJbnB1dCAhPSBPcmlnaW5hbEl0ZXJhdG9yKSB7CiAgICAgICAgICAgIHZhciBfVmFsdWUgPSBOZXh0VG9rZW5WYWx1ZTsKICAgICAgICAgICAgdmFyIEluZGV4VG9DaGFuZ2UgPSBUb2tlbnNbaiArIDFdLkluZGV4SW5wdXQ7CgogICAgICAgICAgICB2YXIgX0FycmF5RWxlbWVudCA9IENyZWF0ZUFycmF5RWxlbWVudChfVmFsdWUsIEluZGV4VG9DaGFuZ2UpOwoKICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBfQXJyYXlFbGVtZW50LnJlcGxhY2UoJ10nLCAnJyk7CgogICAgICAgICAgICB2YXIgU3BsaXQgPSBlbGVtZW50LnNwbGl0KCdbJyk7CgogICAgICAgICAgICBpZiAoU3BsaXRbMV0uaW5jbHVkZXMoJy0nKSB8fCBTcGxpdFsxXS5pbmNsdWRlcygnKycpKSB7CiAgICAgICAgICAgICAgdmFyIF9vdXRwdXQyID0gQ2FsY3VsYXRlVmFsdWVzKFNwbGl0WzFdLCBqLCBtZW1vcnkpOwoKICAgICAgICAgICAgICBTcGxpdFsxXSA9IF9vdXRwdXQyOwogICAgICAgICAgICAgIFNwbGl0ID0gU3BsaXQuam9pbignWycpICsgJ10nOwogICAgICAgICAgICAgIF9BcnJheUVsZW1lbnQgPSBTcGxpdDsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgdmFyIF90b2tlbiA9IG1lbW9yeS5maW5kKGZ1bmN0aW9uIChlbCkgewogICAgICAgICAgICAgIHJldHVybiBlbC5uYW1lID09PSBTcGxpdFsxXTsKICAgICAgICAgICAgfSk7CgogICAgICAgICAgICBpZiAoX3Rva2VuICE9IHVuZGVmaW5lZCAmJiBPcmlnaW5hbEl0ZXJhdG9yICE9IFNwbGl0WzFdKSB7CiAgICAgICAgICAgICAgU3BsaXRbMV0gPSBfdG9rZW4udmFsdWU7CiAgICAgICAgICAgICAgU3BsaXQgPSBTcGxpdC5qb2luKCdbJykgKyAnXSc7CiAgICAgICAgICAgICAgX0FycmF5RWxlbWVudCA9IFNwbGl0OwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIF9BcnJheUVsZW1lbnQgPSBfQXJyYXlFbGVtZW50OyAvLy8vCiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIHZhciBfb3V0cHV0ID0gR2V0QXJyYXlvclN0cmluZ0VsZW1lbnQoX0FycmF5RWxlbWVudCwgbWVtb3J5KTsKCiAgICAgICAgICAgIGhhbmRsZU91dHB1dChfb3V0cHV0LCBrYWxhYW0pOwogICAgICAgICAgfQogICAgICB9IC8vcHJpbnRpbmcgZGlyZWN0IG51bWJlcnMgYW5kIGRpcmVjdCBjYWxjdWx0aW9ucyBsaWtlIHByaW50KDEwKSwgcHJpbnQoMTAqMTApCiAgICAgIGVsc2UgaWYgKHRva2VuID09PSBBY3RpdmVMYW5ndWdhZUtleXdvcmRzLlByaW50ICYmIChpc1B1cmVFdmFsKFJlbW92ZUJyYWNrZXRzKE5leHRUb2tlblZhbHVlKSkgfHwgaXNOdW1iZXIoUmVtb3ZlQnJhY2tldHMoTmV4dFRva2VuVmFsdWUpKSkpIHsKICAgICAgICAgIE5leHRUb2tlblZhbHVlID0gUmVtb3ZlQnJhY2tldHMoTmV4dFRva2VuVmFsdWUpOwoKICAgICAgICAgIGlmIChpc051bWJlcihOZXh0VG9rZW5WYWx1ZSkgJiYgVG9rZW5zW2ogKyAxXS50eXBlICE9ICdDYWxjdWxhdGlvbicpIHsKICAgICAgICAgICAgaGFuZGxlT3V0cHV0KE5leHRUb2tlblZhbHVlLCBrYWxhYW0pOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdmFyIGEgPSBldmFsKE5leHRUb2tlblZhbHVlKTsKICAgICAgICAgICAgaGFuZGxlT3V0cHV0KGEsIGthbGFhbSk7CiAgICAgICAgICB9CiAgICAgICAgfSAvL2Zvcm9wZXJhdGlvbnMgbGlrZSBwcmludCgneW91IGxpdmUsIHlvdSBsZWFybicpCiAgICAgICAgZWxzZSBpZiAoVG9rZW5zW2ogKyAxXS5tb2RlID09PSAnUmVhbFRpbWVQcmludCcgJiYgIU5leHRUb2tlblZhbHVlLmluY2x1ZGVzKCcrJykKICAgICAgICAgIC8qJiYgIU5leHRUb2tlblZhbHVlLmluY2x1ZGVzKCc9JykqLwogICAgICAgICAgKSB7CiAgICAgICAgICAgICAgdmFyIF9vdXRwdXQzID0gUmVtb3ZlQnJhY2tldHMoTmV4dFRva2VuVmFsdWUpOwoKICAgICAgICAgICAgICBfb3V0cHV0MyA9IFJlbW92ZVF1b3Rlcyhfb3V0cHV0Myk7CiAgICAgICAgICAgICAgaGFuZGxlT3V0cHV0KF9vdXRwdXQzICsgJ1xuJywga2FsYWFtKTsKICAgICAgICAgICAgfSAvL29wZXJhdGlvbnMgbGlrZSBwcmludChBZ2UgKyAnaXMgeW91bmcgYWdlJykgaS5lIHN0cmluZyBjb25jYXRlbmF0aW9ucwogICAgICAgICAgZWxzZSBpZiAoVG9rZW5zW2ogKyAxXS5tb2RlID09PSAnUmVhbFRpbWVQcmludCcgJiYgTmV4dFRva2VuVmFsdWUuaW5jbHVkZXMoJysnKSkgewogICAgICAgICAgICAgIHZhciB4ID0gU3BsaXRFbGVtZW50c0FycmF5KE5leHRUb2tlblZhbHVlKTsKICAgICAgICAgICAgICB4ID0geC5qb2luKCcnKS5zcGxpdCgnKycpOwogICAgICAgICAgICAgIFN0cmluZ1ZhciA9IFNldFZhbHVlcyh4LCBtZW1vcnkpOwoKICAgICAgICAgICAgICB2YXIgX291dHB1dDQgPSBTdHJpbmdWYXIuam9pbignICcpOwoKICAgICAgICAgICAgICBfb3V0cHV0NCA9IFJlbW92ZUJyYWNrZXRzKF9vdXRwdXQ0KTsKICAgICAgICAgICAgICBfb3V0cHV0NCA9IFJlbW92ZVF1b3Rlcyhfb3V0cHV0NCk7CiAgICAgICAgICAgICAgaGFuZGxlT3V0cHV0KF9vdXRwdXQ0ICsgJ1xuJywga2FsYWFtKTsKICAgICAgICAgICAgfSBlbHNlIGlmIChpc0NhbGN1bGF0aW9uKFJlbW92ZUJyYWNrZXRzKE5leHRUb2tlblZhbHVlKSkgJiYgVG9rZW5zW2ogKyAxXS5tb2RlICE9ICdSZWFsVGltZVByaW50JykgewogICAgICAgICAgICAgIE5leHRUb2tlblZhbHVlID0gUmVtb3ZlQnJhY2tldHMoTmV4dFRva2VuVmFsdWUpOwoKICAgICAgICAgICAgICB2YXIgX291dHB1dDUgPSBDYWxjdWxhdGVWYWx1ZXMoTmV4dFRva2VuVmFsdWUsIGosIG1lbW9yeSk7CgogICAgICAgICAgICAgIGhhbmRsZU91dHB1dChfb3V0cHV0NSArICdcbicsIGthbGFhbSk7CiAgICAgICAgICAgIH0KCiAgICAgIHZhciBtZXNzYWdlID0gJyBDb21wdXRlciDgpKjgpYcg4KSG4KSq4KSV4KWAIOCkpuClgCDgpJfgpK/gpYAg4KS14KWI4KSy4KWN4KSv4KWCLCAnICsgJyInICsgUmVtb3ZlQnJhY2tldHMoTmV4dFRva2VuVmFsdWUpICsgJyInICsgJyDgpJXgpYsg4KSm4KS/4KSW4KS+4KSv4KS+IOCkueCliCB8JzsgLy9UaGlzIGlzIHRoZSBleHBlcmVzc2lvbiB3aGNpaCBpcyBnZXR0aW5nIGV2YWx1YXRlZC4KCiAgICAgIHZhciBleHByZXNzaW9uID0gdG9rZW4gKyBOZXh0VG9rZW5WYWx1ZTsKICAgICAgdmFyIGRlc2NyaXB0aW9uID0gJ+CkleCkv+CkuOClgCBWQUxVRSDgpJXgpYsgT1VUUFVUIFNDUkVFTiDgpKrgpYcg4KSm4KS/4KSW4KS+4KSo4KWHIOCkleClhyDgpLLgpL/gpI8g4KSm4KS/4KSW4KS+4KSPKCkg4KSV4KS+IOCkieCkquCkr+Cli+CklyDgpLngpYvgpKTgpL4g4KS54KWI4KWkJzsKICAgICAgZXhwcmVzc2lvbiA9IEdldGNsZWFuZWRFeHByZXNzaW9uKGV4cHJlc3Npb24pOwogICAgICB2YXIgcG9zaXRpb24gPSBmaW5kdG9rZW5Qb3NpdGlvbmluQ29kZShMaW5lYnlsaW5lU291cmNlZGF0YSwgZXhwcmVzc2lvbiwgdHJ1ZSk7CgogICAgICBpZiAocG9zaXRpb24gIT0gdW5kZWZpbmVkKSB7CiAgICAgICAgQWRkdG9FeGVjdXRpb25TdGFjayhFeGVjdXRpb25TdGFjaywgQWN0aXZlTGFuZ3VnYWVLZXl3b3Jkcy5QcmludCwgZGVzY3JpcHRpb24sIFZhcmlhYmxlVG9QcmludCwgbnVsbCwgbWVzc2FnZSwgcG9zaXRpb24pOwogICAgICB9CiAgICB9OyAvL0VORCBPRiBGdW5jdGlvbnMgYW5kIEltcG9ydGVkIEZ1bmN0aW9ucwogICAgLy9PdXQgb2YgYWxsIHNlbGYgZnVuY3Rpb24sIFByaW50RW5naW5lIGlzIHZlcnkgaW1wb3J0YW50IGZ1bmN0aW9uLiBJdCBwcmludHMgdmFyaWFibGUgdmFsdWVzIGJ5IHNlYXJjaGluZyB0aGVpciB2YWx1ZSBpbiBtZW1vcnkuCiAgICAvL1NFQ1RJT04gLSBDaGVja2luZyBlYWNoIHRva2VuIGFuZCBhZGRpbmcgdG8gdG9rZW5zIGFycmF5CiAgICAvL190b2tlbnMgdGFrZXMgdHdvIGFyZ3VtZW50cy4gVGhlIGNsZWFuZWRfc291cmNlZGF0YSBhcnJheSBhbmQgY3VycmVudCBpbmRleCBvZiBjbGVhbmVkX3NvdXJjZWRhdGEgYXJyYXkKICAgIC8vX3Rva2VucyBpcyB1c2VkIHRvIGNyZWF0ZSBhIHRva2VucyBhcnJheSB3aXRoIGVhY2ggdG9rZW4gaGF2aW5nIGl0J3MgbmFtZSwgdmFsdWUsIHR5cGUgYW5kIG90aGVyIG1ldGFkYXRhCiAgICAvL0l0IHBlcmZvcm1zIG9wZXJhdGlvbnMgZGVwZW5kaW5nIHVwb24gd2hldGhlciB0aGUgZWxlbWVudCBpcyB2YXJpYWJsZSwgYXJyYXksIGZ1bmN0aW9uLCBsb29wIGV0Yy4KICAgIC8vc2Nhbm5pbmcgZXZlcnkgc2luZ2xlIGVsZW1lbnQgZnJvbSBjbGVhbmVkX3NvdXJjZWRhdGEgYXJyYXkgYW5kIHB1c2hpbmcgaXQgdG8gVG9rZW5zIGRlcGVuZGluZyB1cG9uIHRoZSB0eXBlIHBmIGVsZW1lbnQKCgogICAgdmFyIF9hbmFseXplVG9rZW4gPSBmdW5jdGlvbiBfYW5hbHl6ZVRva2VuKGNsZWFuZWRfc291cmNlZGF0YSwgaSwgdG9rZW5zKSB7CiAgICAgIHZhciBlbGVtZW50ID0gY2xlYW5lZF9zb3VyY2VkYXRhW2ldOwogICAgICBza2lwUGFyc2luZyA9IDA7CiAgICAgIHZhciBuZXh0RWwgPSBjbGVhbmVkX3NvdXJjZWRhdGEubmV4dEVsZW1lbnQoaSk7CiAgICAgIHZhciBwcmV2RWwgPSBjbGVhbmVkX3NvdXJjZWRhdGEucHJldkVsZW1lbnQoaSk7CiAgICAgIHZhciB0b2tlbl90eXBlID0gc2Nhbm5lcihjbGVhbmVkX3NvdXJjZWRhdGEsIGksIHRva2Vucyk7CiAgICAgIGNvbnNvbGUubG9nKCd0b2tlbl90eXBlOicsIHRva2VuX3R5cGUpOyAvL1B1c2ggdmFyaWFibGVzIHRvIHRva2VucwogICAgICAvL0Zvcm1hdDoge3R5cGU6ICJ2YXJpYWJsZSIsIHZhbHVlOiAiUmV2ZXJzZVN0cmluZyJ9CiAgICAgIC8vd2hlbmV2ZXIgd2UgbmVlZCBhIGNlcnRhaW4gaGFuZGxpbmcsIGhhbmRsZXJzLmpzIGlzIHVzZWQKCiAgICAgIHN3aXRjaCAodG9rZW5fdHlwZSkgewogICAgICAgIGNhc2UgJ1ZBUklBQkxFJzoKICAgICAgICAgIC8vSGVyZSB3ZSBzZXBlcmF0ZSBNZXNzYWdlID0gJ0hlbGxvJyBpbnRvIGZvbGxvd2luZyB0aHJlZSB0b2tlbnMgOgogICAgICAgICAgLy8xOsKge3R5cGU6wqAidmFyaWFibGUiLMKgdmFsdWU6wqAiTWVzc2FnZSJ9CiAgICAgICAgICAvLzI6wqB7dHlwZTrCoCJvcGVyYXRvciIswqB2YWx1ZTrCoCI9In0KICAgICAgICAgIC8vMzrCoHt0eXBlOsKgInZhbHVlIizCoHZhbHVlOsKgIkhlbGxvIn0KICAgICAgICAgIHZhciBoYW5kbGVkX3ZhcmlhYmxlID0gaGFuZGxlVmFyaWFibGUoZWxlbWVudCwgdG9rZW5zLCBjbGVhbmVkX3NvdXJjZWRhdGEsIGksIG5leHRFbCwgcHJldkVsKTsKICAgICAgICAgIHZhciBoID0gaGFuZGxlZF92YXJpYWJsZTsKCiAgICAgICAgICBpZiAoaCAhPSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICBoLnR5cGUgPT09ICd2YXJpYWJsZScgPyBQdXNoVmFyaWFibGUoaCwgdG9rZW5zKSA6IGNvbnNvbGUubG9nKCJlcnJvciBpbiBzZXR0aW5nICIuY29uY2F0KGVsZW1lbnQpKTsKICAgICAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUsICJlcnJvciBpbiBzZXR0aW5nICIuY29uY2F0KGVsZW1lbnQpKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQoKICAgICAgICAgIGJyZWFrOwogICAgICAgIC8vUHVzaCB2YXJpYWJsZXMgdG8gdG9rZW5zCgogICAgICAgIGNhc2UgJ05VTUJFUic6CiAgICAgICAgICBQdXNoTnVtYmVyKGVsZW1lbnQsIHRva2Vucyk7CiAgICAgICAgICBicmVhazsKICAgICAgICAvL1B1c2ggRW1wdHlTdHJpbmdzIHRvIHRva2VucwoKICAgICAgICBjYXNlICdFTVBUWV9TVFJJTkcnOgogICAgICAgICAgLy9JbiBzb21lIGNhc2VzIGVtcHR5IHN0cmluZ3Mgd2lsbCBiZSBtb2RpZmllZCBpbnRvIHNvbWV0aGluZyBsaWtlICInIiBvciAnIicKICAgICAgICAgIC8vV2UgY29udmVydCBpdCBiYWNrIHRvICIgIgogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgdmFyIGUgPSBlbGVtZW50OwogICAgICAgICAgICBlID0gZS5sZW5ndGggPiAxICYmIChlLmNoYXJBdCgwKSA9PT0gJ1wnJyB8fCBlLmNoYXJBdCgwKSA9PT0gJyInKSA/IGUgPSBlLnJlcGxhY2UoL1snIl0rL2csICcnKSA6IGUgPSAnICc7CiAgICAgICAgICAgIFB1c2hWYXJpYWJsZVZhbHVlKGUsIHRva2Vucyk7CiAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUsICJFcnJvciBpbiBzZXR0aW5nIEVtcHR5IHN0cmluZyAiLmNvbmNhdChlbGVtZW50KSk7CiAgICAgICAgICB9CgogICAgICAgICAgYnJlYWs7CiAgICAgICAgLy9QdXNoIElucHV0IHRvIHRva2VucwogICAgICAgIC8vRm9ybWF0OiB7dHlwZTrCoCJBY2NlcHRJbnB1dCIswqB2YWx1ZTrCoCIgIizCoEFjY2VwdEFzOsKgIk1lc3NhZ2UifQoKICAgICAgICBjYXNlICdJTlBVVCc6CiAgICAgICAgICB0cnkgewogICAgICAgICAgICBQdXNoSW5wdXQoZWxlbWVudCwgdG9rZW5zLCBjbGVhbmVkX3NvdXJjZWRhdGEsIGkpOwogICAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICBjb25zb2xlLmxvZyhlLCAiRXJyb3IgaW4gc2V0dGluZyBJbnB1dCAiLmNvbmNhdChlbGVtZW50KSk7CiAgICAgICAgICB9CgogICAgICAgICAgYnJlYWs7CiAgICAgICAgLy9QdXNoIG9wZXJhdG9ycyB0byB0b2tlbnMuIFRoZSBhY2NlcHRlZCBvcGVyYXRvcnMgYXJlID0sfSx7CiAgICAgICAgLy9Gb3JtYXQ6wqB7dHlwZTrCoCJvcGVyYXRvciIswqB2YWx1ZTrCoCI9In0KCiAgICAgICAgY2FzZSAnT1BFUkFUT1InOgogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgUHVzaE9wZXJhdG9yKGVsZW1lbnQsIHRva2Vucyk7CiAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUsICJFcnJvciBpbiBzZXR0aW5nIG9wZXJhdG9yICIuY29uY2F0KGVsZW1lbnQpKTsKICAgICAgICAgIH0KCiAgICAgICAgICBicmVhazsKICAgICAgICAvL1B1c2gga2V5b3dyZHMgdG8gdG9rZW5zLiBUaGUgYWNjZXB0ZWQga2V5d29yZHMgaXMg4KSm4KS/4KSW4KS+4KSPCiAgICAgICAgLy9Gb3JtYXQ6IHt0eXBlOsKgImtleXdvcmQiLMKgdmFsdWU6wqBBY3RpdmVMYW5ndWdhZUtleXdvcmRzLlByaW50fQoKICAgICAgICBjYXNlICdQUklOVCc6CiAgICAgICAgICB0cnkgewogICAgICAgICAgICBQdXNoS2V5d29yZChlbGVtZW50LCB0b2tlbnMpOwogICAgICAgICAgICB2YXIgRXhwcmVzc2lvbnRvUHJpbnQgPSBuZXh0RWw7CgogICAgICAgICAgICBpZiAoIWlzUmVhbFRpbWVQcmludE11bHRpcGxlU3RyaW5nKEV4cHJlc3Npb250b1ByaW50KSkgewogICAgICAgICAgICAgIFB1c2hFeHByZXNzaW9uKEV4cHJlc3Npb250b1ByaW50LCB0b2tlbnMpOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUsICJFcnJvciBpbiBwcmludGluZyAiLmNvbmNhdChlbGVtZW50KSk7CiAgICAgICAgICB9CgogICAgICAgICAgYnJlYWs7CiAgICAgICAgLy9QdXNoIGZ1bmN0aW9ucyB0byB0b2tlbnMKICAgICAgICAvL0Zvcm1hdDoge3R5cGU6ICJmdW5jdGlvbiIsIHZhbHVlOiAiRmlyc3QiLCBhcmd1bWVudHM6IEFycmF5KDIpLCBGdW5jdGlvbkludm9jYXRpb25FeGlzdHM6IGZhbHNlLCBGdW5jdGlvblN0YWNrOiBBcnJheSgwKSwg4oCmfQoKICAgICAgICBjYXNlICdGVU5DVElPTic6CiAgICAgICAgICB0cnkgewogICAgICAgICAgICBQdXNoRnVuY3Rpb25EYXRhKGVsZW1lbnQsIHRva2VucywgY2xlYW5lZF9zb3VyY2VkYXRhLCBpKTsKICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgY29uc29sZS5sb2coZSwgIkVycm9yIGluIGhhbmRsaW5nIGZ1bmN0aW9uICIuY29uY2F0KGVsZW1lbnQpKTsKICAgICAgICAgIH0KCiAgICAgICAgICBicmVhazsKICAgICAgICAvLyBQdXNoIGFycmF5IHRvIHRva2VucwoKICAgICAgICBjYXNlICdBUlJBWSc6CiAgICAgICAgICAvL0Zvcm1hdDoge3R5cGU6ICJBcnJheSIsIHZhbHVlOiAiW10ifQogICAgICAgICAgLy9pZiBlbXB0eSBhcnJheSBlbHNlIGJ1aWxkIHRoZSBhcnJheSAoVG8gY29udmVydCAnWycsMSwyLDMsNCwnXScgIGludG8gWzEsMiwzLDRdCiAgICAgICAgICB0cnkgewogICAgICAgICAgICB2YXIgX2UgPSBlbGVtZW50OwogICAgICAgICAgICBfZS5jaGFyQXQoX2UubGVuZ3RoIC0gMSkgPT09ICddJyA/IFB1c2hBcnJheShfZSwgdG9rZW5zKSA6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICB2YXIgQnVpbHRBcnJheSA9IEJ1aWxkQXJyYXkoX2UsIGksIGNsZWFuZWRfc291cmNlZGF0YSk7CiAgICAgICAgICAgICAgUHVzaEFycmF5KEJ1aWx0QXJyYXksIHRva2Vucyk7CiAgICAgICAgICAgIH07CiAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUsICJFcnJvciBpbiBoYW5kbGluZyBBcnJheSAiLmNvbmNhdChlbGVtZW50KSk7CiAgICAgICAgICB9CgogICAgICAgICAgYnJlYWs7CiAgICAgICAgLy9Gb3Igb3BlcmF0aW9ucyBsaWtlIE51bWJlcnNbYV09YQogICAgICAgIC8vRm9ybWF0OiB7dHlwZTrCoCJTZXRBcnJheUluZGV4VmFsdWUiLMKgdmFsdWU6wqAiRmlib25hY2NpW2FdIizCoFZhbHVlVG9TZXQ6wqAiYSJ9CgogICAgICAgIGNhc2UgJ1NFVF9BUlJBWV9JTkRFWCc6CiAgICAgICAgICB0cnkgewogICAgICAgICAgICBQdXNoU2V0QXJyYXlJbmRleFZhbHVlKGVsZW1lbnQsIHRva2VucywgY2xlYW5lZF9zb3VyY2VkYXRhLCBpKTsKICAgICAgICAgICAgY2xlYW5lZF9zb3VyY2VkYXRhLnNwbGljZShpICsgMSwgMSk7CiAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUsICJFcnJvciBpbiBzZXR0aW5nIGFycmF5IGluZGV4IHZhbHVlICIuY29uY2F0KGVsZW1lbnQpKTsKICAgICAgICAgIH0KCiAgICAgICAgICBicmVhazsKICAgICAgICAvL0ZvciBvcGVyYXRpb25zIGxpa2UgYT1OdW1iZXJzW2FdLCByZXZlcnNlIG9mIGFib3ZlCiAgICAgICAgLy9Gb3JtYXQ6IHt0eXBlOsKgIkdldEFycmF5SW5kZXhWYWx1ZSIswqB2YWx1ZTrCoCJGaWJvbmFjY2lbYS0yXSJ9CgogICAgICAgIGNhc2UgJ0dFVF9BUlJBWV9JTkRFWCc6CiAgICAgICAgICB0cnkgewogICAgICAgICAgICBQdXNoR2V0QXJyYXlJbmRleFZhbHVlKGVsZW1lbnQsIHRva2VucywgY2xlYW5lZF9zb3VyY2VkYXRhLCBpKTsKICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgY29uc29sZS5sb2coZSwgIkVycm9yIGluIGdldHRpbmcgYXJyYXkgaW5kZXggdmFsdWUgIi5jb25jYXQoZWxlbWVudCkpOwogICAgICAgICAgfQoKICAgICAgICAgIGJyZWFrOwogICAgICAgIC8vUHVzaCBjb25kaXRpb25zIHRvIHRva2Vucy4gVGhlIGFjY2VwdGVkIGtleXdvcmRzIGFyZSDgpIXgpJfgpLAsIOCknOCkrOCkpOCklSwg4KSF4KSo4KWN4KSv4KSl4KS+CiAgICAgICAgLy8gRm9ybWF0OiB7dHlwZTrCoCJjb25kaXRpb25hbGtleXdvcmQiLMKgdmFsdWU6wqAi4KSF4KSX4KSwIn0KICAgICAgICAvL1B1c2ggd2hpbGUgbG9vcHMgdG8gdG9rZW5zCiAgICAgICAgLy9Gb3JtYXQ6IHt0eXBlOiAiV2hpbGVMb29wU3RhcnQiLCB2YWx1ZTogIuCknOCkrOCkpOCklSJ9LCB7dHlwZTogImNvbmRpdGlvbiIsIHZhbHVlOiAiY291bnQ8MjUifQoKICAgICAgICBjYXNlICdDT05ESVRJT05BTF9LRVlXT1JEJzoKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIGlzV2hpbGVMb29wKGVsZW1lbnQpID8gUHVzaFdoaWxlTG9vcChlbGVtZW50LCB0b2tlbnMpIDogUHVzaENvbmRpdGlvbmFsS2V5d29yZChlbGVtZW50LCB0b2tlbnMpOyAvL1RoaXMgaXMgaG93IHdlIHB1c2ggY29uZGl0aW9ucyBlbmNvdW50ZXJlZCBpbiB0aGUgc291cmNlY29kZQogICAgICAgICAgICAvL0Zvcm1hdDp7dHlwZTrCoCJjb25kaXRpb24iLMKgdmFsdWU6wqAiYTwzIn0KCiAgICAgICAgICAgIHZhciBmb3VuZGNvbmRpdGlvbiA9IEJ1aWxkQ29uZGl0aW9uKGVsZW1lbnQsIGksIGNsZWFuZWRfc291cmNlZGF0YSk7IC8vUHVzaCBjb25kaXRpb25zIHRvIHRva2VucyBhcnJheQoKICAgICAgICAgICAgaWYgKGZvdW5kY29uZGl0aW9uICE9ICcnKSB7CiAgICAgICAgICAgICAgUHVzaENvbmRpdGlvbihmb3VuZGNvbmRpdGlvbiwgdG9rZW5zKTsKICAgICAgICAgICAgfQogICAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICBjb25zb2xlLmxvZyhlLCAiRXJyb3IgaW4gb3BlcmF0aW5nIG9uIGNvbmRpdGlvbmFscyAiLmNvbmNhdChlbGVtZW50KSk7CiAgICAgICAgICB9CgogICAgICAgICAgYnJlYWs7CiAgICAgICAgLy9GaW5kaW5nIG9wZXJhdGlvbnMgbGlrZSBOdW1iZXJzLuCkquClgeCktih4KQogICAgICAgIC8vRm9ybWF0OiB7dHlwZTogIlB1c2hUb0FycmF5IiwgdmFsdWU6ICJOdW1iZXJzLuCkquClgeCktih4KSJ9CgogICAgICAgIGNhc2UgJ1BVU0hfVE9fQVJSQVknOgogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgUHVzaFRvQXJyYXkoZWxlbWVudCwgdG9rZW5zKTsKICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgY29uc29sZS5sb2coZSwgIkVycm9yIGluIHB1c2hpbmcgdGhlIHZhbHVlcyB0byBhcnJheSAiLmNvbmNhdChlbGVtZW50KSk7CiAgICAgICAgICB9CgogICAgICAgICAgYnJlYWs7CiAgICAgICAgLy9QdXNoIEZvciBsb29wIHRvIHRva2VucwogICAgICAgIC8vIEZvcm1hdDoKICAgICAgICAvLyB7dHlwZTrCoCJGb3JMb29wU3RhcnQiLMKgdmFsdWU6wqAi4KSm4KWB4KS54KSw4KS+4KSTIn0KICAgICAgICAvL8Kge3R5cGU6wqAiRm9yTG9vcEFyZ3VtZW50cyIswqBpdGVyYXRvcjrCoCJhIizCoHZhbHVlOsKgIigwLDI1KSIswqBpdGVyYXRpb25TdGFydDrCoCIwIizCoGl0ZXJhdGlvbkVuZDrCoCIyNSJ9CgogICAgICAgIGNhc2UgJ0ZPUl9MT09QJzoKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIFB1c2hGb3JMb29wKGVsZW1lbnQsIHRva2Vucyk7CiAgICAgICAgICAgIFB1c2hGb3JMb29wQXJ1Z3VtZW50cyhlbGVtZW50LCBjbGVhbmVkX3NvdXJjZWRhdGEsIGksIHRva2Vucyk7CiAgICAgICAgICAgIG1lbW9yeS5wdXNoKHsKICAgICAgICAgICAgICBuYW1lOiBuZXh0RWwsCiAgICAgICAgICAgICAgdmFsdWU6IDAsCiAgICAgICAgICAgICAgdHlwZTogJ0Zvckxvb3BJdGVyYXRvcicKICAgICAgICAgICAgfSk7CiAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUsICJFcnJvciBpbiBvcGVyYXRpbmcgb24gZm9yIGxvb3AgIi5jb25jYXQoZWxlbWVudCkpOwogICAgICAgICAgfQoKICAgICAgICAgIGJyZWFrOwogICAgICAgIC8vUHVzaGluZyBiYXNpYyBDYWxjdWxhdGlvbnMgbGlrZSAnbGVuZ3RoLTEnIHRvIHRva2VucwogICAgICAgIC8vRm9ybWF0OiB7dHlwZTrCoCJDYWxjdWxhdGlvbiIswqB2YWx1ZTrCoCJsZW5ndGgtMSJ9CgogICAgICAgIGNhc2UgJ0NBTENVTEFUSU9OJzoKICAgICAgICAgIC8qIHJlZCB6b25lCiAgICAgICAgICBpZiAobmV4dEVsICE9IHVuZGVmaW5lZCkgewogICAgICAgICAgLy8gdGhpcyBpcyB0byBwZXJmb3JtIGxvbmcgY2FsY3VsYXRpb25zIGxpa2UgQXZlcmFnZUFnZT0oYWdlb25lK2FnZXR3bykvMiArIChhZ2VvbmUrYWdldHdvKSoyCiAgICAgICAgICB3aGlsZSAoaXNDYWxjdWxhdGlvbihjbGVhbmVkX3NvdXJjZWRhdGFbaV0pKSB7CiAgICAgICAgICBlbCA9IGVsICsgY2xlYW5lZF9zb3VyY2VkYXRhW2ldOwogICAgICAgICAgIGkrKzsKICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGNvbnNvbGUubG9nKCJlbDoiLCBlbCk7CiAgICAgICAgICAqLwoKICAgICAgICAgIC8qZXJyb3IgcHJvbmUqLwogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgdmFyIGlzTXVsdGlDYWxjdWxhdGlvbiA9IGZ1bmN0aW9uIGlzTXVsdGlDYWxjdWxhdGlvbihjKSB7CiAgICAgICAgICAgICAgdmFyIG9wID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnKisvLSc7CgogICAgICAgICAgICAgIGlmIChjLmluY2x1ZGVzKCcoJykgJiYgYy5pbmNsdWRlcygnKScpKSB7CiAgICAgICAgICAgICAgICB2YXIgcyA9IGMuc3BsaXQoJycpOwogICAgICAgICAgICAgICAgcy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkgewogICAgICAgICAgICAgICAgICBpZiAob3AuaW5jbHVkZXMoZWwpKSB7CiAgICAgICAgICAgICAgICAgICAgZCA9IGQgKyAxOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9KTsKCiAgICAgICAgICAgICAgICBpZiAoZCA+IDEpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9OwoKICAgICAgICAgICAgdmFyIGVsID0gZWxlbWVudDsKICAgICAgICAgICAgdmFyIGNhbCA9ICcnOwogICAgICAgICAgICB2YXIgY291bnQgPSAwOyAvLyAgIGZ1bmN0aW9uIGZpbmRDYWxjdWxhdGlvbihjbGVhbmVkX3NvdXJjZWRhdGEsIGkpIHsKCiAgICAgICAgICAgIHZhciB4ID0gaTsKICAgICAgICAgICAgdmFyIGQgPSAwOwoKICAgICAgICAgICAgd2hpbGUgKGlzQ2FsY3VsYXRpb24oY2xlYW5lZF9zb3VyY2VkYXRhW3hdKSB8fCBjbGVhbmVkX3NvdXJjZWRhdGFbeF0gPT0gJysnKSB7CiAgICAgICAgICAgICAgY2FsID0gY2FsICsgY2xlYW5lZF9zb3VyY2VkYXRhW3hdOwogICAgICAgICAgICAgIGNvdW50ICs9IDE7CiAgICAgICAgICAgICAgeCsrOwogICAgICAgICAgICB9CgogICAgICAgICAgICB2YXIgbXVsdGlDYWwgPSBpc011bHRpQ2FsY3VsYXRpb24oY2FsKTsgLy8gIGNvbnNvbGUubG9nKCJ4IiwgeCwgaSk7CgogICAgICAgICAgICBza2lwUGFyc2luZyA9IGNvdW50IC0gMTsgLy8gY2FsID0gUmVtb3ZlQnJhY2tldHMoY2FsKTsKICAgICAgICAgICAgLy9sZXQgY19lbCA9IFJlbW92ZUJyYWNrZXRzKGNhbCk7CiAgICAgICAgICAgIC8vICBsZXQgY2FsID0gZmluZENhbGN1bGF0aW9uKCk7CiAgICAgICAgICAgIC8vIHRvIHN0b3AgcHJldmVudGlvbiBvZiBleHByZXNzaW9ucyBsaWtlIGlzIisgZ2V0dGluZyBhZGRlZCBhcyBhIGNhbGN1bGF0aW9uCgogICAgICAgICAgICAhY2FsLmluY2x1ZGVzKCciJykgJiYgIVsnLycsICcqJywgJ1wnJywgJyInXS5pbmNsdWRlcyhlbC5jaGFyQXQoMCkpID8gUHVzaENhbGN1bGF0aW9uKGNhbCwgdG9rZW5zLCBjbGVhbmVkX3NvdXJjZWRhdGEsIGksIG11bHRpQ2FsKSA6IGNvbnNvbGUubG9nKCJpbXB1cmUgY2FsY3VsYXRpb24gdGVybXMgIi5jb25jYXQoZWwpKTsKICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgY29uc29sZS5sb2coZSwgIkVycm9yIGluIGNvbXBsZXRpbmcgY2FsY3VsYXRpb24gIi5jb25jYXQoZWxlbWVudCkpOwogICAgICAgICAgfQoKICAgICAgICAgIGJyZWFrOwoKICAgICAgICBjYXNlICdSRUFMVElNRV9QUklOVCc6CiAgICAgICAgICAvL2ZpbmRpbmcgb3BlcmF0aW9ucyBsaWtlIHByaW50KHggKyAneScpLiBUaGUgUmVhbFRpbWVQcmludCBvcGVyYXRpb25zCiAgICAgICAgICAvL0Zvcm1hdDoge3R5cGU6wqAidmFsdWUiLMKgdmFsdWU6wqAiKCdSZXZlcnNlZCBTdHJpbmctJysgUmV2ZXJzZVN0cmluZykiLMKgbW9kZTrCoCJSZWFsVGltZVByaW50In0KICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIHZhciBfaGFuZGxlUmVhbHRpbWVQcmludCA9IGhhbmRsZVJlYWx0aW1lUHJpbnQoY2xlYW5lZF9zb3VyY2VkYXRhLCBpKSwKICAgICAgICAgICAgICAgIGZvdW5kU3RyaW5nID0gX2hhbmRsZVJlYWx0aW1lUHJpbnQuZm91bmRTdHJpbmcsCiAgICAgICAgICAgICAgICBza2lwID0gX2hhbmRsZVJlYWx0aW1lUHJpbnQuc2tpcDsKCiAgICAgICAgICAgIFB1c2hSZWFsVGltZVByaW50T3BlcmF0aW9uKGZvdW5kU3RyaW5nLCB0b2tlbnMpOwogICAgICAgICAgICBza2lwUGFyc2luZyA9IHNraXA7CiAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUsICJFcnJvciBpbiByZWFsIHRpbWUgcHJpbnQgIi5jb25jYXQoZWxlbWVudCkpOwogICAgICAgICAgfQoKICAgICAgICAgIGJyZWFrOwoKICAgICAgICBjYXNlICdTVFJJTkcnOgogICAgICAgICAgLy9zdG9yaW5nIG9ubHkgdGhlIHN0cmluZyB2YWx1ZXMgdG8gdG9rZW5zICggbm90IHRoZSBzdHJpbmdzIGluIHByaW50IHN0YXRlbWVudHMpCiAgICAgICAgICB0cnkgewogICAgICAgICAgICB2YXIgcyA9IEJ1aWxkU3RyaW5nKGVsZW1lbnQsIGksIGNsZWFuZWRfc291cmNlZGF0YSk7CiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoL1snIl0rL2csICcnKTsKICAgICAgICAgICAgIXMuaW5jbHVkZXMoQWN0aXZlTGFuZ3VnYWVLZXl3b3Jkcy5QcmludCkgPyBQdXNoU3RyaW5nKHMsIHRva2VucykgOiBjb25zb2xlLmxvZygiZXJyb3IgaW4gcHVzaGluZyBzdHJpbmcgIi5jb25jYXQoKHMsIGVsZW1lbnQpKSk7CiAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUsICJlcnJvciBpbiBvcGVyYXRpbmcgb24gc3RyaW5nICIuY29uY2F0KGVsZW1lbnQpKTsKICAgICAgICAgIH0KCiAgICAgICAgICBicmVhazsKICAgICAgICAvL0FuIGV4dGVuc2lvbiBvZiBpc1ByaW50T3BlcmF0aW9uKCkgZnVuY3Rpb24KICAgICAgICAvLyBOZWVkcyBpbXByb3ZlbWVudAoKICAgICAgICAvKiAgICAgZWxzZSBpZiAoL14oPz0uKj/gpKbgpL/gpJbgpL7gpI8pKD89LipbYS16XSkvLnRlc3QoZWxlbWVudCkpIHsKICAgICAgICAKICAgICAgICAgICAgIFB1c2hLZXl3b3JkKGVsZW1lbnQuc2xpY2UoMCwgNiksIHRva2Vucyk7IC8vUHVzaGluZyBwcmludCBrZXl3b3JkIG9ubHkKICAgICAgICAgICAgIFB1c2hFeHByZXNzaW9uKGVsZW1lbnQuc2xpY2UoNiksIHRva2Vucyk7IC8vUHVzaGluZyByZW1haW5pbmcgZXhwcmVzc2lvbiBsaWtlIChhKSwgKE1lc3NhZ2UpIGV0YwogICAgICAgIH0KICAgICAgICAqLwogICAgICAgIC8vZXJyb3IgcHJvbmUgY2hhbmdlIG1hZGUgaGVyZS0gUHVzaGluZyBleHByZXNzaW9uIGluIGhlcmUKICAgICAgICAvL1VzZWQgdG8gcHVzaCBmdW5jdGlvbnMgYW5kIGV4cHJlc3Npb25zCiAgICAgICAgLy9Vbm5lY2Vzc2FyeSBkYXRhIGlzIGJlaW5nIHBhc3NlZCB0aHJvdWdoIGthbGFhbS4KICAgICAgICAvL1RoaXMgd2FzIGNyZWF0ZWQgZm9yIGEgdGVtcG9yYXJ5IGZpeAoKICAgICAgICBjYXNlICdGVU5DVElPTl9DQUxMJzoKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIHZhciBDaGVja0Z1bmN0aW9uRXhwcmVzc2lvbiA9IGVsZW1lbnQuc3BsaXQoJygnKTsKICAgICAgICAgICAgdmFyIHBhc3NlZFZhbHVlcyA9IFJlbW92ZUJyYWNrZXRzKENoZWNrRnVuY3Rpb25FeHByZXNzaW9uWzFdKTsKICAgICAgICAgICAgcGFzc2VkVmFsdWVzID0gcGFzc2VkVmFsdWVzLnNwbGl0KCcsJyk7CiAgICAgICAgICAgIFB1c2hGdW5jdGlvbkV4ZWN1dGlvbihlbGVtZW50LCB0b2tlbnMsIGNsZWFuZWRfc291cmNlZGF0YSwgaSwgcGFzc2VkVmFsdWVzKTsKICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgY29uc29sZS5sb2coZSwgImVycm9yIGluIHB1c2hpbmcgZnVuY3Rpb24gZXhlY3V0aW9uICIuY29uY2F0KGVsZW1lbnQpKTsKICAgICAgICAgIH0KCiAgICAgICAgICBicmVhazsKCiAgICAgICAgY2FzZSAnTkFUSVZFX09QRVJBVElPTic6CiAgICAgICAgICB0cnkgewogICAgICAgICAgICBQdXNoTmF0aXZlT3BlcmF0aW9uKGVsZW1lbnQsIHRva2Vucyk7CiAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUsICJlcnJvciBpbiBwdXNoaW5nIG5hdGl2ZSBvcGVyYWlvbiAiLmNvbmNhdChlbGVtZW50KSk7CiAgICAgICAgICB9CgogICAgICAgICAgYnJlYWs7CgogICAgICAgIGNhc2UgJ0FSUkFZX1BVU0gnOgogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgUHVzaEFycmF5KGVsZW1lbnQsIHRva2Vucyk7CiAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUsICJlcnJvciBpbiBhcnJheSBwdXNoICIuY29uY2F0KGVsZW1lbnQpKTsKICAgICAgICAgIH0KCiAgICAgICAgICBicmVhazsKICAgICAgfQogICAgfTsgLy9tYWtpbmcgc2Vuc2Ugb2YgdG9rZW5zIGFycmF5IGNvbWluZyBmcm9tIF9wYXJzZXIuCgoKICAgIHZhciBpbnRlcnByZXRUb2tlbiA9IGZ1bmN0aW9uIGludGVycHJldFRva2VuKHQsIGosIG1lbW9yeSkgewogICAgICBza2lwSW50ZXJwcmV0YXRpb24gPSAwOwogICAgICB2YXIgbXV0YWJsZV90b2tlbnMgPSB0OwogICAgICB2YXIgdG9rZW4gPSBtdXRhYmxlX3Rva2Vuc1tqXS52YWx1ZTsKICAgICAgdmFyIHRva2VuX3R5cGUgPSBtdXRhYmxlX3Rva2Vuc1tqXS50eXBlOwogICAgICB2YXIgdG9rZW5fc3VidHlwZSA9IG11dGFibGVfdG9rZW5zW2pdLnN1YnR5cGU7CiAgICAgIHZhciB0eXBlID0gdG9rZW4gPT09ICfgpKbgpL/gpJbgpL7gpI8nIHx8IHRva2VuX3R5cGUgPT09ICdvcGVyYXRvcicgPyB0b2tlbl9zdWJ0eXBlIDogdG9rZW5fdHlwZTsgLy9uZWVkIHRvIHNraXAgb3ZlciBzb21lIHVubmNlc3NhcnkgdHlwZXMKICAgICAgLy9vcGVyYXRvcnMgYXJlIG5vdCB3b3JraW5nIGNvcnJlY3RseQogICAgICAvLyBubyBuZWVkIHRvIGludGVycHJldCBvdmVyIG5vbi10eXBlcwoKICAgICAgdHJ5IHsKICAgICAgICBpZiAoaXNJbnRlcnByZXRhYmxlVHlwZSh0eXBlKSkgewogICAgICAgICAgc3dpdGNoICh0eXBlKSB7CiAgICAgICAgICAgIGNhc2UgJ1NldEFycmF5SW5kZXhWYWx1ZSc6CiAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgU2V0QXJyYXlJbmRleFZhbHVlKG11dGFibGVfdG9rZW5zLCBqLCBqLCBtZW1vcnksIHRva2VucywgT3JpZ2luYWxJdGVyYXRvciwgaXRlcmF0b3IsIEV4ZWN1dGlvblN0YWNrLCBMaW5lYnlsaW5lU291cmNlZGF0YSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgY2FzZSAnYXNzaWdubWVudCc6CiAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgQXNzaWdub3JVcGRhdGVWYWx1ZXMobXV0YWJsZV90b2tlbnMsIGosIG1lbW9yeSwgaXRlcmF0b3IsIE9yaWdpbmFsSXRlcmF0b3IsIGthbGFhbSwgRXhlY3V0aW9uU3RhY2ssIExpbmVieWxpbmVTb3VyY2VkYXRhKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZQoKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgLy90eXBlPWFzc2lnbm1lbnQKCiAgICAgICAgICAgIGNhc2UgJ1B1c2hUb0FycmF5JzoKICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBBZGRFbGVtZW50VG9BcnJheShtdXRhYmxlX3Rva2VucywgaiwgbWVtb3J5LCBFeGVjdXRpb25TdGFjaywgTGluZWJ5bGluZVNvdXJjZWRhdGEpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgIGNhc2UgJ0FjY2VwdElucHV0JzoKICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBBY2NlcHRJbnB1dGFuZFNldFZhbHVlKG11dGFibGVfdG9rZW5zLCBqLCBtZW1vcnksIEV4ZWN1dGlvblN0YWNrLCBMaW5lYnlsaW5lU291cmNlZGF0YSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAvL1doZW5ldmVyIHdlIGVuY291bnRlciBhIGZ1bmN0aW9uLCB3ZSBjcmVhdGUgYSBzZXBlcmF0ZSBleGVjdXRpb24gY29udGV4dAoKICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOgogICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIC8vV2UgYXJlIHByZXBhcmluZyB0aGUgcmVxdWlyZWQgZGF0YSB0byBleGVjdXRlIGEgZnVuY3Rpb24gY2FsbCBsYXRlciBpbiB0aGUgcHJncm9hbQogICAgICAgICAgICAgICAgLy9mdW5jdGlvbnNvdXJjZWRhdGEgaW5jbHVkZXMgYWxsIHRoZSB0b2tlbnMgZnJvbSB0b2tlbnMgYXJyYXkgd2hpY2ggYmVsb25ncyB0byBhIHBhcnRpY3VsYXIgZnVuY3Rpb24KICAgICAgICAgICAgICAgIHNraXBJbnRlcnByZXRhdGlvbiA9IDA7IC8vV2UgZmluZCBzZWxmIHJhbmdlIG9yIGEgZnVuY3Rpb24gYmxvY2sgdGhyb3VnaCBIYW5kbGVCbG9ja3MgZnVuY3Rpb24KCiAgICAgICAgICAgICAgICB2YXIgX3ByZXBhcmVGdW5jdGlvbiA9IHByZXBhcmVGdW5jdGlvbihtdXRhYmxlX3Rva2VucywgaiksCiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25Tb3VyY2VEYXRhID0gX3ByZXBhcmVGdW5jdGlvbi5mdW5jdGlvblNvdXJjZURhdGE7CgogICAgICAgICAgICAgICAgbXV0YWJsZV90b2tlbnNbal0uU291cmNlRGF0YSA9IGZ1bmN0aW9uU291cmNlRGF0YTsKCiAgICAgICAgICAgICAgICB2YXIgX21lc3NhZ2UgPSAiXHUwOTA3XHUwOTM4ICIuY29uY2F0KEFjdGl2ZUxhbmd1Z2FlS2V5d29yZHMuRnVuY3Rpb24sICIgXHUwOTE1XHUwOTNFIFx1MDkyOFx1MDkzRVx1MDkyRSAiKS5jb25jYXQodG9rZW4sICIgXHUwOTM5XHUwOTQ4IFx1MDkxQ1x1MDkzRlx1MDkzOFx1MDk0NyBcdTA5MzlcdTA5MkUgXHUwOTE1XHUwOTRCXHUwOTIxIFx1MDkyRVx1MDk0N1x1MDkwMiBcdTA5MkNcdTA5M0VcdTA5MjYgXHUwOTJFXHUwOTQ3XHUwOTAyIE5FVyBWQUxVRVMgXHUwOTJBXHUwOTNFXHUwOTM4IFx1MDkxNVx1MDkzMFx1MDkxNVx1MDk0NyBcdTA5MDlcdTA5MkFcdTA5MkZcdTA5NEJcdTA5MTcgXHUwOTE1XHUwOTMwIFx1MDkzOFx1MDkxNVx1MDkyNFx1MDk0NyBcdTA5MzlcdTA5NDh8Iik7CgogICAgICAgICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSAiIi5jb25jYXQoQWN0aXZlTGFuZ3VnYWVLZXl3b3Jkcy5GdW5jdGlvbiwgIiAiKS5jb25jYXQodG9rZW4pOwogICAgICAgICAgICAgICAgdmFyIGRlc2NyaXB0aW9uID0gJyDgpI/gpJUg4KS14KS/4KS24KS/4KS34KWN4KSfIOCksOClguCkqiDgpLjgpYcg4KSy4KS/4KSW4KS+IOCkl+Ckr+CkviDgpJXgpYvgpKEg4KSc4KS/4KS44KSV4KS+IOCkueCkriDgpKzgpL7gpLAg4KSs4KS+4KSwIOCkieCkquCkr+Cli+CklyDgpJXgpLAg4KS44KSV4KSk4KWHIOCkueCliCB8ICc7CiAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBmaW5kdG9rZW5Qb3NpdGlvbmluQ29kZShMaW5lYnlsaW5lU291cmNlZGF0YSwgZXhwcmVzc2lvbiwgdHJ1ZSk7CgogICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uICE9IHVuZGVmaW5lZCkgewogICAgICAgICAgICAgICAgICBBZGR0b0V4ZWN1dGlvblN0YWNrKEV4ZWN1dGlvblN0YWNrLCBBY3RpdmVMYW5ndWdhZUtleXdvcmRzLkZ1bmN0aW9uLCBkZXNjcmlwdGlvbiwgbXV0YWJsZV90b2tlbnNbal0udmFsdWUsIGZ1bmN0aW9uU291cmNlRGF0YSwgX21lc3NhZ2UsIHBvc2l0aW9uKTsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICBza2lwSW50ZXJwcmV0YXRpb24gPSBmdW5jdGlvblNvdXJjZURhdGEubGVuZ3RoOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgLy9XZSBhcmUgb3V0IG9mIHRoZSBmdWNudGlvbiBleGVjdXRpb24gY29udGV4dCBhbmQgYmFjayB0byBnbG9iYWwgZXhlY3V0aW9uIGNvbnRleHQKCiAgICAgICAgICAgIGNhc2UgJ2NvbmRpdGlvbic6CiAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgdmFyIF9lbGVtZW50ID0gdG9rZW47CiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZTsgLy90aGlzIGZ1bmN0aW9uIGlzIHRoZSBmaXJzdCBzdGVwIHRvIGNhbGN1bGF0ZSB2YWx1ZSBvZiBvcGVyYXRpb25zIGxpa2Ug4KSF4KSX4KSwIChhZ2VvbmU9PT0xMCAmJiBBdmVyYWdlQWdlPDEwMDAgJiYgYWdldHdvPjEwMCB8fCBhZ2VvbmU9PT0xMCkgT1IgKGFnZW9uZT09PTEwICkKCiAgICAgICAgICAgICAgICB2YXIgQ29uZGl0aW9uVmFsdWUgPSBHZXRDb25kaXRpb25WYWx1ZShfZWxlbWVudCwgbWVtb3J5LCBqKTsKICAgICAgICAgICAgICAgIGthbGFhbS5MYXN0Q29uZGl0aW9uVmFsdWUucHVzaChDb25kaXRpb25WYWx1ZSk7IC8vaWYgdmFsdWUgaXMgZmFsc2UsIGp1c3Qgc2tpcCB0aGUgaWYgbG9vcCBjb250ZXh0LCBpZiBub3QgaXQgd2lsbCBiZSByYW4gaW4gZmluYWwgcHJpbnQgbW9kdWxlCgogICAgICAgICAgICAgICAgaWYgKCFDb25kaXRpb25WYWx1ZSkgewogICAgICAgICAgICAgICAgICAvLyAgbGV0IEluaXRpYWxpemVMb29wID0gdG9rZW5zLmluZGV4T2YobXV0YWJsZV90b2tlbnNbal0pOwogICAgICAgICAgICAgICAgICAvL0hhbmRsZSBCbG9ja3MgaXMgYSBmdW5jdGlvbiB3aGljaCB0YWtlcyBjYXJlIG9mIG5lc3RlZCBibG9jayBieSB0YWtpbmcgY2FyZSBvZiBuZXN0ZWQgeyBhbmQgfSBicmFja2V0cwogICAgICAgICAgICAgICAgICAvL2l0IHVzZXMgdGhlIHN0YWNrIHRvIHB1c2ggYW5kIHBvcCBicmFja2V0cyB0byBhY2N1cmF0ZWx5IGlkZW50aWZ5IHN0YXJ0IGFuZCB0aGUgZW5kIG9mIHRoZSBibG9jawogICAgICAgICAgICAgICAgICB2YXIgUmV0dXJudmFsdWUgPSBIYW5kbGVCbG9ja3MobXV0YWJsZV90b2tlbnMsIGopOyAvL2Ftb3VudCB0byBza2lwIGlmIGNvbmRpdGlvbiBpcyBmYWxzZQoKICAgICAgICAgICAgICAgICAgc2tpcEludGVycHJldGF0aW9uID0gUmV0dXJudmFsdWUuaiAtIGo7CiAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSAiXHUwOTE1XHUwOTAyXHUwOTIxXHUwOTQwXHUwOTM2XHUwOTI4ICAiLmNvbmNhdChfZWxlbWVudCwgIiAgLCBGQUxTRShcdTA5MTdcdTA5MzJcdTA5MjQpIFx1MDkzOVx1MDk0Qlx1MDkyOFx1MDk0NyBcdTA5MTVcdTA5NDcgXHUwOTE1XHUwOTNFXHUwOTMwXHUwOTI4IENPTVBVVEVSIFx1MDkwNlx1MDkxN1x1MDk0NyBcdTA5MTVcdTA5NDcgXHUwOTE1XHUwOTRCXHUwOTIxIFx1MDkxNVx1MDk0QiBcdTA5MzBcdTA5MjggXHUwOTI4XHUwOTM5XHUwOTQwXHUwOTAyIFx1MDkxNVx1MDkzMFx1MDk0N1x1MDkxN1x1MDkzRSAiKTsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSAiXHUwOTE1XHUwOTAyXHUwOTIxXHUwOTQwXHUwOTM2XHUwOTI4ICIuY29uY2F0KF9lbGVtZW50LCAiICAsIFRSVUUoXHUwOTM4XHUwOTI0XHUwOTREXHUwOTJGKSBcdTA5MzlcdTA5NEJcdTA5MjhcdTA5NDcgXHUwOTE1XHUwOTQ3IFx1MDkxNVx1MDkzRVx1MDkzMFx1MDkyOCBDT01QVVRFUiBcdTA5MDZcdTA5MTdcdTA5NDcgXHUwOTE1XHUwOTQ3IFx1MDkxNVx1MDk0Qlx1MDkyMSBcdTA5MTVcdTA5NEIgXHUwOTMwXHUwOTI4IFx1MDkxNVx1MDkzMFx1MDk0N1x1MDkxN1x1MDkzRSAiKTsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICB2YXIgX2V4cHJlc3Npb24gPSBfZWxlbWVudDsKICAgICAgICAgICAgICAgIHZhciBfZGVzY3JpcHRpb24gPSAn4KSP4KSVIENlcnRhaW4gQ29uZGl0aW9uIOCkleClhyDgpKTgpLngpKQg4KSV4KWL4KShIEV4ZWN1dGlvbiDgpJXgpYsgQWxsb3cg4KSV4KSw4KSk4KS+IOCkueCliOClpCAnOwogICAgICAgICAgICAgICAgX2V4cHJlc3Npb24gPSBHZXRjbGVhbmVkRXhwcmVzc2lvbihfZXhwcmVzc2lvbik7CgogICAgICAgICAgICAgICAgdmFyIF9wb3NpdGlvbiA9IGZpbmR0b2tlblBvc2l0aW9uaW5Db2RlKExpbmVieWxpbmVTb3VyY2VkYXRhLCBfZXhwcmVzc2lvbiwgdHJ1ZSk7CgogICAgICAgICAgICAgICAgaWYgKF9wb3NpdGlvbiAhPSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgICAgICAgQWRkdG9FeGVjdXRpb25TdGFjayhFeGVjdXRpb25TdGFjaywgQWN0aXZlTGFuZ3VnYWVLZXl3b3Jkcy5JZiwgX2Rlc2NyaXB0aW9uLCBfZWxlbWVudCwgQ29uZGl0aW9uVmFsdWUsIG1lc3NhZ2UsIF9wb3NpdGlvbik7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAvL1NvIHRoYXQgd2UgZG9uJ3QgcHJpbnQgYSBzYW1lIHZhbHVlIHR3aWNlLiBGaXJzdCBpbiBnbG9iYWwgZXhlY3V0aW9uIGNvbnRleHQgYW5kIHRoZSBpbiBmdW5jdGlvbiBjb250ZXh0CiAgICAgICAgICAgIC8vVGhpcyBvbmUgcHJpbnRzIHRoZSBnbG9iYWwgY29udGV4dCB2YWx1ZXMKCiAgICAgICAgICAgIGNhc2UgJ3ByaW50JzoKICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBQcmludEVuZ2luZShtdXRhYmxlX3Rva2VucywgbWVtb3J5LCBqKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgLy9UaGlzIHJ1bnMgb3VyIHdoaWxlIGxvb3AgLmkuZSDgpJzgpKzgpKTgpJUKCiAgICAgICAgICAgIGNhc2UgJ1doaWxlTG9vcFN0YXJ0JzoKICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAoZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgICAgICB2YXIgZ2V0V2hpbGVMb29wU291cmNlZGF0YSA9IGZ1bmN0aW9uIGdldFdoaWxlTG9vcFNvdXJjZWRhdGEoc3RhcnRJbmRleCwgbXV0YWJsZV90b2tlbnMsIFN0b3JlUmVzdWx0KSB7CiAgICAgICAgICAgICAgICAgICAgU3RvcmVSZXN1bHQgPSBIYW5kbGVCbG9ja3MobXV0YWJsZV90b2tlbnMsIHN0YXJ0SW5kZXgsIFN0b3JlUmVzdWx0KTsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gU3RvcmVSZXN1bHQ7CiAgICAgICAgICAgICAgICAgIH07CgogICAgICAgICAgICAgICAgICBza2lwSW50ZXJwcmV0YXRpb24gPSAwOwogICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IG11dGFibGVfdG9rZW5zW2ogKyAxXS52YWx1ZTsKICAgICAgICAgICAgICAgICAgdmFyIEV4dHJhdGNlZFZhcmlhYmxlID0gW107CiAgICAgICAgICAgICAgICAgIHZhciB2YXJpYWJsZSA9ICcnOwogICAgICAgICAgICAgICAgICB2YXIgV2hpbGVMb29wU291cmNlZGF0YUluZGV4U3RhcnQgPSAwOwogICAgICAgICAgICAgICAgICB2YXIgV2hpbGVMb29wU291cmNlZGF0YVRva2VucyA9IFtdOwoKICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGVsZW1lbnQubGVuZ3RoOyBfaSsrKSB7CiAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBlbGVtZW50LmNoYXJBdChfaSk7CgogICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhcmlhYmxlKHgpKSB7CiAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZSA9IHZhcmlhYmxlICsgeDsKICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgIGlmICghaXNWYXJpYWJsZShlbGVtZW50LmNoYXJBdChfaSArIDEpKSAmJiBpc1ZhcmlhYmxlKHgpKSB7CiAgICAgICAgICAgICAgICAgICAgICB2YXIgX3Rva2VuMiA9IG1lbW9yeS5maW5kKGZ1bmN0aW9uIChlbCkgewogICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWwubmFtZSA9PT0gdmFyaWFibGU7CiAgICAgICAgICAgICAgICAgICAgICB9KTsKCiAgICAgICAgICAgICAgICAgICAgICBFeHRyYXRjZWRWYXJpYWJsZS5wdXNoKHsKICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGU6IHZhcmlhYmxlLAogICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogX3Rva2VuMi52YWx1ZQogICAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZSA9ICcnOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgV2hpbGVMb29wU291cmNlZGF0YUluZGV4U3RhcnQgPSBnZXRMb29wSW5kZXhTdGFydChtdXRhYmxlX3Rva2VucywgaiwgJ3snLCBXaGlsZUxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydCk7CiAgICAgICAgICAgICAgICAgIFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnMgPSBnZXRXaGlsZUxvb3BTb3VyY2VkYXRhKFdoaWxlTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0LCBtdXRhYmxlX3Rva2VucywgV2hpbGVMb29wU291cmNlZGF0YVRva2VucykuU3RvcmVSZXN1bHQ7CiAgICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gJ+CknOCkrOCkpOCklSAnICsgZWxlbWVudCArICcg4KS44KS54KWAIOCkueCli+Ckl+CkviDgpKTgpKwg4KSk4KSVIOCkhuCkl+ClhyDgpJXgpL4g4KSV4KWL4KShIOCksOCkqCDgpJXgpL/gpK/gpL4g4KSc4KS+4KSv4KWH4KSX4KS+ICc7CiAgICAgICAgICAgICAgICAgIHZhciBkZXNjcmlwdGlvbiA9ICfgpJzgpKzgpKTgpJUg4KSu4KWH4KSCIOCkpuCkv+CkjyDgpLngpYHgpI8g4KS24KSw4KWN4KSkKENvbmRpdGlvbikg4KSV4KWHIOCkquClguCksOCkviDgpLngpYvgpKjgpYcg4KSk4KSVIOCkhuCkl+ClhyDgpJXgpYcg4KSV4KWL4KShIOCkleCliyDgpLDgpKgg4KSV4KSw4KWHIHwnOwogICAgICAgICAgICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IEdldGNsZWFuZWRFeHByZXNzaW9uKGVsZW1lbnQpOwogICAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBmaW5kdG9rZW5Qb3NpdGlvbmluQ29kZShMaW5lYnlsaW5lU291cmNlZGF0YSwgZXhwcmVzc2lvbiwgdHJ1ZSk7CgogICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gIT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgICAgICAgICAgQWRkdG9FeGVjdXRpb25TdGFjayhFeGVjdXRpb25TdGFjaywgQWN0aXZlTGFuZ3VnYWVLZXl3b3Jkcy5XaGlsZSwgZGVzY3JpcHRpb24sIGVsZW1lbnQsIFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnMsIG1lc3NhZ2UsIHBvc2l0aW9uKTsKICAgICAgICAgICAgICAgICAgfSAvL2NvbnN0YW50bHkgYWNjZXNzaW5nIHRoZSBjb25kaXRpb252YWx1ZQoKCiAgICAgICAgICAgICAgICAgIHdoaWxlIChHZXRDb25kaXRpb25WYWx1ZShlbGVtZW50LCBtZW1vcnksIGogKyAxKSkgewogICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnMubGVuZ3RoOyBfaTIrKykgewogICAgICAgICAgICAgICAgICAgICAgLy9TRUNUSU9OIHdoaWxlIGxvb3AgY29udGV4dAogICAgICAgICAgICAgICAgICAgICAgaWYgKFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnNbX2kyXS52YWx1ZSA9PT0gJz0nKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIEFzc2lnbm9yVXBkYXRlVmFsdWVzKFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnMsIF9pMiwgbWVtb3J5LCAnJywgJycsICcnLCBFeGVjdXRpb25TdGFjaywgTGluZWJ5bGluZVNvdXJjZWRhdGEpOwogICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zW19pMl0udHlwZSA9PT0gJ0FjY2VwdElucHV0JykgewogICAgICAgICAgICAgICAgICAgICAgICBBY2NlcHRJbnB1dGFuZFNldFZhbHVlKFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnMsIF9pMiwgbWVtb3J5LCBFeGVjdXRpb25TdGFjayk7CiAgICAgICAgICAgICAgICAgICAgICB9IC8vIEhhbmRsaW5nIENPTkRJVElPTkFMIHN0YXRlbWVudHMgaW4gV2hpbGUgbG9vcAogICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoV2hpbGVMb29wU291cmNlZGF0YVRva2Vuc1tfaTJdLnR5cGUgPT09ICdjb25kaXRpb24nKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiBpbmRleCByZXR1cm5zIGEgdmFsdWUsIGl0IG1lYW5zIGNvbmRpdGlvbiBpcyBmYWxzZSBhbmQgc2tpcCB0aGUgZXhlY3V0aW9uCiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gSGFuZGxlQ29uZGl0aW9ucyhXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zLCBfaTIsIG1lbW9yeSk7CgogICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pMiA9IGluZGV4OwogICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaTIgPSBfaTI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICB9IC8vSGFuZGxpbmcg4KSm4KS/4KSW4KS+4KSPIHN0YXRlbWVudHMgaW4gd2hpbGUgbG9vcAogICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zW19pMl0udmFsdWUgPT09IEFjdGl2ZUxhbmd1Z2FlS2V5d29yZHMuUHJpbnQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIFByaW50RW5naW5lKFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnMsIG1lbW9yeSwgX2kyLCBFeGVjdXRpb25TdGFjayk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUKICAgICAgICAgICAgICAgICAgICAgICAgICB9IC8vb3BlcmF0aW9ucyBsaWtlIE51bWJlcnNbYV09J3h5eicKICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zW19pMl0udHlwZSA9PT0gJ1NldEFycmF5SW5kZXhWYWx1ZScpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2V0QXJyYXlJbmRleFZhbHVlKFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnMsIF9pMiwgaiwgbWVtb3J5LCB0b2tlbnMsIE9yaWdpbmFsSXRlcmF0b3IsIGl0ZXJhdG9yLCBFeGVjdXRpb25TdGFjaywgTGluZWJ5bGluZVNvdXJjZWRhdGEpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgc2tpcEludGVycHJldGF0aW9uID0gV2hpbGVMb29wU291cmNlZGF0YVRva2Vucy5sZW5ndGg7IC8vRW5kIG9mIFdoaWxlIGxvb3AgZXhlY3V0aW9uCiAgICAgICAgICAgICAgICAgIC8vSGFuZGxpbmcgRm9yIGxvb3BzCiAgICAgICAgICAgICAgICB9KSgpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgIGNhc2UgJ0Zvckxvb3BTdGFydCc6CiAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgdmFyIGdldFNvdXJjZWRhdGEgPSBmdW5jdGlvbiBnZXRTb3VyY2VkYXRhKHN0YXJ0SW5kZXgsIG11dGFibGVfdG9rZW5zLCBTdG9yZVJlc3VsdCkgewogICAgICAgICAgICAgICAgICB2YXIgUmV0dXJudmFsdWUgPSBIYW5kbGVCbG9ja3MobXV0YWJsZV90b2tlbnMsIHN0YXJ0SW5kZXgsIFN0b3JlUmVzdWx0KTsKICAgICAgICAgICAgICAgICAgU3RvcmVSZXN1bHQgPSBSZXR1cm52YWx1ZS5TdG9yZVJlc3VsdDsKICAgICAgICAgICAgICAgICAgcmV0dXJuIFN0b3JlUmVzdWx0OwogICAgICAgICAgICAgICAgfTsKCiAgICAgICAgICAgICAgICB2YXIgRmxhZ1ByaW1hbExvb3AgPSAwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lCgogICAgICAgICAgICAgICAgdmFyIFNvdXJjZWRhdGFUb2tlbnMgPSBbXTsKCiAgICAgICAgICAgICAgICB2YXIgX0Zvckxvb3BTZXRNZXRhZGF0YSA9IEZvckxvb3BTZXRNZXRhZGF0YShtdXRhYmxlX3Rva2VucywgaiwgbWVtb3J5KSwKICAgICAgICAgICAgICAgICAgICBPcmlnaW5hbEl0ZXJhdG9yID0gX0Zvckxvb3BTZXRNZXRhZGF0YS5PcmlnaW5hbEl0ZXJhdG9yLAogICAgICAgICAgICAgICAgICAgIEl0ZXJhdGlvblN0YXJ0ID0gX0Zvckxvb3BTZXRNZXRhZGF0YS5JdGVyYXRpb25TdGFydCwKICAgICAgICAgICAgICAgICAgICBJdGVyYXRpb25FbmQgPSBfRm9yTG9vcFNldE1ldGFkYXRhLkl0ZXJhdGlvbkVuZCwKICAgICAgICAgICAgICAgICAgICBpdGVyYXRvciA9IF9Gb3JMb29wU2V0TWV0YWRhdGEuaXRlcmF0b3IsCiAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IF9Gb3JMb29wU2V0TWV0YWRhdGEuZWxlbWVudCwKICAgICAgICAgICAgICAgICAgICBGb3JMb29wU291cmNlZGF0YUluZGV4U3RhcnQgPSBfRm9yTG9vcFNldE1ldGFkYXRhLkZvckxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydCwKICAgICAgICAgICAgICAgICAgICBDeWNsZSA9IF9Gb3JMb29wU2V0TWV0YWRhdGEuQ3ljbGU7CgogICAgICAgICAgICAgICAgRm9yTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0ID0gZ2V0TG9vcEluZGV4U3RhcnQobXV0YWJsZV90b2tlbnMsIGosICd7JywgRm9yTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0KTsKICAgICAgICAgICAgICAgIFNvdXJjZWRhdGFUb2tlbnMgPSBnZXRTb3VyY2VkYXRhKEZvckxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydCwgbXV0YWJsZV90b2tlbnMsIFNvdXJjZWRhdGFUb2tlbnMpOwogICAgICAgICAgICAgICAgU291cmNlZGF0YVRva2Vucy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkgewogICAgICAgICAgICAgICAgICBlbC5pc05lc3RlZExvb3AgPSBmYWxzZTsKICAgICAgICAgICAgICAgIH0pOyAvL0NoZWNraW5nIGlmIHRoZSBmb3IgbG9vcCBoYXMgb25lIG1vcmUgZm9yIGxvb3AgaW5zaWRlIGl0CgogICAgICAgICAgICAgICAgdmFyIEZpbmROZXN0ZWRMb29wID0gU291cmNlZGF0YVRva2Vucy5maW5kKGZ1bmN0aW9uIChlbCkgewogICAgICAgICAgICAgICAgICByZXR1cm4gZWwudHlwZSA9PT0gJ0Zvckxvb3BTdGFydCc7CiAgICAgICAgICAgICAgICB9KTsKCiAgICAgICAgICAgICAgICBpZiAoRmluZE5lc3RlZExvb3AgIT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgICAgICAgIHZhciBOZXN0ZWRMb29waW5kZXggPSBTb3VyY2VkYXRhVG9rZW5zLmluZGV4T2YoRmluZE5lc3RlZExvb3ApICsgMzsKICAgICAgICAgICAgICAgICAgdmFyIE5lc3RlZExvb3BsZW5ndGggPSBTb3VyY2VkYXRhVG9rZW5zW05lc3RlZExvb3BpbmRleF0uRW5kSW5kZXggLSBTb3VyY2VkYXRhVG9rZW5zW05lc3RlZExvb3BpbmRleF0uc3RhcnRJbmRleCArIDI7IC8vaWYgd2UgaGF2ZSBhIG5lc3RlZCBsb29wLCBzZXQgaXNOZXN0ZUxvb3AgdG8gVFJVRQoKICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeCA9IE5lc3RlZExvb3BpbmRleDsgeCA8IE5lc3RlZExvb3BpbmRleCArIE5lc3RlZExvb3BsZW5ndGg7IHgrKykgewogICAgICAgICAgICAgICAgICAgIFNvdXJjZWRhdGFUb2tlbnNbeF0uaXNOZXN0ZWRMb29wID0gdHJ1ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LmluY2x1ZGVzKCcoJykgJiYgZWxlbWVudC5pbmNsdWRlcygnLCcpKSB7CiAgICAgICAgICAgICAgICAgIEZsYWdQcmltYWxMb29wID0gMTsKICAgICAgICAgICAgICAgIH0gLy9JdGVyYXRpbmcgb3ZlciBmb3Jsb29wIHNvdXJjZWRhdGEKICAgICAgICAgICAgICAgIC8vc2VsZiBsaW5lICdpdGVyYXRvciA8PSBDeWNsZScgZGV0ZXJtaW5lcyBzdGFydCBvZiB0aGUgbG9vcCBhbmQgdGhlIGR1cmF0aW9uIG9mIHRoZSBsb29wCgoKICAgICAgICAgICAgICAgIHZhciBfbWVzc2FnZTIgPSAn4KSm4KWB4KS54KSw4KS+4KSTIOCkleClhyDgpIXgpILgpKbgpLAg4KSy4KS/4KSW4KWHIOCkl+CkjyDgpJXgpYvgpKEg4KSV4KWLICcgKyBJdGVyYXRpb25TdGFydCArICcg4KS44KWHICcgKyBJdGVyYXRpb25FbmQgKyAnIOCkpOCklSwg4KSu4KSk4KSy4KSsICcgKyBldmFsKEl0ZXJhdGlvbkVuZCAtIEl0ZXJhdGlvblN0YXJ0ICsgMSkgKyAnIOCkrOCkvuCksCBSVU4o4KSw4KSoKSDgpJXgpL/gpK/gpL4g4KSc4KS+4KSv4KWH4KSX4KS+IHwnICsgJ1xuJyArICcg4KSH4KS44KSu4KWH4KSCIENvbXB1dGVyLCAnICsgJyInICsgaXRlcmF0b3IgKyAnIicgKyAnIOCkleCliyBNZW1vcnkg4KSu4KWH4KSCLCAnICsgSXRlcmF0aW9uU3RhcnQgKyAnIOCkuOClhyAnICsgSXRlcmF0aW9uRW5kICsgJyDgpKTgpJUg4KSV4KS84KWA4KSu4KSkKFZhbHVlcykg4KS44KWH4KSfIOCkleCksOCkpOCkviDgpJzgpL7gpI/gpJfgpL58JzsgLy9UaGlzIGlzIHRoZSBleHBlcmVzc2lvbiB3aGNpaCBpcyBnZXR0aW5nIGV2YWx1YXRlZC4KCgogICAgICAgICAgICAgICAgdmFyIF9leHByZXNzaW9uMiA9ICfgpKbgpYHgpLngpLDgpL7gpJMgJyArIGl0ZXJhdG9yICsgJyDgpJXgpYsgJyArIG11dGFibGVfdG9rZW5zW2ogKyAxXS52YWx1ZSArICcg4KSu4KWHJzsKCiAgICAgICAgICAgICAgICB2YXIgX2Rlc2NyaXB0aW9uMiA9ICfgpI/gpJUg4KS54KWAIOCkleCli+CkoSDgpJXgpYsg4KSs4KS+4KSwLeCkrOCkvuCksCDgpKbgpYvgpLngpLDgpL7gpKjgpL7gpaQgJzsKICAgICAgICAgICAgICAgIHZhciBMaW5lbnVtYmVyID0gTGluZWJ5bGluZVNvdXJjZWRhdGEuaW5kZXhPZihfZXhwcmVzc2lvbjIpOwogICAgICAgICAgICAgICAgTGluZW51bWJlciArPSAxOwogICAgICAgICAgICAgICAgQWRkdG9FeGVjdXRpb25TdGFjayhFeGVjdXRpb25TdGFjaywgQWN0aXZlTGFuZ3VnYWVLZXl3b3Jkcy5Gb3IsIF9kZXNjcmlwdGlvbjIsIFNvdXJjZWRhdGFUb2tlbnMsICcnLCBfbWVzc2FnZTIsIExpbmVudW1iZXIpOwoKICAgICAgICAgICAgICAgIGZvciAoaXRlcmF0b3IgPSBJdGVyYXRpb25TdGFydDsgaXRlcmF0b3IgPD0gQ3ljbGU7IGl0ZXJhdG9yKyspIHsKICAgICAgICAgICAgICAgICAgdmFyIGZvcmxvb3BpbmRleCA9IG1lbW9yeS5maW5kKGZ1bmN0aW9uIChlbCkgewogICAgICAgICAgICAgICAgICAgIHJldHVybiBlbC5uYW1lID09PSBPcmlnaW5hbEl0ZXJhdG9yOwogICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgICAgZm9ybG9vcGluZGV4LnZhbHVlID0gaXRlcmF0b3I7IC8vZmxhZyB0byBhdm9pZCBydW5uaW5nIHRoaXMgY29kZSBpZiBsb29wIGlzIHByaW1hbCBiZWNhdXNlIHRoZSBwYXlsb2FkIG5lZWRzIHRvIGJlIGNvbXBlbHRlbHkgZGlmZmVyZW50CgogICAgICAgICAgICAgICAgICBpZiAoRmxhZ1ByaW1hbExvb3AgPT09IDApIHsvLyBGb3JMb29wQXJyYXlvclN0cmluZ091dHB1dChlbGVtZW50VmFsdWUsIGl0ZXJhdG9yLCBtZW1vcnksIHNlbGYpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lCiAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IFNvdXJjZWRhdGFUb2tlbnMubGVuZ3RoOyBfaTMrKykgewogICAgICAgICAgICAgICAgICAgIC8vIGxldCBpc05lc3RlZCA9IFNvdXJjZWRhdGFUb2tlbnNbaV0uaXNOZXN0ZWRMb29wOwogICAgICAgICAgICAgICAgICAgIC8vVGhpcyBjb2RlIHJ1bnMgb25seSBpZiB3ZSBoYXZlIGEgbmVzdGVkIGxvb3Agc2l0dWF0aW9uCiAgICAgICAgICAgICAgICAgICAgc2tpcEludGVycHJldGF0aW9uID0gMDsKCiAgICAgICAgICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgICAgICAgIGludGVycHJldFRva2VuKFNvdXJjZWRhdGFUb2tlbnMsIF9pMywgbWVtb3J5KTsKICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlLCAiZXJyb3IgaW4gaW50ZXJwcmV0aW5nIGZvciBsb29wICIuY29uY2F0KFNvdXJjZWRhdGFUb2tlbnNbX2kzXSkpOwogICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgaWYgKHNraXBJbnRlcnByZXRhdGlvbiAhPSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICBfaTMgPSBfaTMgKyBza2lwSW50ZXJwcmV0YXRpb247CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgc2tpcEludGVycHJldGF0aW9uID0gc2tpcEludGVycHJldGF0aW9uICsgU291cmNlZGF0YVRva2Vucy5sZW5ndGg7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAvL0VORCBGT1IgTE9PUCBFWEVDVVRJT04KCiAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uRXhlY3V0aW9uJzoKICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAvL2NoZWNraW5nIGlmIGZ1bmN0aW9uIGlzIGludm9rZWQgc29tZXdoZXJlIGxhdGVyIGluIHRoZSBwcm9ncmFtCiAgICAgICAgICAgICAgICAvL0lmIHdlIHNlZSBhIGZ1bmN0aW9uIGV4ZWN1dGlvbiBjYWxsLCBmb3IgZS5nIEFkZCh4LHkpLCB3ZSBwcmVwYXJlIGZvciBleGVjdXRpb24KICAgICAgICAgICAgICAgIHZhciBfZnVuY3Rpb25Tb3VyY2VEYXRhID0gW107CiAgICAgICAgICAgICAgICB2YXIgZnVuY3Rpb25OYW1lID0gdG9rZW47CiAgICAgICAgICAgICAgICB2YXIgcGFzc2VkVmFsdWVzID0gbXV0YWJsZV90b2tlbnNbal0ucGFzc2VkVmFsdWVzOwogICAgICAgICAgICAgICAgdmFyIGZ1bmN0aW9uVG9rZW4gPSBtdXRhYmxlX3Rva2Vucy5maW5kKGZ1bmN0aW9uIChlbCkgewogICAgICAgICAgICAgICAgICByZXR1cm4gZWwudmFsdWUgPT09IGZ1bmN0aW9uTmFtZTsKICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgdmFyIGZ1bmN0aW9uQXJndW1lbnRzID0gZnVuY3Rpb25Ub2tlbi5hcmd1bWVudHM7CiAgICAgICAgICAgICAgICBfZnVuY3Rpb25Tb3VyY2VEYXRhID0gZnVuY3Rpb25Ub2tlbi5Tb3VyY2VEYXRhOyAvL0NyZWF0aW5nIGEgc2VwZXJhdGUgZXhlY3V0aW9uIGNvbnRleHQgYW5kIHNldHRpbmcgZnVjbnRpb24gY29udGV4dCBuYW1lOnZhbHVlIHBhaXIgaW4gZnVuY3Rpb25Db250ZXh0bWVtb3J5CiAgICAgICAgICAgICAgICAvL2ZvciBlLmcgeD0zLCB5PTQgaXMgYWxyZWFkeSBkZWZpbmVkIGFuZCB0aGVuIHdlIGV4ZWN1dGUgYWRkKHgseSkKICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYW4gbWVtb3J5IGZvcm0gbGltaXRlZCB0byBmdW5jdGlvbiBjb250ZXh0CiAgICAgICAgICAgICAgICAvL09wZXJhdGluZyBvbiBmdW5jdGlvbiBhcmd1bWVudHMgYW5kIHNldHRpbmcgdGhlaXIgdmFsdWVzLiBGb3IgZS5nIHRoZSBmdW5jdGlvbiBhZGQoeCx5KSBtaWdodCBiZSBjYWxsZWQgYXMgYWRkKDMsNCkKICAgICAgICAgICAgICAgIC8vc28gd2Ugc2V0IHg9MywgeT00IGFuZCBzZXQgc2VsZiB2YXJpYWJsZS12YWx1ZSBwYWlyIGluIGZ1bmN0aW9uQ29udGV4dG1lbW9yeQoKICAgICAgICAgICAgICAgIGZ1bmN0aW9uQXJndW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsLCBpbmRleCkgewogICAgICAgICAgICAgICAgICB2YXIgdmFsID0gcGFzc2VkVmFsdWVzW2luZGV4XTsKICAgICAgICAgICAgICAgICAgdmFsID0gdmFsLnJlcGxhY2UoLyIvZywgJycpOwogICAgICAgICAgICAgICAgICB2YWwgPSB2YWwucmVwbGFjZSgvJy9nLCAnJyk7CiAgICAgICAgICAgICAgICAgIHBhc3NlZFZhbHVlc1tpbmRleF0gPSB2YWw7IC8vaW4gc2VsZiBjb2RlIHdlIGFyZSBmaWx0ZXJpbmcgb3V0IGFyZ3VtZW50cyBwYXNzZWQgYmFzZWQgb24gd2hldGhlciB0aGV5IGFscmVhZHkgZXhpc3QgaW4gdXBkYXRlZCB0b2tlbnMgb3Igbm90CgogICAgICAgICAgICAgICAgICB2YXIgRmluZEluVXBkYXRlZFRva2VucyA9IG1lbW9yeS5maW5kKGZ1bmN0aW9uIChlbCkgewogICAgICAgICAgICAgICAgICAgIHJldHVybiBlbC5uYW1lID09PSB2YWw7CiAgICAgICAgICAgICAgICAgIH0pOyAvL0ZvciBwYXNzaW5nIHNhbWUgYXJndW1lbnQgYW5kIHNhbWUgdmFsdWUgdG8gZnVuY3Rpb24gIGUuZyBmdW5jdGlvbiBmb28gKGZpYm9uYWNjaSkgYW5kIGZpYm9uYWNjaSBpcyBhbHJlYWR5IGRlY2xhcmVkIHdpdGggc29tZSB2YWx1ZQoKICAgICAgICAgICAgICAgICAgaWYgKEZpbmRJblVwZGF0ZWRUb2tlbnMgPT09IHVuZGVmaW5lZCkgewogICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uQ29udGV4dG1lbW9yeS5wdXNoKHsKICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGVsLAogICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbCwKICAgICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXI6IGogKyBpbmRleCwKICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd2YWx1ZScsCiAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiAnRnVuY3Rpb25FeGVjdXRpb25Db250ZXh0JwogICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgICB9IC8vRm9yIHBhc3NpbmcgZGlmZmVyZW50IGFyZ3VtZW50IGFuZCB2YWx1ZSB0byBmdW5jdGlvbiAgZS5nIGZ1bmN0aW9uIGZvbyAoYXJyKSBhbmQgYXJyIGRvZXNuJ3QgZXhpc3QgYW55d2hlcmUgaW4gdG9rZW5zLgogICAgICAgICAgICAgICAgICBlbHNlIGlmIChlbCAhPSBGaW5kSW5VcGRhdGVkVG9rZW5zLm5hbWUgJiYgRmluZEluVXBkYXRlZFRva2VucyAhPSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uQ29udGV4dG1lbW9yeS5wdXNoKHsKICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZWwsCiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBGaW5kSW5VcGRhdGVkVG9rZW5zLnZhbHVlLAogICAgICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVyOiBqICsgaW5kZXgsCiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEZpbmRJblVwZGF0ZWRUb2tlbnMudHlwZSwKICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogJ0Z1bmN0aW9uRXhlY3V0aW9uQ29udGV4dCcsCiAgICAgICAgICAgICAgICAgICAgICAgIEludGhlRW5kU2V0VmFsdWV0bzogdmFsCiAgICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25Db250ZXh0bWVtb3J5LnB1c2goewogICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBlbCwKICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbCwKICAgICAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllcjogaiArIGluZGV4LAogICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBGaW5kSW5VcGRhdGVkVG9rZW5zLnR5cGUsCiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6ICdGdW5jdGlvbkV4ZWN1dGlvbkNvbnRleHQnLAogICAgICAgICAgICAgICAgICAgICAgICBJbnRoZUVuZFNldFZhbHVldG86IHZhbAogICAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSk7IC8vQnVpbGRpbmcgYSBjb21wbGV0ZSB2YXJpYWJsZS12YWx1ZSBwYWlyIGRhdGFzZXQKCiAgICAgICAgICAgICAgICB2YXIgQ29tcGxldGVUb2tlblZhbHVlTGlzdCA9IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkobWVtb3J5KSwgZnVuY3Rpb25Db250ZXh0bWVtb3J5KTsKCiAgICAgICAgICAgICAgICB2YXIgX21lc3NhZ2UzID0gJ0NvbXB1dGVyICcgKyAnIicgKyBmdW5jdGlvbk5hbWUgKyAnIicgKyAnIOCkqOCkvuCkriDgpJXgpYAg4KSw4KSa4KSo4KS+IOCkleCliyDgpJXgpYngpLIgKENhbGwpIOCkleCksOCkpOCkviDgpLngpYggfCDgpIbgpKrgpKjgpYcgJyArICciKCkiJyArICcg4KSV4KWHIOCkheCkguCkpuCksCDgpKbgpL/gpI8g4KSX4KSPIE5ldyBWYWx1ZXMg4KSV4KS+IOCksOCkmuCkqOCkviAnICsgZnVuY3Rpb25OYW1lICsgJyDgpK7gpYfgpIIg4KSJ4KSq4KSv4KWL4KSXIOCkleCksOCkleClhywg4KSw4KSa4KSo4KS+ICcgKyBmdW5jdGlvbk5hbWUgKyAnIOCkruClh+CkgiDgpLLgpL/gpJbgpYcg4KSX4KSPIOCkleCli+CkoSDgpJXgpYsg4KSw4KSoIOCkleCksOCkpOCkviDgpLngpYggfCc7CgogICAgICAgICAgICAgICAgdmFyIF9leHByZXNzaW9uMyA9IGZ1bmN0aW9uTmFtZSArICcoJzsKCiAgICAgICAgICAgICAgICB2YXIgX2Rlc2NyaXB0aW9uMyA9ICcg4KSP4KSVIOCkteCkv+CktuCkv+Ckt+CljeCknyDgpLDgpYLgpKog4KS44KWHIOCksuCkv+CkluCkviDgpJfgpK/gpL4g4KSV4KWL4KShIOCknOCkv+CkuOCkleCkviDgpLngpK4g4KSs4KS+4KSwIOCkrOCkvuCksCDgpIngpKrgpK/gpYvgpJcg4KSV4KSwIOCkuOCkleCkpOClhyDgpLngpYggfCAnOwoKICAgICAgICAgICAgICAgIHZhciBfcG9zaXRpb24yID0gZmluZHRva2VuUG9zaXRpb25pbkNvZGUoTGluZWJ5bGluZVNvdXJjZWRhdGEsIF9leHByZXNzaW9uMywgZmFsc2UpOwoKICAgICAgICAgICAgICAgIGlmIChfcG9zaXRpb24yICE9IHVuZGVmaW5lZCkgewogICAgICAgICAgICAgICAgICBBZGR0b0V4ZWN1dGlvblN0YWNrKEV4ZWN1dGlvblN0YWNrLCBBY3RpdmVMYW5ndWdhZUtleXdvcmRzLkZ1bmN0aW9uLCBfZGVzY3JpcHRpb24zLCBmdW5jdGlvbk5hbWUsIF9mdW5jdGlvblNvdXJjZURhdGEsIF9tZXNzYWdlMywgX3Bvc2l0aW9uMik7CiAgICAgICAgICAgICAgICB9IC8vTm93IHdlIHN0YXJ0IGRpZ2dpbmcgaW50byB0aGUgZnVuY3Rpb24gZXhlY3V0aW9uCiAgICAgICAgICAgICAgICAvL21pZ2h0IGhhdmUgdG8gY2hhbmdlIGkgdG8gMQogICAgICAgICAgICAgICAgLy9za2lwIGluIGZ1bmN0aW9uc291cmNlZGF0YQoKCiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBfZnVuY3Rpb25Tb3VyY2VEYXRhLmxlbmd0aDsgX2k0KyspIHsKICAgICAgICAgICAgICAgICAgc2tpcEludGVycHJldGF0aW9uID0gMDsKCiAgICAgICAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgICAgICAgaW50ZXJwcmV0VG9rZW4oX2Z1bmN0aW9uU291cmNlRGF0YSwgX2k0LCBDb21wbGV0ZVRva2VuVmFsdWVMaXN0KTsKICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUsICJlcnJvciBpbiBpbnRlcnByZXRpbmcgZnVuY3Rpb24gZXhlY3V0aW9uICIuY29uY2F0KGZ1bmN0aW9uTmFtZSkpOwogICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICBpZiAoc2tpcEludGVycHJldGF0aW9uICE9IDApIHsKICAgICAgICAgICAgICAgICAgICBfaTQgPSBfaTQgKyBza2lwSW50ZXJwcmV0YXRpb247CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgY29uc29sZS5sb2coZSwgIkVycm9yIGluIEludGVycHJldGluZyB0b2tlbiAiLmNvbmNhdChtdXRhYmxlX3Rva2Vuc1tqXSkpOwogICAgICB9CiAgICAgIC8qIGVsc2UgaWYgKHRva2VuID09PSAi4KSF4KSo4KWN4KSv4KSl4KS+IikgewogICAgICBsZXQgcmVzdWx0ID0gSGFuZGxlQmxvY2tzKG11dGFibGVfdG9rZW5zLCBqLCByZXN1bHQpOwogICAgICAvLyBsZXQgU3RhcnRvZkJsb2NrID0gbXV0YWJsZV90b2tlbnNbaiArIDFdLnN0YXJ0SW5kZXg7CiAgICAgIGxldCBFbmRvZkJsb2NrID0gbXV0YWJsZV90b2tlbnNbaiArIDFdLkVuZEluZGV4OwogICAgICBsZXQgbGFzdFZhbHVlID0ga2FsYWFtLkxhc3RDb25kaXRpb25WYWx1ZS5wb3AoKTsKICAgICAgaWYgKGxhc3RWYWx1ZSkgewogICAgICBqID0gRW5kb2ZCbG9jazsKICAgICAgfSovCgogICAgfTsgLy8jU1RFUCAxLSBDbGVhbmluZyB0aGUgc291cmNlZGF0YSBhbmQgc2V0dGluZyB0aGUgJ3Jlc3VsdCcgdG8gJ2NsZWFuZWRfc291cmNlZGF0YScKICAgIC8vSWYgYSBjb2RlIGlzIG5vdCB3b3JraW5nLCBpdCBpcyBwcm9iYWJseSBiZWNhdXNlIGl0J3Mgbm90IGNsZWFuZWQgcHJvcGVybHkuCgoKICAgIC8vVGhpcyBpcyB3aGVyZSBlcnJvciBoYW5kbGluZyBraWNrcyBpbgogICAgLy9UbyBmaW5kIHVuZGVmaW5lZCB2YXJpYWJsZXMKICAgIHZhciBvbmx5VW5pcXVlID0gZnVuY3Rpb24gb25seVVuaXF1ZSh2YWx1ZSwgaW5kZXgsIGFycikgewogICAgICByZXR1cm4gYXJyLmluZGV4T2YodmFsdWUpID09PSBpbmRleDsKICAgIH07CgogICAgLy90MCBhbG9uZyB3aXRoIHQxIHRha2VzIHJlY29yZCBvZiBUaW1lIHRha2VuIHRvIHJ1biB0aGUgY29kZS4gdDEtdDAgZ2l2ZXMgdXMgdGhlIGV4YWN0IHRpbWUgdGFrZW4uCiAgICB2YXIgdDAgPSBwZXJmb3JtYW5jZS5ub3coKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZQogICAgLy9Tb3VyY2VkYXRhIGlzIHRoZSByYXcgY29kZSBwcm92aWRlZCBieSB1c2VyCgogICAgdmFyIHNvdXJjZWRhdGEgPSBzb3VyY2Vjb2RlOwogICAgdmFyIExpbmVieWxpbmVTb3VyY2VkYXRhID0gc291cmNlZGF0YS5yZXBsYWNlKC8oPzpcclxufFxyfFxuKS9nLCAnYnJlYWtwb2ludCcpLnNwbGl0KCdicmVha3BvaW50Jyk7IC8vVGhpcyBpcyB3aGVyZSBmb3JtYXR0ZWQgYW5kIGNsZWFuZWQgc291cmNlZGF0YSB3aWxsIGdvLgoKICAgIHZhciBjbGVhbmVkX3NvdXJjZWRhdGEgPSBbXTsKICAgIHZhciBFeGVjdXRpb25TdGFjayA9IFtdOwogICAgdmFyIGkgPSAwOyAvL1RoaXMgaXMgd2hlcmUgdG9rZW5zIHdpbGwgYmUgcHVzaGVkIGRlcGVuZGluZyB1cG9uIHRoZWlyIHR5cGVzIGxpa2UgVmFyaWFibGUsIGZ1bmN0aW9uLCBsb29wcyBldGMuCgogICAgdmFyIHRva2VucyA9IFtdOyAvL0V4cGVyaW1lbnRhbAoKICAgIHZhciBtaXhlZGltcHVyaXR5ID0gW107IC8vVGhlIHZhcmlhYmxlcyB3aXRoIHRoZWlyIGNhbGN1bGF0ZWQgdmFsdWVzIGFyZSBwdXNoZWQgaGVyZS4gSWYgYz1hK2IsIG1lbW9yeSBpcyB3aGVyZSB5b3Ugd2lsbCBmaW5kIHRoZSBjYWxjdWxhdGVkIHZhbHVlCgogICAgdmFyIG1lbW9yeSA9IFtdOyAvL1ZhcmlhYmxlLXZhbHVlIHBhaXJzIHNpbWlsYXIgdG8gbWVtb3J5IGJ1dCBsaW1pdHMgaXRzZWxmIHRvIGEgdXNlciBjcmVhdGVkIGZ1bmN0aW9uLgoKICAgIHZhciBmdW5jdGlvbkNvbnRleHRtZW1vcnkgPSBbXTsKICAgIHZhciB2YXJpYWJsZXNfYXJyYXkgPSBbXTsgLy9QdXNoaW5nIHRoZSB2YXJpYWJsZXMgdGhhdCBhcmUgYXNzaWduZWQgdG8gZmlsdGVyIG91dCBkZWZpbmVkIGFuZCB1bmRlZmluZWQgdmFyaWFibGVzLiBVc2VmdWwgaW4gZXJyb3IgaGFuZGxpbmcKCiAgICB2YXIgYXNzaWduZWRfdmFyaWFibGVzID0gW107IC8vVE8gUkVNT1ZFIERVUExJQ0FURSBWQVJJQUJMRVMsCiAgICAvLyB2YXIgdmFyaWFibGVBcnJheSA9IFtdOwogICAgLy9BIHRlbXBvcmFyeSBpbnN0YW5jZSBvZiBhIGdsb2JhbCB2YXJpYWJsZS4gVXNlZCBiZWNhdXNlIG9mIHNjb3BpbmcgaXNzdWUsIHRoZXJlIGFyZSBiZXR0ZXIgc291bHRpb25zIGFuZCB3ZSB3aWxsIGRvIHRoYXQuCiAgICAvL2VtcHR5aW5nIGFjY3VtdWxhdGVkIHZhbHVlCiAgICAvL1NlZSBBc3NpZ25vclVwZGF0ZVZhbHVlcyBmdW5jdGlvbiBmb3IgbW9yZQoKICAgIHZhciBza2lwUGFyc2luZyA9IDA7CiAgICB2YXIgc2tpcEludGVycHJldGF0aW9uID0gMDsKICAgIFJlc2V0VmFsdWUoKTsKICAgIHZhciBrYWxhYW0gPSB7fTsgLy9JZiBhbiBlcnJvciBpcyBlbmNvdW50ZXJlZCB3ZSBzZXQgdGhlIHZhbHVlIHRvIHRydWUgYW5kIHB1c2ggdGhlIGVycm9yIHRvIGVycm9ycyBhcnJheS4KCiAgICBrYWxhYW0uaXNFcnJvciA9IGZhbHNlOwogICAgc291cmNlY29kZSA9IGVhcmx5Q2xlYW5pbmcoc291cmNlY29kZSk7CiAgICBrYWxhYW0ub3V0cHV0ID0gJyc7CiAgICBrYWxhYW0uTGFzdENvbmRpdGlvblZhbHVlID0gW107CiAgICBrYWxhYW0uRXhlY3V0aW9uU3RhY2sgPSBbXTsKICAgIGthbGFhbS5saW5lYnlsaW5lT3V0cHV0ID0ga2FsYWFtLm91dHB1dC5zcGxpdCgnXG4nKTsKICAgIGthbGFhbS5lcnJvciA9IFtdOwogICAga2FsYWFtLk9wZXJhdGlvbk9iamVjdHMgPSBbXTsgLy9TRUNUSU9OIC0gQ2hlY2tpbmcgZm9yIHR5cGUgb2YgY2hhcmFjdGVycy4gVHlwZUNoZWNrIGlzIGFuIG9iamVjdCB3aGljaCBjb25zaXN0cyBhbGwgc2VsZiBmdW5jdGlvbnMuIENoZWNrIExpbmUgMTAyCgogICAgdmFyIGlzVmFyaWFibGUgPSBUeXBlQ2hlY2suaXNWYXJpYWJsZSgpOwogICAgdmFyIGlzTnVtYmVyID0gVHlwZUNoZWNrLmlzTnVtYmVyKCk7CiAgICB2YXIgaXNXaGlsZUxvb3AgPSBUeXBlQ2hlY2suaXNXaGlsZUxvb3AoKTsKICAgIHZhciBpc1B1cmVFdmFsID0gQWR2YW5jZWRUeXBlQ2hlY2suaXNQdXJlRXZhbCgpOyAvL2lmIF90b2tlbnNyIGVuY291bnRlcnMgYW55dGhpbmcgbGlrZSAoIiBvciAoLCB0aGVuIHRoYXQncyBhIHJlYWx0aW1lIHByaW50LgogICAgLy9idWlsZHN0cmluZyB3aWxsIGJlIGFwcGxpZWQgbm93IHRvIGNyZWF0ZSBhIHN0cmluZyBhbmQgcHVzaCBpdCBpbnRvIHRva2Vucy4gQnVpbGRzdHJpbmcgaXMgdXNlZCB0byBjb21iaW5lIHN0cmluZyB0b2tlbnMgbGlrZQogICAgLy9bJ2hlbGxvJywgJ0thbGFhbScsICdkZXZlbG9wZXJzJywgIiEiXSBpbnRvICdoZWxsbyBrYWxhYW0gZGV2ZWxvcGVycyEnLgogICAgLy9JdCdzIGJlY2F1c2UgY2xlYW5lZF9zb3VyY2VkYXRhIGlzIGFuIGFycmF5IG9mIHRva2VucyBhbmQgZWFjaCB0b2tlbiBpcyBhbiBpbmRpdmlkdWFsIHdvcmQgaW4gYSBwcm9ncmFtLgogICAgLy9JdCdzIHJlY29tbWVuZGVkIHRvIGxvb2sgYXQgY2xlYW5lZF9zb3VyY2VkYXRhIG9mIGV2ZXJ5IHByb2dyYW0gdG8gdW5kZXJzdGFuZCBob3cgaXQgY29udmVydHMgcGxhaW4gdGV4dCBpbnRvIGFycmF5IG9mIGluZGl2aWR1YWwgd29yZHMuCgogICAgdmFyIGlzUmVhbFRpbWVQcmludE11bHRpcGxlU3RyaW5nID0gQWR2YW5jZWRUeXBlQ2hlY2suaXNSZWFsVGltZVByaW50TXVsdGlwbGVTdHJpbmcoKTsgLy9jb25zdCBpc1N0cmluZ2FuZFZhbHVlID0gQWR2YW5jZWRUeXBlQ2hlY2suaXNTdHJpbmdhbmRWYWx1ZSgpCgogICAgdmFyIGlzQ2FsY3VsYXRpb24gPSBBZHZhbmNlZFR5cGVDaGVjay5pc0NhbGN1bGF0aW9uKCk7IC8vIGNvbnN0IGlzRGlyZWN0UHJpbnRBcml0aG1ldGljID0gQWR2YW5jZWRUeXBlQ2hlY2suaXNEaXJlY3RQcmludEFyaXRobWV0aWMoKQogICAgLy9TRUNUSU9OIC0gQnVpbGQgT3BlcmF0aW9ucwogICAgLy9UbyBjb252ZXJ0IFsnaGVsbG8nLCAnS2FsYWFtJywgJ2RldmVsb3BlcnMnLCAiISJdIGludG8gJ2hlbGxvIGthbGFhbSBkZXZlbG9wZXJzIScuCgogICAgdmFyIEJ1aWxkU3RyaW5nID0gQnVpbGRPcGVyYXRpb24uQnVpbGRTdHJpbmcoKTsgLy9UbyBjb252ZXJ0IFsnWycsICd4JywneScsJ3onLCddJ10gaW50byBbJ3gnLCd5JywneiddCgogICAgdmFyIEJ1aWxkQXJyYXkgPSBCdWlsZE9wZXJhdGlvbi5CdWlsZEFycmF5KCk7IC8vc2VsZiBmdW5jdGlvbiBpcyB0aGUgZmlyc3Qgc3RlcCB0byBoYW5kbGxlIG9wZXJhdGlvbnMgbGlrZSDgpIXgpJfgpLAgKGFnZW9uZT09PTEwICYmIEF2ZXJhZ2VBZ2U8MTAwMCAmJiBhZ2V0d28+MTAwIHx8IGFnZW9uZT09PTEwKSBPUiAoYWdlb25lPT09MTAgKQoKICAgIHZhciBCdWlsZENvbmRpdGlvbiA9IEJ1aWxkT3BlcmF0aW9uLkJ1aWxkQ29uZGl0aW9uKCk7CiAgICBjbGVhbmVkX3NvdXJjZWRhdGEgPSBHZXRDbGVhblNvdXJjZWRhdGEoc291cmNlZGF0YSwgY2xlYW5lZF9zb3VyY2VkYXRhLCBtaXhlZGltcHVyaXR5KTsKICAgIGNvbnNvbGUubG9nKCdjbGVhbmVkX3NvdXJjZWRhdGE6JywgY2xlYW5lZF9zb3VyY2VkYXRhKSAvLyNTVEVQIDItIC0gUGFyc2luZyBjbGVhbmVkX3NvdXJjZWRhdGEsIGFkZGluZyBlYWNoIGl0ZW0gZGVwZW5kaW5nIG9uIGl0J3MgdHlwZSB0byB0b2tlbnMgYXJyYXkKICAgIC8vIFBBUlNJTkcgSU5JVElBVElPTgogICAgKGZ1bmN0aW9uIF9wYXJzZXIoKSB7CiAgICAgIGZvciAoaTsgaSA8IGNsZWFuZWRfc291cmNlZGF0YS5sZW5ndGg7IGkrKykgewogICAgICAgIF9hbmFseXplVG9rZW4oY2xlYW5lZF9zb3VyY2VkYXRhLCBpLCB0b2tlbnMpOyAvL0NvZGUgdG8gc2tpcCBpbXByb3ZlIGEgcGFydGljdWxhciBwYXJ0IG9mIGNsZWFuZWRfc291cmNlZGF0YSBpZiBpdCdzIGJlaW5nIG9wZXJhdGVkIGJ5IHR3byBkaWZmZXJlbnQgZnVuY3Rpb25zLgoKCiAgICAgICAgaWYgKHNraXBQYXJzaW5nICE9IDApIHsKICAgICAgICAgIGkgPSBpICsgc2tpcFBhcnNpbmc7CiAgICAgICAgfQogICAgICB9CiAgICB9KSgpOyAvL0NMRUFOSU5HIFVQIFRIRSBUT0tFTlMgQVJSQVkKICAgIC8vUmVtb3ZpbmcgdG9rZW5zIHdpdGggdmFsdWUgPSAnJywgSXQgd2FzIGdlbmVyYXRlZCBkdWUgdG8gIiBjbGVhbmVkX3NvdXJjZWRhdGEgPSBjbGVhbmVkX3NvdXJjZWRhdGEucmVwbGFjZSgvKDt8XG58XHIpL2dtLCAiICIpLnNwbGl0KCcgJykiCiAgICAvL0ZpbHRlcmluZyBzZWVtZWQgdW5uZWNlc3NhcnksIHJlbW92ZWQgZm9yIG5vdy4KICAgIC8vdG9rZW5zID0gdG9rZW5zLmZpbHRlcihlbCA9PiBlbC52YWx1ZSAhPSAnJykKICAgIC8vdmFyaWFibGVBcnJheSA9IHRva2Vucy5maWx0ZXIoKGVsKSA9PiBlbC50eXBlID09PSAndmFyaWFibGUnKTsKICAgIC8vQXMgb2Ygbm93LCB0aGlzIGlzIGhvdyB0aGUgdGltZWxpbmUgbG9va3MKICAgIC8vcmF3IHNvdXJjZWNvZGUgLT4gY2xlYW5lZF9zb3VyY2VkYXRhIC0+IHRva2VucwogICAgLy8jU1RFUCAzIC0gZXZhbHVhdGluZyBjb25kaXRpb25zLCBydW5uaW5nIGxvb3BzLCBleGVjdXRpbmcgZnVuY3Rpb25zIGZpbmRpbmcgdmFsdWVzIGluIG1lbW9yeSBhbmQgcHJpbnRpbmcgb3V0cHV0cwogICAgLy9UaGlzIGlzIHRoZSBmaW5hbCBzZWN0aW9uCiAgICAvL2ludGVycHJldGluZyB0aGUgY29kZSBmcm9tIHN5bnRheCB0cmVlCgogICAgKGZ1bmN0aW9uIF9pbnRlcnByZXRvcigpIHsKICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB0b2tlbnMubGVuZ3RoOyB4KyspIHsKICAgICAgICAvL1dlIHdpbGwgYmUgaGF2aW5nIGEgY29weSBvZiB0b2tlbnMgYXMgbXV0YWJsZV90b2tlbnMKICAgICAgICBpbnRlcnByZXRUb2tlbih0b2tlbnMsIHgsIG1lbW9yeSk7CgogICAgICAgIGlmIChza2lwSW50ZXJwcmV0YXRpb24gIT0gMCkgewogICAgICAgICAgeCA9IHggKyBza2lwSW50ZXJwcmV0YXRpb247CiAgICAgICAgfQogICAgICB9CiAgICB9KSgpOwoKICAgIHZhciBhc3NpZ25lZF92YXJpYWJsZXMgPSBhc3NpZ25lZF92YXJpYWJsZXMuZmlsdGVyKG9ubHlVbmlxdWUpOwogICAgdmFyIGRpZmZlcmVuY2UgPSB2YXJpYWJsZXNfYXJyYXkuZmlsdGVyKGZ1bmN0aW9uICh4KSB7CiAgICAgIHJldHVybiAhYXNzaWduZWRfdmFyaWFibGVzLmluY2x1ZGVzKHgpOwogICAgfSk7CgogICAgaWYgKGRpZmZlcmVuY2UubGVuZ3RoID4gMCkgewogICAgICBkaWZmZXJlbmNlLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7CiAgICAgICAga2FsYWFtLmVycm9yLnB1c2goIlZhcmlhYmxlICIuY29uY2F0KGVsLCAiIGlzIHVuZGVmaW5lZCIpKTsKICAgICAgfSk7CiAgICB9CgogICAga2FsYWFtLmxpbmVieWxpbmVPdXRwdXQgPSBrYWxhYW0uZXJyb3IubGVuZ3RoID4gMCA/IGthbGFhbS5lcnJvciA6IGthbGFhbS5vdXRwdXQuc3BsaXQoJ1xuJyk7IC8vdGltZSB0YWtlbiB0byB0cmFuc3BpbGUgdGhlIGNvZGUgaXMgdDEtdDAKCiAgICB2YXIgdDEgPSBwZXJmb3JtYW5jZS5ub3coKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZQoKICAgIGlmIChrYWxhYW0uZXJyb3IubGVuZ3RoID09PSAwKSB7CiAgICAgIHZhciBzID0gKHQxIC0gdDApLnRvUHJlY2lzaW9uKDQpOwogICAgICBrYWxhYW0uVGltZVRha2VuID0gIlx1MDkzOFx1MDkyQlx1MDkzMiB8IHNwZWVkIC0gIi5jb25jYXQocywgIiBtcyIpOwogICAgfSBlbHNlIHsKICAgICAga2FsYWFtLmlzRXJyb3IgPSB0cnVlOwogICAgICBrYWxhYW0uVGltZVRha2VuID0gJ0NvbXBpbGF0aW9uIEVycm9yOiBDaGVjayBmb3IgYXNzaWduZW1lbnQgYW5kIGRlY2xhcmF0aW9uIG1pc3R5cGluZyc7CiAgICB9IC8va2FsYWFtLmxpbmVieWxpbmVvdXRwdXQgaXMgd2hhdCB5b3Ugd2lsbCBmaW5hbGx5IHNlZSBvbiBvdXRwdXQgc2NyZWVuCgoKICAgIGthbGFhbS5saW5lYnlsaW5lT3V0cHV0ID0ga2FsYWFtLmxpbmVieWxpbmVPdXRwdXQuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7CiAgICAgIHJldHVybiBpdGVtICE9PSAnJzsKICAgIH0pOwogICAga2FsYWFtLkV4ZWN1dGlvblN0YWNrID0gRXhlY3V0aW9uU3RhY2s7CiAgICByZXR1cm4ga2FsYWFtOwogIH0gY2F0Y2ggKGUpIHsKICAgIGNvbnNvbGUubG9nKGUpOwogIH0KfQ=="},{"version":3,"sources":["/Users/jonny/Desktop/myProjects/Kalaam-core/Compiler/main.js"],"names":["TypeCheck","ActiveLangugaeKeywords","AdvancedTypeCheck","BuildOperation","RemoveQuotes","RemoveBrackets","earlyCleaning","PushArray","PushCalculation","PushConditionalKeyword","PushCondition","PushForLoop","PushWhileLoop","PushForLoopAruguments","PushExpression","PushNativeOperation","PushKeyword","PushNumber","PushOperator","PushRealTimePrintOperation","PushString","PushVariable","PushVariableValue","PushFunctionData","PushFunctionExecution","PushToArray","PushInput","GetCleanSourcedata","GetcleanedExpression","AddElementToArray","ResetValue","CreateArrayElement","CalculateValues","GetArrayorStringElement","HandleBlocks","SplitElementsArray","SetValues","PushSetArrayIndexValue","PushGetArrayIndexValue","GetConditionValue","AcceptInputandSetValue","AssignorUpdateValues","HandleConditions","getLoopIndexStart","ForLoopSetMetadata","SetArrayIndexValue","AddtoExecutionStack","scanner","handleRealtimePrint","handleVariable","handleOutput","prepareFunction","findtokenPositioninCode","isInterpretableType","Compile","sourcecode","PrintEngine","Tokens","memory","j","iterator","OriginalIterator","StringVar","token","value","NextTokenValue","nextElement","VariableToPrint","forEach","el","name","assigned_variables","includes","kalaam","isNumber","push","isPureEval","outputpure","eval","type","toString","undefined","IndexInput","Value","ArrayElement","output","IndexToChange","element","replace","Split","split","join","find","Print","a","mode","x","isCalculation","message","expression","description","position","LinebylineSourcedata","ExecutionStack","_analyzeToken","cleaned_sourcedata","i","tokens","skipParsing","nextEl","prevEl","prevElement","token_type","console","log","handled_variable","h","e","length","charAt","ExpressiontoPrint","isRealTimePrintMultipleString","BuiltArray","BuildArray","splice","isWhileLoop","foundcondition","BuildCondition","isMultiCalculation","c","op","s","d","cal","count","multiCal","foundString","skip","BuildString","CheckFunctionExpression","passedValues","interpretToken","t","skipInterpretation","mutable_tokens","token_subtype","subtype","functionSourceData","SourceData","Function","ConditionValue","LastConditionValue","Returnvalue","If","getWhileLoopSourcedata","startIndex","StoreResult","ExtratcedVariable","variable","WhileLoopSourcedataIndexStart","WhileLoopSourcedataTokens","isVariable","While","index","getSourcedata","FlagPrimalLoop","SourcedataTokens","IterationStart","IterationEnd","ForLoopSourcedataIndexStart","Cycle","isNestedLoop","FindNestedLoop","NestedLoopindex","indexOf","NestedLooplength","EndIndex","Linenumber","For","forloopindex","functionName","functionToken","functionArguments","arguments","val","FindInUpdatedTokens","functionContextmemory","identifier","context","IntheEndSetValueto","CompleteTokenValueList","onlyUnique","arr","t0","performance","now","sourcedata","mixedimpurity","variables_array","isError","linebylineOutput","error","OperationObjects","_parser","_interpretor","filter","difference","t1","toPrecision","TimeTaken","item"],"mappings":"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","sourcesContent":["/*!\n * Kalaam v1.0.0\n * (C) 2020-21 Swanand Kadam\n * Released under the MIT License.\n */\n\n//SECTION - Importing function modules\n\n//To check variable types: Number, String, Array etc.\nimport * as TypeCheck from '../TypeCheck/TypeChecking';\n\nimport { ActiveLangugaeKeywords, } from '../Compiler/constants';\n\n//To check other operations like MultiString, Arithmetic Operation etc.\nimport * as AdvancedTypeCheck from '../TypeCheck/AdvancedTypeChecking';\n\n//To format user input into a proper String, Array or Condition.\nimport * as BuildOperation from '../Scripts/BuildOperations';\n\nimport { RemoveQuotes, RemoveBrackets, earlyCleaning, } from '../Scripts/Helpers';\n\n//Functions imported to push a particular data to our Tokens array.\n//Tokens array is basically a clean, formatted and a word by word version of raw code provided by user\nimport {\n    PushArray,\n    PushCalculation,\n    PushConditionalKeyword,\n    PushCondition,\n    PushForLoop,\n    PushWhileLoop,\n    PushForLoopAruguments,\n    PushExpression,\n    PushNativeOperation,\n    PushKeyword,\n    PushNumber,\n    PushOperator,\n    PushRealTimePrintOperation,\n    PushString,\n    PushVariable,\n    PushVariableValue,\n    PushFunctionData,\n    PushFunctionExecution,\n    PushToArray,\n    PushInput,\n} from '../PushTokens/main';\n\n//This are other helper functions that we need for a particular task. All of this functions will be explained indepth as we see them in codebase.\nimport {\n    GetCleanSourcedata,\n    GetcleanedExpression,\n    AddElementToArray,\n    ResetValue,\n    CreateArrayElement,\n    CalculateValues,\n    GetArrayorStringElement,\n    HandleBlocks,\n    SplitElementsArray,\n    SetValues,\n    PushSetArrayIndexValue,\n    PushGetArrayIndexValue,\n    GetConditionValue,\n    AcceptInputandSetValue,\n    AssignorUpdateValues,\n    HandleConditions,\n    getLoopIndexStart,\n    ForLoopSetMetadata,\n    SetArrayIndexValue,\n    AddtoExecutionStack,\n} from '../Scripts/main.js';\n\nimport scanner from '../scanner/main';\n\nimport '../HelperLibrary/main';\nimport { handleRealtimePrint, handleVariable, handleOutput, prepareFunction, } from '../Scripts/Handlers';\nimport { findtokenPositioninCode, } from '../Scripts/finders';\nimport { isInterpretableType, } from '../Scripts/testers';\n//We will be importing this whole function to practise.vue and it will be executed when user clicks on 'RUN'\n\nexport default function Compile(sourcecode) {\n    try {\n    //t0 along with t1 takes record of Time taken to run the code. t1-t0 gives us the exact time taken.\n    var t0 = performance.now(); // eslint-disable-line\n\n        //Sourcedata is the raw code provided by user\n        const sourcedata = sourcecode;\n\n        var LinebylineSourcedata = sourcedata.replace(/(?:\\r\\n|\\r|\\n)/g, 'breakpoint').split('breakpoint');\n\n        //This is where formatted and cleaned sourcedata will go.\n        var cleaned_sourcedata = [];\n        var ExecutionStack = [];\n        var i = 0;\n        //This is where tokens will be pushed depending upon their types like Variable, function, loops etc.\n        var tokens = [];\n\n        //Experimental\n        var mixedimpurity = [];\n\n        //The variables with their calculated values are pushed here. If c=a+b, memory is where you will find the calculated value\n        var memory = [];\n\n        //Variable-value pairs similar to memory but limits itself to a user created function.\n        var functionContextmemory = [];\n\n        var variables_array = [];\n\n        //Pushing the variables that are assigned to filter out defined and undefined variables. Useful in error handling\n        var assigned_variables = [];\n\n        //TO REMOVE DUPLICATE VARIABLES,\n\n        // var variableArray = [];\n        //A temporary instance of a global variable. Used because of scoping issue, there are better soultions and we will do that.\n\n        //emptying accumulated value\n        //See AssignorUpdateValues function for more\n\n        var skipParsing = 0;\n        var skipInterpretation = 0;\n\n        ResetValue();\n        var kalaam = {};\n        //If an error is encountered we set the value to true and push the error to errors array.\n        kalaam.isError = false;\n\n        sourcecode = earlyCleaning(sourcecode);\n\n        kalaam.output = '';\n        kalaam.LastConditionValue = [];\n        kalaam.ExecutionStack = [];\n\n        kalaam.linebylineOutput = kalaam.output.split('\\n');\n        kalaam.error = [];\n        kalaam.OperationObjects = [];\n\n        //SECTION - Checking for type of characters. TypeCheck is an object which consists all self functions. Check Line 102\n\n        const isVariable = TypeCheck.isVariable();\n\n        const isNumber = TypeCheck.isNumber();\n\n        const isWhileLoop = TypeCheck.isWhileLoop();\n\n        const isPureEval = AdvancedTypeCheck.isPureEval();\n\n        //if _tokensr encounters anything like (\" or (, then that's a realtime print.\n\n        //buildstring will be applied now to create a string and push it into tokens. Buildstring is used to combine string tokens like\n        //['hello', 'Kalaam', 'developers', \"!\"] into 'hello kalaam developers!'.\n\n        //It's because cleaned_sourcedata is an array of tokens and each token is an individual word in a program.\n\n        //It's recommended to look at cleaned_sourcedata of every program to understand how it converts plain text into array of individual words.\n\n        const isRealTimePrintMultipleString = AdvancedTypeCheck.isRealTimePrintMultipleString();\n\n        //const isStringandValue = AdvancedTypeCheck.isStringandValue()\n\n        const isCalculation = AdvancedTypeCheck.isCalculation();\n\n        // const isDirectPrintArithmetic = AdvancedTypeCheck.isDirectPrintArithmetic()\n\n        //SECTION - Build Operations\n\n        //To convert ['hello', 'Kalaam', 'developers', \"!\"] into 'hello kalaam developers!'.\n\n        const BuildString = BuildOperation.BuildString();\n\n        //To convert ['[', 'x','y','z',']'] into ['x','y','z']\n\n        const BuildArray = BuildOperation.BuildArray();\n\n        //self function is the first step to handlle operations like  (ageone===10 && AverageAge<1000 && agetwo>100 || ageone===10) OR (ageone===10 )\n\n        const BuildCondition = BuildOperation.BuildCondition();\n\n        //This will run for every () statement encountered in the program, not just for loops\n\n        //ARGUMENTS TO PrintEngine are:\n        //Tokens- Tokens array\n        //memory- Variable-value pairs of variables\n        //j- Index of a token in Tokens array\n        //global- self or self\n        //iterator and OriginalIterator are used to print values in for and while loops.\n\n        function PrintEngine(Tokens, memory, j, iterator, OriginalIterator) {\n            //To understand what kind of data is necessary to print a value\n\n            //Getting the current token as token and value to be printed as NextTokenValue\n            //e.g. For (Name), Name is the NextTokenValue and it is the one which we will have to print\n\n            var StringVar = [];\n\n            var token = Tokens[j].value;\n\n            var NextTokenValue = Tokens.nextElement(j).value;\n            //Removing the brackets, if any.\n            var VariableToPrint = RemoveBrackets(NextTokenValue);\n\n            //SECTION - Outputting the code\n            // finding the variable value in memory. memory is where our Variable-value pairs exists.\n\n            //This loop is only for printing direct values like print(name), print(array)\n\n            memory.forEach((el) => {\n                //If we have a variable-value pair sitting in memory\n\n                if (el.name === VariableToPrint) {\n                    //for calculations like x=ageone+agetwo\n\n                    //If we have already calculated value in assigned_variables, use that or else move forward\n\n                    if (assigned_variables.includes(el) || assigned_variables.includes(el.name)) {\n                        handleOutput(el.value, kalaam);\n                    } else {\n                        //if the value found is a Number\n\n                        if (isNumber(el.value)) {\n                            handleOutput(el.value, kalaam);\n\n                            assigned_variables.push(el.name);\n                        }\n\n                        //if the value found is operations like age=2020-1996\n                        else if (isPureEval(el.value)) {\n                            //we are using Javascript's eval function to calculate direct arithmetic operations\n                            let outputpure = eval(el.value);\n\n                            el.value = outputpure;\n\n                            handleOutput(el.value, kalaam);\n\n                            assigned_variables.push(el.name);\n                        }\n\n                        //We will simplify this conditions as we move forward\n                        else if (!isPureEval(el.value) && !isNumber(el.value)) {\n                            if (!(el.name.includes(']') && el.name.includes('['))) {\n                                if (el.type === 'Array') {\n                                    if (!el.value.includes('[')) {\n                                        el.value = '[' + el.value.toString() + ']';\n                                    }\n                                }\n\n                                handleOutput(el.value, kalaam);\n\n                                assigned_variables.push(el.name);\n                            }\n                        }\n                    }\n                }\n            });\n\n            //This is how we print Array in Kalaam\n            if (Tokens[j + 1].type === 'Array') {\n                //To run only if iterator is present\n\n                //This runs on for loop - (Array[a]) etc\n\n                //self runs only if for(i) and in the loop, array[i], not on array[x]. For loop Iterator and index should be same, in self case 'i'\n\n                if (iterator != undefined && Tokens[j + 1].IndexInput === OriginalIterator) {\n                    let Value = NextTokenValue;\n\n                    let ArrayElement = CreateArrayElement(Value, iterator);\n\n                    let output = GetArrayorStringElement(ArrayElement, memory);\n\n                    output = RemoveQuotes(output);\n\n                    handleOutput(output, kalaam);\n\n                    assigned_variables.push(Tokens[j + 1]);\n                }\n\n                //This runs to Print(Array[2]) like specific array values\n                else if (Tokens[j + 1].IndexInput != OriginalIterator) {\n                    let Value = NextTokenValue;\n\n                    let IndexToChange = Tokens[j + 1].IndexInput;\n\n                    let ArrayElement = CreateArrayElement(Value, IndexToChange);\n\n                    let element = ArrayElement.replace(']', '');\n\n                    let Split = element.split('[');\n\n                    if (Split[1].includes('-') || Split[1].includes('+')) {\n                        let output = CalculateValues(Split[1], j, memory);\n\n                        Split[1] = output;\n\n                        Split = Split.join('[') + ']';\n                        ArrayElement = Split;\n                    }\n\n                    let token = memory.find((el) => el.name === Split[1]);\n\n                    if (token != undefined && OriginalIterator != Split[1]) {\n                        Split[1] = token.value;\n\n                        Split = Split.join('[') + ']';\n                        ArrayElement = Split;\n                    } else {\n                        ArrayElement = ArrayElement;\n                        ////\n                    }\n\n                    let output = GetArrayorStringElement(ArrayElement, memory);\n\n                    handleOutput(output, kalaam);\n                }\n            }\n\n            //printing direct numbers and direct calcultions like print(10), print(10*10)\n            else if (\n                token === ActiveLangugaeKeywords.Print &&\n        (isPureEval(RemoveBrackets(NextTokenValue)) || isNumber(RemoveBrackets(NextTokenValue)))\n            ) {\n                NextTokenValue = RemoveBrackets(NextTokenValue);\n\n                if (isNumber(NextTokenValue) && Tokens[j + 1].type != 'Calculation') {\n                    handleOutput(NextTokenValue, kalaam);\n                } else {\n                    let a = eval(NextTokenValue);\n\n                    handleOutput(a, kalaam);\n                }\n            }\n\n            //foroperations like print('you live, you learn')\n            else if (\n                Tokens[j + 1].mode === 'RealTimePrint' &&\n        !NextTokenValue.includes('+') /*&& !NextTokenValue.includes('=')*/\n            ) {\n                let output = RemoveBrackets(NextTokenValue);\n\n                output = RemoveQuotes(output);\n\n                handleOutput(output + '\\n', kalaam);\n            }\n\n            //operations like print(Age + 'is young age') i.e string concatenations\n            else if (Tokens[j + 1].mode === 'RealTimePrint' && NextTokenValue.includes('+')) {\n                let x = SplitElementsArray(NextTokenValue);\n\n                x = x.join('').split('+');\n\n                StringVar = SetValues(x, memory);\n\n                let output = StringVar.join(' ');\n\n                output = RemoveBrackets(output);\n                output = RemoveQuotes(output);\n\n                handleOutput(output + '\\n', kalaam);\n            } else if (isCalculation(RemoveBrackets(NextTokenValue)) && Tokens[j + 1].mode != 'RealTimePrint') {\n                NextTokenValue = RemoveBrackets(NextTokenValue);\n\n                let output = CalculateValues(NextTokenValue, j, memory);\n\n                handleOutput(output + '\\n', kalaam);\n            }\n\n            let message =\n        ' Computer     , ' + '\"' + RemoveBrackets(NextTokenValue) + '\"' + '    |';\n\n            //This is the experession whcih is getting evaluated.\n\n            let expression = token + NextTokenValue;\n            let description = ' VALUE  OUTPUT SCREEN     ()    ';\n\n            expression = GetcleanedExpression(expression);\n\n            let position = findtokenPositioninCode(LinebylineSourcedata, expression, true);\n            if (position != undefined) {\n                AddtoExecutionStack(\n                    ExecutionStack,\n                    ActiveLangugaeKeywords.Print,\n                    description,\n                    VariableToPrint,\n                    null,\n                    message,\n                    position\n                );\n            }\n        }\n\n        //END OF Functions and Imported Functions\n\n        //Out of all self function, PrintEngine is very important function. It prints variable values by searching their value in memory.\n\n        //SECTION - Checking each token and adding to tokens array\n\n        //_tokens takes two arguments. The cleaned_sourcedata array and current index of cleaned_sourcedata array\n\n        //_tokens is used to create a tokens array with each token having it's name, value, type and other metadata\n\n        //It performs operations depending upon whether the element is variable, array, function, loop etc.\n\n        //scanning every single element from cleaned_sourcedata array and pushing it to Tokens depending upon the type pf element\n\n        function _analyzeToken(cleaned_sourcedata, i, tokens) {\n            let element = cleaned_sourcedata[i];\n\n            skipParsing = 0;\n\n            let nextEl = cleaned_sourcedata.nextElement(i);\n            let prevEl = cleaned_sourcedata.prevElement(i);\n\n            let token_type = scanner(cleaned_sourcedata, i, tokens);\n            console.log('token_type:', token_type)\n            //Push variables to tokens\n            //Format: {type: \"variable\", value: \"ReverseString\"}\n\n            //whenever we need a certain handling, handlers.js is used\n            switch (token_type) {\n            case 'VARIABLE':\n                //Here we seperate Message = 'Hello' into following three tokens :\n\n                //1:{type:\"variable\",value:\"Message\"}\n\n                //2:{type:\"operator\",value:\"=\"}\n\n                //3:{type:\"value\",value:\"Hello\"}\n\n                let handled_variable = handleVariable(element, tokens, cleaned_sourcedata, i, nextEl, prevEl);\n                let h = handled_variable;\n                if (h != undefined) {\n                    try {\n                        h.type === 'variable' ? PushVariable(h, tokens) : console.log(`error in setting ${element}`);\n                    } catch (e) {\n                        console.log(e, `error in setting ${element}`);\n                    }\n                }\n                break;\n                //Push variables to tokens\n            case 'NUMBER':\n                PushNumber(element, tokens);\n                break;\n\n                //Push EmptyStrings to tokens\n            case 'EMPTY_STRING':\n                //In some cases empty strings will be modified into something like \"'\" or '\"'\n                //We convert it back to \" \"\n                try {\n                    let e = element;\n                    e =\n              e.length > 1 && (e.charAt(0) === '\\'' || e.charAt(0) === '\"') ? (e = e.replace(/['\"]+/g, '')) : (e = ' ');\n\n                    PushVariableValue(e, tokens);\n                } catch (e) {\n                    console.log(e, `Error in setting Empty string ${element}`);\n                }\n                break;\n\n                //Push Input to tokens\n                //Format: {type:\"AcceptInput\",value:\" \",AcceptAs:\"Message\"}\n            case 'INPUT':\n                try {\n                    PushInput(element, tokens, cleaned_sourcedata, i);\n                } catch (e) {\n                    console.log(e, `Error in setting Input ${element}`);\n                }\n                break;\n                //Push operators to tokens. The accepted operators are =,},{\n                //Format:{type:\"operator\",value:\"=\"}\n            case 'OPERATOR':\n                try {\n                    PushOperator(element, tokens);\n                } catch (e) {\n                    console.log(e, `Error in setting operator ${element}`);\n                }\n                break;\n\n                //Push keyowrds to tokens. The accepted keywords is \n\n                //Format: {type:\"keyword\",value:ActiveLangugaeKeywords.Print}\n            case 'PRINT':\n                try {\n                    PushKeyword(element, tokens);\n\n                    let ExpressiontoPrint = nextEl;\n\n                    if (!isRealTimePrintMultipleString(ExpressiontoPrint)) {\n                        PushExpression(ExpressiontoPrint, tokens);\n                    }\n                } catch (e) {\n                    console.log(e, `Error in printing ${element}`);\n                }\n                break;\n                //Push functions to tokens\n                //Format: {type: \"function\", value: \"First\", arguments: Array(2), FunctionInvocationExists: false, FunctionStack: Array(0), }\n            case 'FUNCTION':\n                try {\n                    PushFunctionData(element, tokens, cleaned_sourcedata, i);\n                } catch (e) {\n                    console.log(e, `Error in handling function ${element}`);\n                }\n                break;\n\n                // Push array to tokens\n\n            case 'ARRAY':\n                //Format: {type: \"Array\", value: \"[]\"}\n                //if empty array else build the array (To convert '[',1,2,3,4,']'  into [1,2,3,4]\n                try {\n                    let e = element;\n                    e.charAt(e.length - 1) === ']'\n                        ? PushArray(e, tokens)\n                        : function() {\n                            let BuiltArray = BuildArray(e, i, cleaned_sourcedata);\n\n                            PushArray(BuiltArray, tokens);\n                        };\n                } catch (e) {\n                    console.log(e, `Error in handling Array ${element}`);\n                }\n\n                break;\n\n                //For operations like Numbers[a]=a\n                //Format: {type:\"SetArrayIndexValue\",value:\"Fibonacci[a]\",ValueToSet:\"a\"}\n            case 'SET_ARRAY_INDEX':\n                try {\n                    PushSetArrayIndexValue(element, tokens, cleaned_sourcedata, i);\n\n                    cleaned_sourcedata.splice(i + 1, 1);\n                } catch (e) {\n                    console.log(e, `Error in setting array index value ${element}`);\n                }\n\n                break;\n\n                //For operations like a=Numbers[a], reverse of above\n                //Format: {type:\"GetArrayIndexValue\",value:\"Fibonacci[a-2]\"}\n            case 'GET_ARRAY_INDEX':\n                try {\n                    PushGetArrayIndexValue(element, tokens, cleaned_sourcedata, i);\n                } catch (e) {\n                    console.log(e, `Error in getting array index value ${element}`);\n                }\n                break;\n\n                //Push conditions to tokens. The accepted keywords are , , \n                // Format: {type:\"conditionalkeyword\",value:\"\"}\n                //Push while loops to tokens\n                //Format: {type: \"WhileLoopStart\", value: \"\"}, {type: \"condition\", value: \"count<25\"}\n\n            case 'CONDITIONAL_KEYWORD':\n                try {\n                    isWhileLoop(element) ? PushWhileLoop(element, tokens) : PushConditionalKeyword(element, tokens);\n\n                    //This is how we push conditions encountered in the sourcecode\n                    //Format:{type:\"condition\",value:\"a<3\"}\n                    let foundcondition = BuildCondition(element, i, cleaned_sourcedata);\n\n                    //Push conditions to tokens array\n\n                    if (foundcondition != '') {\n                        PushCondition(foundcondition, tokens);\n                    }\n                } catch (e) {\n                    console.log(e, `Error in operating on conditionals ${element}`);\n                }\n\n                break;\n\n                //Finding operations like Numbers.(x)\n                //Format: {type: \"PushToArray\", value: \"Numbers.(x)\"}\n            case 'PUSH_TO_ARRAY':\n                try {\n                    PushToArray(element, tokens);\n                } catch (e) {\n                    console.log(e, `Error in pushing the values to array ${element}`);\n                }\n                break;\n\n                //Push For loop to tokens\n                // Format:\n                // {type:\"ForLoopStart\",value:\"\"}\n                //{type:\"ForLoopArguments\",iterator:\"a\",value:\"(0,25)\",iterationStart:\"0\",iterationEnd:\"25\"}\n            case 'FOR_LOOP':\n                try {\n                    PushForLoop(element, tokens);\n                    PushForLoopAruguments(element, cleaned_sourcedata, i, tokens);\n\n                    memory.push({\n                        name: nextEl,\n                        value: 0,\n                        type: 'ForLoopIterator',\n                    });\n                } catch (e) {\n                    console.log(e, `Error in operating on for loop ${element}`);\n                }\n                break;\n\n                //Pushing basic Calculations like 'length-1' to tokens\n                //Format: {type:\"Calculation\",value:\"length-1\"}\n            case 'CALCULATION':\n                /* red zone\n  \n          if (nextEl != undefined) {\n            // this is to perform long calculations like AverageAge=(ageone+agetwo)/2 + (ageone+agetwo)*2\n  \n            while (isCalculation(cleaned_sourcedata[i])) {\n              el = el + cleaned_sourcedata[i];\n  \n              i++;\n            }\n          }\n  \n          console.log(\"el:\", el);\n  */\n                /*error prone*/\n\n                try {\n                    let el = element;\n                    let cal = '';\n                    let count = 0;\n                    //   function findCalculation(cleaned_sourcedata, i) {\n                    let x = i;\n                    let d = 0;\n\n                    while (isCalculation(cleaned_sourcedata[x]) || cleaned_sourcedata[x] == '+') {\n                        cal = cal + cleaned_sourcedata[x];\n                        count += 1;\n                        x++;\n                    }\n\n                    function isMultiCalculation(c, op = '*+/-') {\n                        if (c.includes('(') && c.includes(')')) {\n                            let s = c.split('');\n                            s.forEach((el) => {\n                                if (op.includes(el)) {\n                                    d = d + 1;\n                                }\n                            });\n\n                            if (d > 1) {\n                                return true;\n                            } else {\n                                return false;\n                            }\n                        }\n                    }\n\n                    let multiCal = isMultiCalculation(cal);\n\n                    //  console.log(\"x\", x, i);\n                    skipParsing = count - 1;\n                    // cal = RemoveBrackets(cal);\n\n                    //let c_el = RemoveBrackets(cal);\n\n                    //  let cal = findCalculation();\n\n                    // to stop prevention of expressions like is\"+ getting added as a calculation\n                    !cal.includes('\"') && !['/', '*', '\\'', '\"',].includes(el.charAt(0))\n                        ? PushCalculation(cal, tokens, cleaned_sourcedata, i, multiCal)\n                        : console.log(`impure calculation terms ${el}`);\n                } catch (e) {\n                    console.log(e, `Error in completing calculation ${element}`);\n                }\n                break;\n\n            case 'REALTIME_PRINT':\n                //finding operations like print(x + 'y'). The RealTimePrint operations\n\n                //Format: {type:\"value\",value:\"('Reversed String-'+ ReverseString)\",mode:\"RealTimePrint\"}\n                try {\n                    let { foundString, skip, } = handleRealtimePrint(cleaned_sourcedata, i);\n\n                    PushRealTimePrintOperation(foundString, tokens);\n\n                    skipParsing = skip;\n                } catch (e) {\n                    console.log(e, `Error in real time print ${element}`);\n                }\n\n                break;\n\n            case 'STRING':\n                //storing only the string values to tokens ( not the strings in print statements)\n                try {\n                    let s = BuildString(element, i, cleaned_sourcedata);\n\n                    s = s.replace(/['\"]+/g, '');\n\n                    !s.includes(ActiveLangugaeKeywords.Print)\n                        ? PushString(s, tokens)\n                        : console.log(`error in pushing string ${(s, element)}`);\n                } catch (e) {\n                    console.log(e, `error in operating on string ${element}`);\n                }\n                break;\n\n                //An extension of isPrintOperation() function\n                // Needs improvement\n\n                /*     else if (/^(?=.*?)(?=.*[a-z])/.test(element)) {\n                \n    \n                PushKeyword(element.slice(0, 6), tokens); //Pushing print keyword only\n    \n                PushExpression(element.slice(6), tokens); //Pushing remaining expression like (a), (Message) etc\n            }\n            */\n\n                //error prone change made here- Pushing expression in here\n                //Used to push functions and expressions\n                //Unnecessary data is being passed through kalaam.\n                //This was created for a temporary fix\n            case 'FUNCTION_CALL':\n                try {\n                    let CheckFunctionExpression = element.split('(');\n\n                    let passedValues = RemoveBrackets(CheckFunctionExpression[1]);\n                    passedValues = passedValues.split(',');\n\n                    PushFunctionExecution(element, tokens, cleaned_sourcedata, i, passedValues);\n                } catch (e) {\n                    console.log(e, `error in pushing function execution ${element}`);\n                }\n                break;\n\n            case 'NATIVE_OPERATION':\n                try {\n                    PushNativeOperation(element, tokens);\n                } catch (e) {\n                    console.log(e, `error in pushing native operaion ${element}`);\n                }\n                break;\n\n            case 'ARRAY_PUSH':\n                try {\n                    PushArray(element, tokens);\n                } catch (e) {\n                    console.log(e, `error in array push ${element}`);\n                }\n                break;\n            }\n        }\n\n        //making sense of tokens array coming from _parser.\n        function interpretToken(t, j, memory) {\n            skipInterpretation = 0;\n            let mutable_tokens = t;\n\n            let token = mutable_tokens[j].value;\n\n            let token_type = mutable_tokens[j].type;\n            let token_subtype = mutable_tokens[j].subtype;\n\n            let type = token === '' || token_type === 'operator' ? token_subtype : token_type;\n            //need to skip over some unncessary types\n\n            //operators are not working correctly\n            // no need to interpret over non-types\n            try {\n                if (isInterpretableType(type)) {\n                    switch (type) {\n                    case 'SetArrayIndexValue':\n                        {\n                            SetArrayIndexValue(\n                                mutable_tokens,\n                                j,\n                                j,\n                                memory,\n                                tokens,\n                                OriginalIterator,\n                                iterator,\n                                ExecutionStack,\n                                LinebylineSourcedata\n                            );\n                        }\n                        break;\n\n                    case 'assignment': {\n                        AssignorUpdateValues(\n                            mutable_tokens,\n                            j,\n                            memory,\n                            iterator,\n                            OriginalIterator,\n                            kalaam,\n                            ExecutionStack,\n                            LinebylineSourcedata\n              ); // eslint-disable-line\n\n                        break;\n                    }\n                    //type=assignment\n\n                    case 'PushToArray':\n                        {\n                            AddElementToArray(mutable_tokens, j, memory, ExecutionStack, LinebylineSourcedata);\n                        }\n                        break;\n                    case 'AcceptInput':\n                        {\n                            AcceptInputandSetValue(mutable_tokens, j, memory, ExecutionStack, LinebylineSourcedata);\n                        }\n                        break;\n\n                        //Whenever we encounter a function, we create a seperate execution context\n                    case 'function':\n                        {\n                            //We are preparing the required data to execute a function call later in the prgroam\n\n                            //functionsourcedata includes all the tokens from tokens array which belongs to a particular function\n                            skipInterpretation = 0;\n                            //We find self range or a function block through HandleBlocks function\n                            let { functionSourceData, } = prepareFunction(mutable_tokens, j);\n\n                            mutable_tokens[j].SourceData = functionSourceData;\n\n                            let message = ` ${ActiveLangugaeKeywords.Function}   ${token}        NEW VALUES      |`;\n\n                            let expression = `${ActiveLangugaeKeywords.Function} ${token}`;\n                            let description = '                | ';\n\n                            let position = findtokenPositioninCode(LinebylineSourcedata, expression, true);\n                            if (position != undefined) {\n                                AddtoExecutionStack(\n                                    ExecutionStack,\n                                    ActiveLangugaeKeywords.Function,\n                                    description,\n                                    mutable_tokens[j].value,\n                                    functionSourceData,\n                                    message,\n                                    position\n                                );\n                            }\n                            skipInterpretation = functionSourceData.length;\n                        }\n                        break;\n                        //We are out of the fucntion execution context and back to global execution context\n                    case 'condition':\n                        {\n                            let element = token;\n\n                            var message;\n\n                            //this function is the first step to calculate value of operations like  (ageone===10 && AverageAge<1000 && agetwo>100 || ageone===10) OR (ageone===10 )\n\n                            let ConditionValue = GetConditionValue(element, memory, j);\n\n                            kalaam.LastConditionValue.push(ConditionValue);\n\n                            //if value is false, just skip the if loop context, if not it will be ran in final print module\n\n                            if (!ConditionValue) {\n                                //  let InitializeLoop = tokens.indexOf(mutable_tokens[j]);\n\n                                //Handle Blocks is a function which takes care of nested block by taking care of nested { and } brackets\n                                //it uses the stack to push and pop brackets to accurately identify start and the end of the block\n                                let Returnvalue = HandleBlocks(mutable_tokens, j);\n\n                                //amount to skip if condition is false\n                                skipInterpretation = Returnvalue.j - j;\n\n                                message = `  ${element}  , FALSE()    COMPUTER        `;\n                            } else {\n                                message = ` ${element}  , TRUE()    COMPUTER       `;\n                            }\n\n                            let expression = element;\n                            let description = ' Certain Condition    Execution  Allow   ';\n\n                            expression = GetcleanedExpression(expression);\n\n                            let position = findtokenPositioninCode(LinebylineSourcedata, expression, true);\n                            if (position != undefined) {\n                                AddtoExecutionStack(\n                                    ExecutionStack,\n                                    ActiveLangugaeKeywords.If,\n                                    description,\n                                    element,\n                                    ConditionValue,\n                                    message,\n                                    position\n                                );\n                            }\n                        }\n\n                        break;\n                        //So that we don't print a same value twice. First in global execution context and the in function context\n\n                        //This one prints the global context values\n                    case 'print':\n                        {\n                PrintEngine(mutable_tokens, memory, j); // eslint-disable-line\n                        }\n                        break;\n\n                        //This runs our while loop .i.e \n                    case 'WhileLoopStart':\n                        {\n                            skipInterpretation = 0;\n                            let element = mutable_tokens[j + 1].value;\n\n                            let ExtratcedVariable = [];\n\n                            let variable = '';\n                            let WhileLoopSourcedataIndexStart = 0;\n                            let WhileLoopSourcedataTokens = [];\n\n                            for (let i = 0; i < element.length; i++) {\n                                let x = element.charAt(i);\n\n                                if (isVariable(x)) {\n                                    variable = variable + x;\n                                }\n                                if (!isVariable(element.charAt(i + 1)) && isVariable(x)) {\n                                    let token = memory.find((el) => el.name === variable);\n\n                                    ExtratcedVariable.push({\n                                        variable: variable,\n                                        value: token.value,\n                                        \n                                    });\n\n                                    variable = '';\n                                }\n                            }\n\n                            function getWhileLoopSourcedata(startIndex, mutable_tokens, StoreResult) {\n                                StoreResult = HandleBlocks(mutable_tokens, startIndex, StoreResult);\n\n                                return StoreResult;\n                            }\n\n                            WhileLoopSourcedataIndexStart = getLoopIndexStart(\n                                mutable_tokens,\n                                j,\n                                '{',\n                                WhileLoopSourcedataIndexStart\n                            );\n\n                            WhileLoopSourcedataTokens = getWhileLoopSourcedata(\n                                WhileLoopSourcedataIndexStart,\n                                mutable_tokens,\n                                WhileLoopSourcedataTokens\n                            ).StoreResult;\n\n                            let message = ' ' + element + '           ';\n\n                            let description = '    (Condition)           |';\n\n                            let expression = GetcleanedExpression(element);\n\n                            let position = findtokenPositioninCode(LinebylineSourcedata, expression, true);\n                            if (position != undefined) {\n                                AddtoExecutionStack(\n                                    ExecutionStack,\n                                    ActiveLangugaeKeywords.While,\n                                    description,\n                                    element,\n                                    WhileLoopSourcedataTokens,\n                                    message,\n                                    position\n                                );\n                            }\n\n                            //constantly accessing the conditionvalue\n\n\n                            while (GetConditionValue(element, memory, j + 1)) {\n                                for (let i = 0; i < WhileLoopSourcedataTokens.length; i++) {\n                                    //SECTION while loop context\n\n                                    if (WhileLoopSourcedataTokens[i].value === '=') {\n                                        AssignorUpdateValues(\n                                            WhileLoopSourcedataTokens,\n                                            i,\n                                            memory,\n                                            '',\n                                            '',\n                                            '',\n                                            ExecutionStack,\n                                            LinebylineSourcedata\n                                        );\n                                    } else if (WhileLoopSourcedataTokens[i].type === 'AcceptInput') {\n                                        AcceptInputandSetValue(WhileLoopSourcedataTokens, i, memory, ExecutionStack);\n                                    }\n\n                                    // Handling CONDITIONAL statements in While loop\n                                    else if (WhileLoopSourcedataTokens[i].type === 'condition') {\n                                        //if index returns a value, it means condition is false and skip the execution\n\n                                        let index = HandleConditions(WhileLoopSourcedataTokens, i, memory);\n\n                                        if (index != undefined) {\n                                            i = index;\n                                        } else {\n                                            i = i;\n                                        }\n                                    }\n\n                                    //Handling  statements in while loop\n                                    else if (WhileLoopSourcedataTokens[i].value === ActiveLangugaeKeywords.Print) {\n                      PrintEngine(WhileLoopSourcedataTokens, memory, i, ExecutionStack); // eslint-disable-line\n                                    }\n\n                                    //operations like Numbers[a]='xyz'\n                                    else if (WhileLoopSourcedataTokens[i].type === 'SetArrayIndexValue') {\n                                        SetArrayIndexValue(\n                                            WhileLoopSourcedataTokens,\n                                            i,\n                                            j,\n                                            memory,\n                                            tokens,\n                                            OriginalIterator,\n                                            iterator,\n                                            ExecutionStack,\n                                            LinebylineSourcedata\n                                        );\n                                    }\n                                }\n                            }\n                            skipInterpretation = WhileLoopSourcedataTokens.length;\n\n                            //End of While loop execution\n\n                            //Handling For loops\n                        }\n                        break;\n\n                    case 'ForLoopStart':\n                        {\n                var FlagPrimalLoop = 0; // eslint-disable-line\n\n                            var SourcedataTokens = [];\n\n                            var {\n                                OriginalIterator,\n                                IterationStart,\n                                IterationEnd,\n                                iterator,\n                                element,\n                                ForLoopSourcedataIndexStart,\n                                Cycle,\n                            } = ForLoopSetMetadata(mutable_tokens, j, memory);\n\n                            function getSourcedata(startIndex, mutable_tokens, StoreResult) {\n                                let Returnvalue = HandleBlocks(mutable_tokens, startIndex, StoreResult);\n                                StoreResult = Returnvalue.StoreResult;\n\n                                return StoreResult;\n                            }\n\n                            ForLoopSourcedataIndexStart = getLoopIndexStart(mutable_tokens, j, '{', ForLoopSourcedataIndexStart);\n\n                            SourcedataTokens = getSourcedata(ForLoopSourcedataIndexStart, mutable_tokens, SourcedataTokens);\n\n                            SourcedataTokens.forEach((el) => {\n                                el.isNestedLoop = false;\n                            });\n\n                            //Checking if the for loop has one more for loop inside it\n                            let FindNestedLoop = SourcedataTokens.find((el) => el.type === 'ForLoopStart');\n\n                            if (FindNestedLoop != undefined) {\n                                let NestedLoopindex = SourcedataTokens.indexOf(FindNestedLoop) + 3;\n                                let NestedLooplength =\n                    SourcedataTokens[NestedLoopindex].EndIndex - SourcedataTokens[NestedLoopindex].startIndex + 2;\n\n                                //if we have a nested loop, set isNesteLoop to TRUE\n\n                                for (let x = NestedLoopindex; x < NestedLoopindex + NestedLooplength; x++) {\n                                    SourcedataTokens[x].isNestedLoop = true;\n                                }\n                            }\n\n                            if (element.includes('(') && element.includes(',')) {\n                                FlagPrimalLoop = 1;\n                            }\n\n                            //Iterating over forloop sourcedata\n                            //self line 'iterator <= Cycle' determines start of the loop and the duration of the loop\n\n                            let message =\n                  '       ' +\n                  IterationStart +\n                  '  ' +\n                  IterationEnd +\n                  ' ,  ' +\n                  eval(IterationEnd - IterationStart + 1) +\n                  '  RUN()   |' +\n                  '\\n' +\n                  '  Computer, ' +\n                  '\"' +\n                  iterator +\n                  '\"' +\n                  '  Memory , ' +\n                  IterationStart +\n                  '  ' +\n                  IterationEnd +\n                  '  (Values)   |';\n\n                            //This is the experession whcih is getting evaluated.\n                            let expression = ' ' + iterator + '  ' + mutable_tokens[j + 1].value + ' ';\n                            let description = '    -  ';\n                            let Linenumber = LinebylineSourcedata.indexOf(expression);\n                            Linenumber += 1;\n\n                            AddtoExecutionStack(\n                                ExecutionStack,\n                                ActiveLangugaeKeywords.For,\n                                description,\n                                SourcedataTokens,\n                                '',\n                                message,\n                                Linenumber\n                            );\n\n                            for (iterator = IterationStart; iterator <= Cycle; iterator++) {\n                                let forloopindex = memory.find((el) => el.name === OriginalIterator);\n\n                                forloopindex.value = iterator;\n\n                                //flag to avoid running this code if loop is primal because the payload needs to be compeltely different\n                                if (FlagPrimalLoop === 0) {\n                                    // ForLoopArrayorStringOutput(elementValue, iterator, memory, self); // eslint-disable-line\n                                }\n\n                                for (let i = 0; i < SourcedataTokens.length; i++) {\n                                    // let isNested = SourcedataTokens[i].isNestedLoop;\n\n                                    //This code runs only if we have a nested loop situation\n                                    skipInterpretation = 0;\n                                    try {\n                                        interpretToken(SourcedataTokens, i, memory);\n                                    } catch (e) {\n                                        console.log(e, `error in interpreting for loop ${SourcedataTokens[i]}`);\n                                    }\n                                    if (skipInterpretation != 0) {\n                                        i = i + skipInterpretation;\n                                    }\n                                }\n                            }\n\n                            skipInterpretation = skipInterpretation + SourcedataTokens.length;\n                        }\n\n                        break;\n                        //END FOR LOOP EXECUTION\n                    case 'functionExecution': {\n                        //checking if function is invoked somewhere later in the program\n\n                        //If we see a function execution call, for e.g Add(x,y), we prepare for execution\n\n                        let functionSourceData = [];\n                        let functionName = token;\n\n                        let passedValues = mutable_tokens[j].passedValues;\n\n                        let functionToken = mutable_tokens.find((el) => el.value === functionName);\n\n                        let functionArguments = functionToken.arguments;\n\n                        functionSourceData = functionToken.SourceData;\n\n                        //Creating a seperate execution context and setting fucntion context name:value pair in functionContextmemory\n\n                        //for e.g x=3, y=4 is already defined and then we execute add(x,y)\n\n                        // This is an memory form limited to function context\n\n                        //Operating on function arguments and setting their values. For e.g the function add(x,y) might be called as add(3,4)\n\n                        //so we set x=3, y=4 and set self variable-value pair in functionContextmemory\n\n                        functionArguments.forEach((el, index) => {\n                            let val = passedValues[index];\n\n                            val = val.replace(/\"/g, '');\n                            val = val.replace(/'/g, '');\n\n                            passedValues[index] = val;\n\n                            //in self code we are filtering out arguments passed based on whether they already exist in updated tokens or not\n\n                            let FindInUpdatedTokens = memory.find((el) => el.name === val);\n\n                            //For passing same argument and same value to function  e.g function foo (fibonacci) and fibonacci is already declared with some value\n                            if (FindInUpdatedTokens === undefined) {\n                                functionContextmemory.push({\n                                    name: el,\n\n                                    value: val,\n\n                                    identifier: j + index,\n                                    type: 'value',\n                                    context: 'FunctionExecutionContext',\n                                });\n                            }\n\n                            //For passing different argument and value to function  e.g function foo (arr) and arr doesn't exist anywhere in tokens.\n                            else if (el != FindInUpdatedTokens.name && FindInUpdatedTokens != undefined) {\n                                functionContextmemory.push({\n                                    name: el,\n\n                                    value: FindInUpdatedTokens.value,\n\n                                    identifier: j + index,\n                                    type: FindInUpdatedTokens.type,\n                                    context: 'FunctionExecutionContext',\n                                    IntheEndSetValueto: val,\n                                });\n                            } else {\n                                functionContextmemory.push({\n                                    name: el,\n\n                                    value: val,\n\n                                    identifier: j + index,\n                                    type: FindInUpdatedTokens.type,\n                                    context: 'FunctionExecutionContext',\n                                    IntheEndSetValueto: val,\n                                });\n                            }\n                        });\n\n                        //Building a complete variable-value pair dataset\n\n                        var CompleteTokenValueList = [...memory, ...functionContextmemory,];\n\n                        let message =\n                'Computer ' +\n                '\"' +\n                functionName +\n                '\"' +\n                '      (Call)   |  ' +\n                '\"()\"' +\n                '     New Values   ' +\n                functionName +\n                '   ,  ' +\n                functionName +\n                '         |';\n\n                        let expression = functionName + '(';\n\n                        let description = '                | ';\n\n                        let position = findtokenPositioninCode(LinebylineSourcedata, expression, false);\n\n                        if (position != undefined) {\n                            AddtoExecutionStack(\n                                ExecutionStack,\n                                ActiveLangugaeKeywords.Function,\n                                description,\n                                functionName,\n                                functionSourceData,\n                                message,\n                                position\n                            );\n                        }\n\n                        //Now we start digging into the function execution\n                        //might have to change i to 1\n                        //skip in functionsourcedata\n                        for (let i = 0; i < functionSourceData.length; i++) {\n                            skipInterpretation = 0;\n                            try {\n                                interpretToken(functionSourceData, i, CompleteTokenValueList);\n                            } catch (e) {\n                                console.log(e, `error in interpreting function execution ${functionName}`);\n                            }\n                            if (skipInterpretation != 0) {\n                                i = i + skipInterpretation;\n                            }\n                        }\n                        break;\n                    }\n                    }\n                }\n            } catch (e) {\n                console.log(e, `Error in Interpreting token ${mutable_tokens[j]}`);\n            }\n            /* else if (token === \"\") {\n        let result = HandleBlocks(mutable_tokens, j, result);\n        // let StartofBlock = mutable_tokens[j + 1].startIndex;\n        let EndofBlock = mutable_tokens[j + 1].EndIndex;\n  \n        let lastValue = kalaam.LastConditionValue.pop();\n  \n        if (lastValue) {\n          j = EndofBlock;\n        }*/\n        }\n\n        //#STEP 1- Cleaning the sourcedata and setting the 'result' to 'cleaned_sourcedata'\n\n        //If a code is not working, it is probably because it's not cleaned properly.\n\n        cleaned_sourcedata = GetCleanSourcedata(sourcedata, cleaned_sourcedata, mixedimpurity);\n        console.log('cleaned_sourcedata:', cleaned_sourcedata)\n\n        //#STEP 2- - Parsing cleaned_sourcedata, adding each item depending on it's type to tokens array\n\n        // PARSING INITIATION\n        (function _parser() {\n            for (i; i < cleaned_sourcedata.length; i++) {\n                _analyzeToken(cleaned_sourcedata, i, tokens);\n\n                //Code to skip improve a particular part of cleaned_sourcedata if it's being operated by two different functions.\n                if (skipParsing != 0) {\n                    i = i + skipParsing;\n                }\n            }\n        })();\n\n        //CLEANING UP THE TOKENS ARRAY\n        //Removing tokens with value = '', It was generated due to \" cleaned_sourcedata = cleaned_sourcedata.replace(/(;|\\n|\\r)/gm, \" \").split(' ')\"\n\n        //Filtering seemed unnecessary, removed for now.\n        //tokens = tokens.filter(el => el.value != '')\n\n        //variableArray = tokens.filter((el) => el.type === 'variable');\n\n        //As of now, this is how the timeline looks\n\n        //raw sourcecode -> cleaned_sourcedata -> tokens\n\n        //#STEP 3 - evaluating conditions, running loops, executing functions finding values in memory and printing outputs\n\n        //This is the final section\n        //interpreting the code from syntax tree\n        (function _interpretor() {\n            for (let x = 0; x < tokens.length; x++) {\n                //We will be having a copy of tokens as mutable_tokens\n                interpretToken(tokens, x, memory);\n                if (skipInterpretation != 0) {\n                    x = x + skipInterpretation;\n                }\n            }\n        })();\n\n        //This is where error handling kicks in\n\n        //To find undefined variables\n\n        function onlyUnique(value, index, arr) {\n            return arr.indexOf(value) === index;\n        }\n\n        var assigned_variables = assigned_variables.filter(onlyUnique);\n\n        var difference = variables_array.filter((x) => !assigned_variables.includes(x));\n\n        if (difference.length > 0) {\n            difference.forEach((el) => {\n                kalaam.error.push(`Variable ${el} is undefined`);\n            });\n        }\n\n        kalaam.linebylineOutput = kalaam.error.length > 0 ? kalaam.error : kalaam.output.split('\\n');\n\n        //time taken to transpile the code is t1-t0\n    var t1 = performance.now(); // eslint-disable-line\n\n        if (kalaam.error.length === 0) {\n            let s = (t1 - t0).toPrecision(4);\n            kalaam.TimeTaken = ` | speed - ${s} ms`;\n        } else {\n            kalaam.isError = true;\n\n            kalaam.TimeTaken = 'Compilation Error: Check for assignement and declaration mistyping';\n        }\n\n        //kalaam.linebylineoutput is what you will finally see on output screen\n\n        kalaam.linebylineOutput = kalaam.linebylineOutput.filter(function(item) {\n            return item !== '';\n        });\n\n        kalaam.ExecutionStack = ExecutionStack;\n        return kalaam;\n    } catch (e) {\n        console.log(e);\n    }\n}\n"]}]}